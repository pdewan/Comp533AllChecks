//START OF FILE: src/centralizedwindow/acharacterdrawer.java
package centralizedWindow;


import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;
import windowApp.ACursorTrackerOfDelegateFrame;

public class ACharacterDrawer extends ACursorTrackerOfDelegateFrame implements  ListenablePainter {
	final static int CARAT_LENGTH = 10; 
	public ACharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}			
	public void paint (ADelegateFrame theDelegateFrame, ListenableGraphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();		
	}	
}
//END OF FILE
//START OF FILE: src/centralizedwindow/alogpainter.java
package centralizedWindow;

import java.util.ArrayList;
import java.util.List;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.SerializableGraphicsRequest;

public class ALogPainter implements LogPainter {
	List<SerializableGraphicsRequest> requests = new ArrayList();
	@Override
	public synchronized void paint(ADelegateFrame theFrame, ListenableGraphics g) {		
		for (SerializableGraphicsRequest request:requests) {
			paint(theFrame, g, request);
		}
		
		
	}
	public synchronized void add (SerializableGraphicsRequest theRequest) {
		//System.out.println("request added:" + theRequest);
		requests.add(theRequest);
	}
	public synchronized void clear() {
		//System.out.println("Log Cleared");
		requests.clear();
	}
	
    void  paint(ADelegateFrame theFrame, ListenableGraphics g, SerializableGraphicsRequest theRequest) {
		//System.out.println("Painting " + theRequest);
    	if (theRequest.getSource() != theFrame.getID())
			return;
    	g.processRequest(theRequest);
//		Object[] args = theRequest.getArgs();
//		if (theRequest.getName().equals(theRequest.DRAW_LINE)) {
//			//System.out.println("Drawing line ");
//			g.drawLine( (Integer) args[0],(Integer) args[1], (Integer) args[2], (Integer) args[3]);
//		} else if (theRequest.getName().equals(theRequest.DRAW_RECT)) {
//			g.drawRect( (Integer) args[0],(Integer) args[1], (Integer) args[2], (Integer) args[3]);
//		} else if (theRequest.getName().equals(theRequest.DRAW_OVAL)) {
//			g.drawOval( (Integer) args[0],(Integer) args[1], (Integer) args[2], (Integer) args[3]);
//		} else if (theRequest.getName().equals(theRequest.DRAW_STRING)) {
//			//System.out.println("Drawing String ");
//			g.drawString( (String) args[0], (Integer) args[1], (Integer) args[2]);
//		}
	}
	

}
//END OF FILE
//START OF FILE: src/centralizedwindow/amasterinputhandler.java
package centralizedWindow;
import util.awt.ADelegateFrame;
import util.awt.ASerializableFrameRequest;
import util.awt.AnOutputQueue;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;
import util.awt.SerializableFrameRequest;
public class AMasterInputHandler implements EventQueueHandler {	
	
	public void newEvent(SerializableEvent event) {
		if ( event.isResizeEvent() ) {	
			int frameId = event.getSource();
			ADelegateFrame frame = ADelegateFrame.getFrame(frameId);
			Object args[] = {frame.getWidth(), frame.getHeight()};
			SerializableFrameRequest request =  new ASerializableFrameRequest(frameId, SerializableFrameRequest.SET_SIZE, args);			
			AnOutputQueue.notifyListeners(request);
		}		
	}
}
//END OF FILE
//START OF FILE: src/centralizedwindow/areceivedrequestprocessor.java
package centralizedWindow;

import java.util.Collection;
import java.util.List;

import util.awt.ADelegateFrame;
import util.awt.ASerializableGraphicsRequest;
import util.awt.SerializableFrameRequest;
import util.awt.SerializableGraphicsRequest;
import util.session.ReceivedMessageListener;
import util.trace.Tracer;

public class AReceivedRequestProcessor implements ReceivedMessageListener {
	LogPainter logPainter;	
	public AReceivedRequestProcessor(LogPainter theLogPainter) {
		logPainter = theLogPainter;
	}
	@Override
	public void objectReceived(Object message, String sourceName) {		
		processRequest(message);
		
	}
	void processRequest(Object message) {
		if (message instanceof SerializableGraphicsRequest)
			processGraphicsRequest((ASerializableGraphicsRequest) message);
		else if ( message instanceof SerializableFrameRequest) {
			processFrameRequest((SerializableFrameRequest) message);
		}
		else if (message instanceof List) {
			processLog((List) message);			
		}
		
	}
	
	void processLog (List log) {
		for (Object request: log)	
			processRequest(request);
	}
	
	void processFrameRequest (SerializableFrameRequest request) {
		if (request.getName().equals(request.CREATE_FRAME)) {
			int width = (Integer) request.getArgs()[0];
			int height = (Integer) request.getArgs()[1];
			String title = (String) request.getArgs()[2];
			if (request.getSource() != ADelegateFrame.getAllFrames().size()) {
				Tracer.error("Received master frame id: " + request.getSource() + " Expecting: " + ADelegateFrame.getAllFrames().size());
			}
			ADelegateFrame frame = new ADelegateFrame(title);
			frame.addPainter(logPainter);
			frame.setSize(width, height);
			frame.setVisible(true);
			
		} else if (request.getName().equals(request.SET_SIZE)) {
			ADelegateFrame frame = ADelegateFrame.getFrame(request.getSource());
			frame.processRequest(request);
//			int width = (Integer) request.getArgs()[0];
//			int height = (Integer) request.getArgs()[1];
//			
//			frame.setSize(width, height);			
		}
//	} else if (request.getName().equals(request.SET_SIZE)) {
//		int width = (Integer) request.getArgs()[0];
//		int height = (Integer) request.getArgs()[1];
//		ADelegateFrame frame = ADelegateFrame.getFrame(request.getSource());
//		frame.setSize(width, height);			
//	}
		
		
	}
	void processGraphicsRequest (SerializableGraphicsRequest request) {
		if (request.getName().equals(SerializableGraphicsRequest.PAINT_START)) {
			logPainter.clear();
		} else if (request.getName().equals(SerializableGraphicsRequest.PAINT_END)) {
			ADelegateFrame frame = ADelegateFrame.getFrame(request.getSource());
			frame.repaint();
		} else
			logPainter.add(request);
		
	}

	@Override
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		
		
	}

	@Override
	public void clientLeft(String userName, String theApplicationName) {
		// TODO Auto-generated method stub
		
	}

}
//END OF FILE
//START OF FILE: src/centralizedwindow/aslaveinputhandler.java
package centralizedWindow;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;
import util.session.Communicator;
public class ASlaveInputHandler implements EventQueueHandler {
	Communicator multicastClient;
	String masterName;
	public ASlaveInputHandler(String theMasterName, Communicator theMulticaster) {		
		multicastClient = theMulticaster;
		masterName = theMasterName;
	}
	public void newEvent(SerializableEvent event) {
		if (event.isKeyEvent()  || event.isMousePressedEvent() || event.isResizeEvent() ) {			
			multicastClient.toClient(masterName, event);
			return;
		}		
	}
}
//END OF FILE
//START OF FILE: src/centralizedwindow/anapplicationlauncher.java
package centralizedWindow;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnApplicationLauncher implements ReceivedMessageListener{
	Communicator multicaster;
	OutputLoggerAndListener outputListenerAndLogger;
	public AnApplicationLauncher(Communicator theMulticaster, OutputLoggerAndListener theOutputListenerAndLogger) {
		multicaster = theMulticaster;
		outputListenerAndLogger = theOutputListenerAndLogger;
	}

	@Override
	public void objectReceived(Object message, String userName) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void clientJoined(String userName, String theApplicationName,
			String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		if (userName.equals(multicaster.getClientName())) {
			MasterCharacterDrawer.createCharacterDrawer("Frame 1");
		    MasterCharacterDrawer.createCharacterDrawer("Frame 2");
		    MasterCharacterDrawer.interceptOutput(multicaster, outputListenerAndLogger);
		}
		
	}

	@Override
	public void clientLeft(String userName, String theApplicationName) {
		// TODO Auto-generated method stub
		
	}

}
//END OF FILE
//START OF FILE: src/centralizedwindow/anoutputlogsender.java
package centralizedWindow;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnOutputLogSender implements ReceivedMessageListener {
	Communicator multicaster;
	OutputLoggerAndListener outputLogger;
	public AnOutputLogSender(Communicator theMulticaster, 
			OutputLoggerAndListener theOutputLogger) {
		multicaster = theMulticaster;
		outputLogger = theOutputLogger;
	}
	@Override
	public void objectReceived(Object message, String userName) {
				
	}

	@Override
	public void clientJoined(String userName, String theApplicationName,
			String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
//		if (userName.equals(multicaster.getUserName())) {
//			MasterCharacterDrawer.createCharacterDrawer("Frame 1");
//		    MasterCharacterDrawer.createCharacterDrawer("Frame 2");
//		    MasterCharacterDrawer.interceptOutput(multicaster, outputLogger);
//		} else
		if (!userName.equals(multicaster.getClientName()))
		    multicaster.toClient(userName, outputLogger.getOutputLog());		
	}

	@Override
	public void clientLeft(String userName, String theApplicationName) {
		
	}

}
//END OF FILE
//START OF FILE: src/centralizedwindow/anoutputloggerandlistener.java
package centralizedWindow;

import java.util.ArrayList;
import java.util.List;

import util.awt.SerializableFrameRequest;
import util.awt.SerializableGraphicsRequest;
import util.awt.SerializableRequest;
import util.session.Communicator;

public class AnOutputLoggerAndListener implements OutputLoggerAndListener{
	Communicator multicaster;
	List<SerializableRequest> outputLog = new ArrayList();
	public AnOutputLoggerAndListener(Communicator theMulticaster) {
		multicaster = theMulticaster;
	}
	@Override
	public void newFrameRequest(SerializableFrameRequest frameRequest) {
		outputLog.add(frameRequest);
		multicaster.toOthers(frameRequest);
		
		
	}
	@Override
	public void newGraphicsRequest(SerializableGraphicsRequest graphicsRequest) {
		outputLog.add(graphicsRequest);
		multicaster.toOthers(graphicsRequest);
		
	}
	@Override
	public List getOutputLog() {
		return outputLog;
	}
}
//END OF FILE
//START OF FILE: src/centralizedwindow/logpainter.java
package centralizedWindow;

import util.awt.ListenablePainter;
import util.awt.SerializableGraphicsRequest;

public interface LogPainter extends ListenablePainter{
	
	public void add (SerializableGraphicsRequest theRequest);
	public void clear();

}
//END OF FILE
//START OF FILE: src/centralizedwindow/mastercharacterdrawer.java
package centralizedWindow;


import java.util.List;

import old.replicatedWindow.ALocalMouseMotionListener;
import old.replicatedWindow.AReceivedEventForwarder;
import old.replicatedWindow.AReceivedTelePointerProcessor;
import old.replicatedWindow.ATelePointerManager;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.ReceivedMessageListener;
//import bus.uigen.ObjectEditor;
import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;
import util.awt.AnOutputQueue;
import widgets.TextFieldLauncher;

public class MasterCharacterDrawer  {
	static String APPLICATION_NAME = "Character Drawer";
	public static void launch (String[] args) {
		CommunicatorCreator multicasterFactory = CommunicatorSelector.getCommunicatorFactory();
		Communicator multicaster = multicasterFactory.getCommunicator(args[0],args[1],args[2], APPLICATION_NAME);
		ReceivedMessageListener remoteEventForwarder = new AReceivedEventForwarder();
		multicaster.addReceivedMessageListener(remoteEventForwarder);
		ATelePointerManager telePointerManager = new ATelePointerManager();
		ReceivedMessageListener receivedTelePointerProcessor = new AReceivedTelePointerProcessor(telePointerManager);
		multicaster.addReceivedMessageListener(receivedTelePointerProcessor);
		//ADelegateEventQueue.getDelegateEventQueue().addEventQueueHandler(new ASerializableEventBroadcaster(multicaster));
		OutputLoggerAndListener outputLoggerAndListener = new AnOutputLoggerAndListener(multicaster);
		ReceivedMessageListener outputLogSender = new AnOutputLogSender(multicaster, outputLoggerAndListener);
		multicaster.addReceivedMessageListener(outputLogSender);
//		ReceivedMessageListener applicationLauncher = new AnApplicationLauncher(multicaster,outputLoggerAndListener);
//		multicaster.addReceivedMessageListener(applicationLauncher);
		//AnInputQueue.getEventQueue().addEventQueueHandler(new ALocalMouseMotionListener(multicaster.getUserName(), telePointerManager ));
		AnInputQueue.addHandler(new ALocalMouseMotionListener(multicaster.getClientName(), telePointerManager ));
		AnInputQueue.addHandler(new AMasterInputHandler());
		AnOutputQueue.addOutputListener(outputLoggerAndListener);
		multicaster.join();
		createCharacterDrawer("Frame 1");
		TextFieldLauncher.createTextField("text field");
	    //createCharacterDrawer("Frame 2");
//		createCharacterDrawer("Frame 1");
//		createCharacterDrawer("Frame 2");
//		interceptOutput(multicaster, outputLoggerAndListener);
//		createCharacterDrawer("Frame 1", telePointerManager);
//		createCharacterDrawer("Frame 2", telePointerManager);
//		
		//ObjectEditor.edit(multicaster);
	}
	public static void interceptOutput(Communicator multicaster, OutputLoggerAndListener outputListener) {
		
		List<ADelegateFrame> allFrames = ADelegateFrame.getAllFrames();
		for (ADelegateFrame frame:allFrames) {
			frame.addOutputListener(outputListener);
			
		}
	}
//	public static void createCharacterDrawer (String theTitle, ATelePointerManager telePointerManager) {
//		ADelegateFrame delegateFrame = new ADelegateFrame();
//		delegateFrame.setTitle(theTitle);
//		delegateFrame.addPainter(telePointerManager);
//		ACharacterDrawer characterDrawer =  new ACharacterDrawer(delegateFrame);
//		delegateFrame.setSize(300, 400);
//		delegateFrame.setVisible(true);			
//	}	
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		//frame.setTitle(theTitle);
		new ACharacterDrawer(frame);
		frame.setSize(300, 200);
		frame.setVisible(true);		
		return frame;
	}
	public static void main (String[] args) {
		launch (new String[] {"localhost", "test",  "master"});
	}
}
//END OF FILE
//START OF FILE: src/centralizedwindow/outputloggerandlistener.java
package centralizedWindow;

import java.util.List;

import util.awt.OutputListener;

public interface OutputLoggerAndListener extends OutputListener{
	public List getOutputLog();

}
//END OF FILE
//START OF FILE: src/centralizedwindow/slavercharacterdrawer.java
package centralizedWindow;


import java.util.List;

import old.replicatedWindow.ALocalMouseMotionListener;
import old.replicatedWindow.AReceivedTelePointerProcessor;
import old.replicatedWindow.ATelePointerManager;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.ReceivedMessageListener;
//import bus.uigen.ObjectEditor;
import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;

public class SlaverCharacterDrawer {
	static String APPLICATION_NAME = "Character Drawer";
	public static void launch (String[] args) {
		//MessageSender multicastClient = new AMulticastClient(args);
		CommunicatorCreator messageSenderFactory = CommunicatorSelector.getCommunicatorFactory();
		Communicator multicaster = messageSenderFactory.getCommunicator(args[0],args[1],args[2], APPLICATION_NAME);
		String masterName = args[3];
		//ReceivedMessageListener remoteEventReceiver = new AReceivedEventForwarder(multicastClient);
//		ReceivedMessageListener remoteEventForwarder = new AReceivedEventForwarder();
//		multicaster.addReceivedMessageListener(remoteEventForwarder);
		ATelePointerManager telePointerManager = new ATelePointerManager();
		ReceivedMessageListener receivedTelePointerProcessor = new AReceivedTelePointerProcessor(telePointerManager);
		multicaster.addReceivedMessageListener(receivedTelePointerProcessor);
		LogPainter logPainter = new ALogPainter();
		ReceivedMessageListener receivedRequestProcessor = new AReceivedRequestProcessor(logPainter);
		multicaster.addReceivedMessageListener(receivedRequestProcessor);
		//ADelegateEventQueue.getDelegateEventQueue().addEventQueueHandler(new ALocalEventForwarder());
		AnInputQueue.getEventQueue().addEventQueueHandler(new ASlaveInputHandler(masterName, multicaster));
	
		AnInputQueue.getEventQueue().addEventQueueHandler(new ALocalMouseMotionListener(multicaster.getClientName(), telePointerManager ));
		//AMouseTracker mouseTracker = new AMouseTracker(telePointerManager, multicastClient);
		multicaster.join();
		addPainter(logPainter);
		
		//ObjectEditor.edit(multicaster);
	}
	public static void addPainter(LogPainter logPainter) {
		
		List<ADelegateFrame> allFrames = ADelegateFrame.getAllFrames();
		for (ADelegateFrame frame:allFrames) {
			frame.addPainter(logPainter);
			
		}
	}
	public static void main (String[] args) {
		launch (new String[] {"localhost", "test",  "slave", "master"});	}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/acharacterdrawer.java
package clean.centralizedWindow;

import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;
import windowApp.ACursorTrackerOfDelegateFrame;

public class ACharacterDrawer extends ACursorTrackerOfDelegateFrame implements  ListenablePainter {
	final static int CARAT_LENGTH = 10;
	public ACharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}
	public void paint (ADelegateFrame theDelegateFrame, ListenableGraphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();
	}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/amasterinputhandler.java
package clean.centralizedWindow;

import util.awt.ADelegateFrame;
import util.awt.ASerializableFrameRequest;
import util.awt.AnOutputQueue;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;
import util.awt.SerializableFrameRequest;

public class AMasterInputHandler implements EventQueueHandler {
	public void newEvent(SerializableEvent event) {
		if ( event.isResizeEvent() ) {
			int frameId = event.getSource();
			ADelegateFrame frame = ADelegateFrame.getFrame(frameId);
			Object args[] = {frame.getWidth(), frame.getHeight()};
			SerializableFrameRequest request =  new ASerializableFrameRequest(frameId, SerializableFrameRequest.SET_SIZE, args);
			AnOutputQueue.notifyListeners(request);
		}
	}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/anoutputlogsender.java
package clean.centralizedWindow;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnOutputLogSender implements ReceivedMessageListener {
	Communicator multicaster;
	OutputLoggerAndListener outputLogger;
	public AnOutputLogSender(Communicator theMulticaster, OutputLoggerAndListener theOutputLogger) {
		multicaster = theMulticaster;
		outputLogger = theOutputLogger;
	}
	public void objectReceived(Object message, String userName) {}
	public void clientJoined(String userName, String theApplicationName,
			String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		if (!userName.equals(multicaster.getClientName()))
		    multicaster.toClient(userName, outputLogger.getOutputLog());
	}
	public void clientLeft(String userName, String theApplicationName) {}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/anoutputloggerandlistener.java
package clean.centralizedWindow;

import java.util.ArrayList;
import java.util.List;

import util.awt.SerializableFrameRequest;
import util.awt.SerializableGraphicsRequest;
import util.awt.SerializableRequest;
import util.session.Communicator;

public class AnOutputLoggerAndListener implements OutputLoggerAndListener {
	Communicator multicaster;
	List<SerializableRequest> outputLog = new ArrayList();
	public AnOutputLoggerAndListener(Communicator theMulticaster) {
		multicaster = theMulticaster;
	}
    public void newFrameRequest(SerializableFrameRequest frameRequest) {
		outputLog.add(frameRequest);
		multicaster.toOthers(frameRequest);
	}
	public void newGraphicsRequest(SerializableGraphicsRequest graphicsRequest) {
		outputLog.add(graphicsRequest);
		multicaster.toOthers(graphicsRequest);
	}
	public List getOutputLog() {
		return outputLog;
	}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/mastercharacterdrawer.java
package clean.centralizedWindow;

import java.util.List;

import old.replicatedWindow.ALocalMouseMotionListener;
import old.replicatedWindow.AReceivedEventForwarder;
import old.replicatedWindow.AReceivedTelePointerProcessor;
import old.replicatedWindow.ATelePointerManager;
import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;
import util.awt.AnOutputQueue;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.ReceivedMessageListener;

public class MasterCharacterDrawer  {
	static String APPLICATION_NAME = "Character Drawer";
	public static void main (String[] args) {
		CommunicatorCreator multicasterFactory = CommunicatorSelector.getCommunicatorFactory();
		Communicator multicaster = multicasterFactory.getCommunicator(args[0],args[1],args[2], APPLICATION_NAME);
		ReceivedMessageListener remoteEventForwarder = new AReceivedEventForwarder();
		multicaster.addReceivedMessageListener(remoteEventForwarder);
		ATelePointerManager telePointerManager = new ATelePointerManager();
		ReceivedMessageListener receivedTelePointerProcessor = new AReceivedTelePointerProcessor(telePointerManager);
		multicaster.addReceivedMessageListener(receivedTelePointerProcessor);
		OutputLoggerAndListener outputLoggerAndListener = new AnOutputLoggerAndListener(multicaster);
		ReceivedMessageListener outputLogSender = new AnOutputLogSender(multicaster, outputLoggerAndListener);
		multicaster.addReceivedMessageListener(outputLogSender);
		AnInputQueue.addHandler(new ALocalMouseMotionListener(multicaster.getClientName(), telePointerManager ));
		AnInputQueue.addHandler(new AMasterInputHandler());
		AnOutputQueue.addOutputListener(outputLoggerAndListener);
		multicaster.join();
		createCharacterDrawer("Frame 1");
	}
	public static void interceptOutput(Communicator multicaster, OutputLoggerAndListener outputListener) {
		List<ADelegateFrame> allFrames = ADelegateFrame.getAllFrames();
		for (ADelegateFrame frame:allFrames) {
			frame.addOutputListener(outputListener);
		}
	}
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		new ACharacterDrawer(frame);
		frame.setSize(300, 200);
		frame.setVisible(true);
		return frame;
	}
}
//END OF FILE
//START OF FILE: src/clean/centralizedwindow/outputloggerandlistener.java
package clean.centralizedWindow;

import java.util.List;

import util.awt.OutputListener;

public interface OutputLoggerAndListener extends OutputListener{
	public List getOutputLog();

}
//END OF FILE
//START OF FILE: src/clean/windowapp/acharacterdrawer.java
package clean.windowApp;

import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.DelegateFramePainter;

public class ACharacterDrawer extends ACursorTrackerOfDelegateFrame implements DelegateFramePainter {
	final static int CARAT_LENGTH = 10;
	public ACharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}
	public void paint(ADelegateFrame theDelegateFrame, Graphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mouseClicked(MouseEvent event) {
		super.mouseClicked(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();
	}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/acursortracker.java
package clean.windowApp;

import java.awt.Frame;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

public class ACursorTracker implements MouseListener, KeyListener {
	Frame frame;
	int charX, charY;
	char lastChar;		
	public ACursorTracker(Frame theFrame) {
		frame = theFrame;
		frame.addMouseListener(this);
		frame.addKeyListener(this);
	}		
	public void mousePressed(MouseEvent event) {
		charX = event.getX();
		charY = event.getY();
		frame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		lastChar = event.getKeyChar();
		frame.repaint();		
	}	
	public void mouseEntered(MouseEvent event) {	}	
	public void mouseExited(MouseEvent event) {}	
	public void mouseClicked(MouseEvent event) {}	
	public void mouseReleased(MouseEvent event) {}	
	public void keyPressed(KeyEvent event) {}	
	public void keyReleased(KeyEvent event) {} 
}
//END OF FILE
//START OF FILE: src/clean/windowapp/acursortrackerofdelegateframe.java
package clean.windowApp;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import util.awt.ADelegateFrame;

public class ACursorTrackerOfDelegateFrame implements MouseListener, KeyListener {
	protected ADelegateFrame delegateFrame;
	protected int charX, charY;
	protected char lastChar;
	public ACursorTrackerOfDelegateFrame(ADelegateFrame theFrame) {
		delegateFrame = theFrame;
		delegateFrame.addMouseListener(this);
		delegateFrame.addKeyListener(this);
	}
	public void mousePressed(MouseEvent event) {
		charX = event.getX();
		charY = event.getY();
	}
	public void keyTyped(KeyEvent event) {
		lastChar = event.getKeyChar();
	}
	public void mouseEntered(MouseEvent event) {}
	public void mouseExited(MouseEvent event) {}
	public void mouseClicked(MouseEvent event) {}
	public void mouseReleased(MouseEvent event) {}	
	public void keyPressed(KeyEvent event) {}
	public void keyReleased(KeyEvent event) {}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/aglobalinputtracker.java
package clean.windowApp;

import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;
import util.awt.EventQueueHandler;
import util.awt.DelegateFramePainter;
import util.awt.SerializableEvent;

public class AGlobalInputTracker implements EventQueueHandler, MouseListener, KeyListener, DelegateFramePainter {
	String lastFrameTitle;
	ADelegateFrame globalFrame;
	int lastX, lastY;
	char lastChar = ' ';
	public AGlobalInputTracker(ADelegateFrame theGlobalFrame) {
		globalFrame = theGlobalFrame;
		globalFrame.addMouseListener(this);
		globalFrame.addKeyListener(this);
		globalFrame.addPainter(this);
		AnInputQueue.getEventQueue().addEventQueueHandler(this);
	}
	public void newEvent(SerializableEvent event) {
		if (event.getSource() == globalFrame.getID() ||
		    !event.isKeyEvent() && !event.isMousePressedEvent())
			return;
		int frameId = event.getSource();
		ADelegateFrame frame =  ADelegateFrame.getFrame(frameId);
		lastFrameTitle = frame.getTitle();
		globalFrame.processEvent(event);
	}
	public void paint(ADelegateFrame theFrame, Graphics g) {
		g.drawString(lastFrameTitle+':'+lastChar, lastX, lastY);
	}
	public void mousePressed(MouseEvent event) {
		lastX = event.getX();
		lastY = event.getY();
		globalFrame.repaint();
	}
    public void keyPressed(KeyEvent event) {
		lastChar = event.getKeyChar();
		globalFrame.repaint();
	}
	public void mouseClicked(MouseEvent arg0) {}
	public void mouseEntered(MouseEvent arg0) {}
	public void mouseExited(MouseEvent arg0) {}
	public void mouseReleased(MouseEvent arg0) {}
	public void keyReleased(KeyEvent arg0) {}
	public void keyTyped(KeyEvent arg0) {}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/aglobalpainter.java
package clean.windowApp;

import util.awt.ADelegateFrame;
import util.awt.AnOutputQueue;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;
import util.awt.OutputListener;
import util.awt.SerializableFrameRequest;
import util.awt.SerializableGraphicsRequest;

public class AGlobalPainter implements ListenablePainter, OutputListener {
	SerializableGraphicsRequest lastGraphicsRequest;
	String lastFrameTitle;
	ADelegateFrame globalFrame;
	public AGlobalPainter(ADelegateFrame theGlobalFrame) {
		globalFrame = theGlobalFrame;
		globalFrame.addPainter(this);
		AnOutputQueue.addOutputListener(this);
	}
	public void paint(ADelegateFrame theFrame, ListenableGraphics g) {
		if (lastGraphicsRequest == null) return;
		Object[] args = lastGraphicsRequest.getArgs();			
		g.drawString(lastFrameTitle+':'+(String) args[0], (Integer) args[1], (Integer) args[2]);
	}
	public void newGraphicsRequest(SerializableGraphicsRequest graphicsRequest) {
		if (graphicsRequest.getSource() == globalFrame.getID() ||
	       !graphicsRequest.getName().equals(SerializableGraphicsRequest.DRAW_STRING))
			 return;
		lastGraphicsRequest = graphicsRequest;
		lastFrameTitle = ADelegateFrame.getFrame(graphicsRequest.getSource()).getTitle();
		globalFrame.repaint();
	}
    public void newFrameRequest(SerializableFrameRequest frameRequest) {}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/alistenablecharacterdrawer.java
package clean.windowApp;

import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;

public class AListenableCharacterDrawer extends ACursorTrackerOfDelegateFrame implements ListenablePainter {
	final static int CARAT_LENGTH = 10;
	public AListenableCharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}
	public void paint (ADelegateFrame theDelegateFrame, ListenableGraphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();		
	}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/aninheritingcharacterdrawer.java
package clean.windowApp;

import java.awt.Frame;
import java.awt.Graphics;

import util.awt.ADelegateFrame;

public class AnInheritingCharacterDrawer extends Frame {
	final static int CARAT_LENGTH = 10; 
	ADelegateFrame delegateFrame;
	int charX, charY;
	char c;	
	
	public void paint(Graphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + c, charX, charY);
	}	
}
//END OF FILE
//START OF FILE: src/clean/windowapp/characterdrawerlauncher.java
package clean.windowApp;

import util.awt.ADelegateFrame;

public class CharacterDrawerLauncher {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
	}
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		new ACharacterDrawer(frame);
		frame.setSize(300, 200);
		frame.setVisible(true);
		return frame;
	}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/globalpaintercomposerandlauncher.java
package clean.windowApp;

import util.awt.ADelegateFrame;

public class GlobalPainterComposerAndLauncher {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
		createGlobalFrameAndPainter();
	}
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		new AListenableCharacterDrawer(frame);
//		frame.add(new TextField("I am a text field"));
		frame.setSize(300, 200);
		frame.setVisible(true);
		return frame;
	}
	public static ADelegateFrame createGlobalFrameAndPainter() {
		ADelegateFrame globalFrame = new ADelegateFrame("global frame");
		new AGlobalPainter(globalFrame);
		globalFrame.setSize(300, 200);
		globalFrame.setVisible(true);
		return globalFrame;
	}
}
//END OF FILE
//START OF FILE: src/clean/windowapp/globaltrackercomposerandlauncher.java
package clean.windowApp;

import util.awt.ADelegateFrame;

public class GlobalTrackerComposerAndLauncher extends CharacterDrawerLauncher {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
		createGlobalFrameAndPainter();
	}
	public static ADelegateFrame createGlobalFrameAndPainter() {
		ADelegateFrame globalFrame = new ADelegateFrame("global frame");
		new AGlobalInputTracker(globalFrame);
		globalFrame.setSize(300, 200);
		globalFrame.setVisible(true);
		return globalFrame;
	}
}
//END OF FILE
//START OF FILE: src/echo/modular/ahistory.java
package echo.modular;

import im.OperationName;

import java.util.ArrayList;
import java.util.List;

import trace.echo.modular.ListEditMade;
import trace.echo.modular.ListEditNotified;
import util.annotations.Tags;
import util.tags.ApplicationTags;
import util.tags.InteractiveTags;

@Tags({ApplicationTags.HISTORY, InteractiveTags.MODEL})

public class AHistory<ElementType> implements History<ElementType> {

	List<ElementType> history = new ArrayList();
	List<HistoryObserver<ElementType>> observers = new ArrayList();
	int normalizedIndex(int index) {
		return index > size()?size(): index;
	}
	public synchronized void add(int anIndex, ElementType anElement) {
//		if (anIndex > size()) {
//			anIndex = size();
//			Tracer.error("Received index greater than size, appending object");
//		}
		history.add(normalizedIndex(anIndex), anElement);
		ListEditMade.newCase(OperationName.ADD, anIndex, anElement, this);
	}
	
	public synchronized void add(ElementType anElement) {
//		if (anIndex > size()) {
//			anIndex = size();
//			Tracer.error("Received index greater than size, appending object");
//		}
		history.add(history.size(), anElement);
	}
	
	public synchronized void observableAdd(ElementType anElement) {
//		if (anIndex > size()) {
//			anIndex = size();
//			Tracer.error("Received index greater than size, appending object");
//		}
		observableAdd (history.size(), anElement);		
	}

	public synchronized void observableAdd(int anIndex, ElementType anElement) {
		add(anIndex, anElement);
		notifyObservers(normalizedIndex(anIndex), anElement);
	}

	@Override
	public int size() {
		return history.size() ;
	}
	@Override
	public ElementType get(int index) {
		return history.get(index);
	}
//	public synchronized void add(int index, ElementType input) {
//		super.add(index, input);
//		notifyObservers(input);
//	}

	@Override
	public void addObserver(HistoryObserver<ElementType> anObserver) {
		observers.add(anObserver);
	}
	
	public void notifyObservers(int index, ElementType newValue) {
		ListEditNotified.newCase(OperationName.ADD, index, newValue, this);
		for (HistoryObserver<ElementType> observer:observers)
			observer.elementAdded(index, newValue);
	}
}
//END OF FILE
//START OF FILE: src/echo/modular/amodularechodemoerandtester.java
package echo.modular;

import java.util.List;

import trace.echo.modular.ModularEchoTraceChecker;
import util.trace.Traceable;
import bus.uigen.models.DemoerAndTester;
import echo.monolithic.AMonolithicEchoDemoerAndTester;

public class AModularEchoDemoerAndTester extends AMonolithicEchoDemoerAndTester implements DemoerAndTester{

	protected boolean modularityTestSucceeded;
	protected boolean modularityTranscriptTestSucceeded;

	
	public AModularEchoDemoerAndTester() {
//		computeFinalHistory();
	}
	public AModularEchoDemoerAndTester(boolean anInteractive) {
		super(anInteractive);
	}
	
	
	 
	
	

	
	
	protected Class echoClass() {
		return 	AnEchoComposerAndLauncher.class;
	}
	protected   Boolean testAgainstCorrectTranscripts(List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		boolean superTestSucceeded = super.testAgainstCorrectTranscripts(aTestTraceableList, aCorrectTraceableList);
		modularityTranscriptTestSucceeded =  ModularEchoTraceChecker.compareMVCSequences(aTestTraceableList, aCorrectTraceableList);
		return superTestSucceeded && modularityTranscriptTestSucceeded;
	}
//	@Override
//	public Boolean testAgainstCorrectTranscripts() {
//		boolean superTestSucceeded = super.testAgainstCorrectTranscripts();
////		modularityTranscriptTestSucceeded = ModularEchoTraceChecker.compareMVCSequences(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//		modularityTranscriptTestSucceeded = testAgainstCorrectTranscripts(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//
//		return superTestSucceeded && modularityTranscriptTestSucceeded;
//
//	}
//	
	@Override
	public boolean intraSequenceTest(List<Traceable> aTraceableList) {
		boolean superTestSucceeded = super.intraSequenceTest(aTraceableList);
		modularityTestSucceeded =  ModularEchoTraceChecker.intraSequenceCheckModularEchoer(aTraceableList);
		System.out.println( "Intra Sequence Check, Modularity:" + modularityTestSucceeded );
		return superTestSucceeded &
				modularityTestSucceeded;

	}
	
//	@Override
//	public Boolean test() {
//		boolean superTestSucceeded = super.test();
////		modularityTestSucceeded = ModularEchoTraceChecker.intraSequenceCheckModularEchoer(getGlobalTraceableList());
//		modularityTestSucceeded = intraSequenceCheck(getGlobalTraceableList());
//
//		return superTestSucceeded &
//				modularityTestSucceeded;
//
//	}

//	public Boolean executeLoadAndTest(Boolean aCorrectTranscripts, Boolean aTestAgainstCorrectTranscripts) {	
//		return super.executeLoadAndTest(aCorrectTranscripts, aTestAgainstCorrectTranscripts) & // not short-circuit on purpose 
//				ModularEchoTraceChecker.checkModularEchoer(getGlobalTraceableList());
//	}
//	public Boolean test(Boolean aTestAgainstCorrectTranscripts) {	
//		// not short-circuit on purpose 
//		boolean retVal1 = super.test(aTestAgainstCorrectTranscripts);
//		boolean retVal2 = ModularEchoTraceChecker.checkModularEchoer(getGlobalTraceableList());
//		boolean retVal = retVal1 & retVal1; // not short-circuit on purpose 
//		if (aTestAgainstCorrectTranscripts)
//			return retVal & 
//				ModularEchoTraceChecker.compareMVCSequences(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//		else
//			return retVal;
//	}
}
//END OF FILE
//START OF FILE: src/echo/modular/anechocomposerandlauncher.java
package echo.modular;

import trace.echo.modular.EchoTracerSetter;
import util.annotations.Tags;
import util.tags.ApplicationTags;
import util.tags.InteractiveTags;
import util.trace.Tracer;


@Tags({ApplicationTags.ECHOER, InteractiveTags.COMPOSER})
public class AnEchoComposerAndLauncher implements EchoerComposerAndLauncher{
	protected History<String> history;	
	protected EchoerInteractor interactor;	
	public void composeAndLaunch(String[] args) {		
		compose(args);
		launch();
		
	}
	public void launch() {
		interactor.doInput();
	}
	// factory method
	protected History<String> createHistory() {
		return new AHistory();
	}
	// factory method
	protected EchoerInteractor createInteractor() {
		return new AnEchoInteractor(history);
	}	
	public void compose(String[] args) {
		history = createHistory();
//		interactor = createInteractor();
//		history.addObserver(interactor);
		connectModelInteractor();
	}
	protected void connectModelInteractor() {
		interactor = createInteractor();
		history.addObserver(interactor);
	}
	public History<String> getHistory() {
		return history;
	}
	public EchoerInteractor getInteractor() {
		return interactor;
	}
	public static void main (String[] args) {
//		System.out.println("setting traces");
//		Tracer.showInfo(true);
		EchoTracerSetter.traceEchoer();
		(new AnEchoComposerAndLauncher()).composeAndLaunch(args);		
	}
}
//END OF FILE
//START OF FILE: src/echo/modular/anechointeractor.java
package echo.modular;
import im.OperationName;

import java.util.Scanner;

import echo.monolithic.MonolithicEchoer;
import trace.echo.modular.ListEditInput;
import trace.echo.modular.ListEditObserved;
import util.annotations.Tags;
import util.tags.ApplicationTags;
import util.tags.InteractiveTags;
@Tags({ApplicationTags.ECHOER, InteractiveTags.INTERACTOR})
public class AnEchoInteractor implements EchoerInteractor {
	
	protected History<String> history;
	public static final String PROMPT = "Please enter an input line or " +
		     QUIT + " or " + HISTORY;
	public AnEchoInteractor(History<String> aHistory) {
		history = aHistory;
	}
	public AnEchoInteractor() {
	}
	public void doInput() {
		for (;;) {
//			System.out.println("Please enter an input line or " +
//				     QUIT + " or " + HISTORY);
//			System.out.println(Thread.currentThread());
			System.out.println(PROMPT);
			Scanner scanner = new Scanner(System.in);
			String nextInput = scanner.nextLine();
			if (nextInput.equals(QUIT)) {
				processQuit();
				break;
			} else if (nextInput.equals(HISTORY))
				printHistory();
			else
			    processInput(nextInput);
		}
	}
	public static final String echo(String anInput) {
		return anInput + ECHO_INDICATOR;
	}
	protected void displayOutput(String newValue) {
		System.out.println(echo(newValue));
	}
	// overridden by IMInteractor
	protected void addToHistory(String newValue) {
//		int anIndex = history.size();
//		history.observableAdd(history.size(), newValue);
		history.observableAdd(newValue);

	}
	protected void processInput(String newValue) {
//		displayOutput(newValue);
		ListEditInput.newCase(OperationName.ADD, history.size(), newValue, this);
		addToHistory(newValue);
	}
	protected void processQuit() {
		System.out.println("Quitting application");
	}
	public static String toString(History aHistory) {
		StringBuilder stringBuilder = new StringBuilder();
		for (int index = 0; index < aHistory.size(); index++) {
			stringBuilder.append(aHistory.get(index));			
			stringBuilder.append((index == aHistory.size() - 1)? "\n":", ");
		}		
		return stringBuilder.toString();
	}
	public synchronized void printHistory() {
//		System.out.println(Thread.currentThread());

		System.out.println(toString(history));
//		for (int index = 0; index < history.size(); index++) {
//			System.out.print(history.get(index));
//		}
//		System.out.println();
	}
	@Override
	public void elementAdded(int anIndex, Object aNewValue) {
		ListEditObserved.newCase(OperationName.ADD, anIndex, aNewValue, this);
		displayOutput(history.get(anIndex));
	}

}
//END OF FILE
//START OF FILE: src/echo/modular/echoutility.java
package echo.modular;

import java.beans.PropertyChangeEvent;

public class EchoUtility {
	public static boolean localEchoOf(PropertyChangeEvent aConsoleModelEvent, String anInput ) {
		String aText = aConsoleModelEvent.getNewValue().toString();
//		return aText.contains(anInput) && (aText.contains(EchoerInteractor.ECHO_INDICATOR));

//		return 	aText.contains(AnEchoerInteractor.echo(anInput));
		return localEchoOf(aText, anInput);
		
	}
	public static boolean localEchoOf(String aText, String anInput ) {
//		return aText.contains(anInput) && (aText.contains(EchoerInteractor.ECHO_INDICATOR));

		return 	aText.contains(AnEchoInteractor.echo(anInput));
		
	}


}
//END OF FILE
//START OF FILE: src/echo/modular/echoercomposerandlauncher.java
package echo.modular;

import replicatedWindow.CommunicatorBasedComposerAndLauncher;


public interface EchoerComposerAndLauncher {
	public History<String> getHistory();
	public EchoerInteractor getInteractor();
	public void compose(String[] args);
	public void composeAndLaunch(String[] args);
	public void launch();

}
//END OF FILE
//START OF FILE: src/echo/modular/echoerinteractor.java
package echo.modular;

import echo.monolithic.MonolithicEchoer;

public interface EchoerInteractor extends HistoryObserver {
	public static final String ECHO_INDICATOR = MonolithicEchoer.ECHO_INDICATOR;
	public static final String QUIT = MonolithicEchoer.QUIT;
	public static final String HISTORY = MonolithicEchoer.HISTORY;
	public void doInput() ;
	public  void printHistory() ;
//	String toString(History aHistory);

}
//END OF FILE
//START OF FILE: src/echo/modular/filetotraceabletester.java
package echo.modular;

import java.util.List;

import bus.uigen.trace.TraceUtility;
import util.trace.Traceable;

public class FileToTraceableTester {
	public static void main (String[] args) {
		List<Traceable> retVal = TraceUtility.toTraceableList("traceLog.txt");
		System.out.println(retVal);
	}

}
//END OF FILE
//START OF FILE: src/echo/modular/history.java
package echo.modular;


public interface History<ElementType> {
	 void add(int index, ElementType input) ;
	 void add(ElementType input);
//	 void add(ElementType input) ;
	 void observableAdd(int index, ElementType input) ;
	 void observableAdd(ElementType input) ;
	 int size();
	 ElementType get(int index);
	 void addObserver(HistoryObserver<ElementType> anObserver) ;
		
}
//END OF FILE
//START OF FILE: src/echo/modular/historyobserver.java
package echo.modular;

public interface HistoryObserver<ElementType> {
	void elementAdded(int anIndex, ElementType aNewValue);

}
//END OF FILE
//START OF FILE: src/echo/modular/launcherofmodularcorrectloggenerator.java
package echo.modular;

import trace.echo.EchoTraceChecker;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.echo.modular.EchoTracerSetter;
import util.misc.ThreadSupport;
import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfModularCorrectLogGenerator {
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AModularEchoDemoerAndTester(anInteractive);
	}
	public static void main(String args[]) {
		// make sure that AnEchoerComposerAndLauncher has echoing of tracer
		ConsoleTraceSetter.traceConsole();	// needed for Echo Tracer
		DemoerAndTester aDemoer = createDemoer(false);
		// correct
		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
		// test
//		Boolean retVal = aDemoer.executeLoadAndTest(false, true);
		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/echo/modular/launcherofmodularechodemoer.java
package echo.modular;

import trace.echo.modular.ModularEchoTraceChecker;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfModularEchoDemoer {
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AModularEchoDemoerAndTester(anInteractive);
	}
	public static void main(String args[]) {
		DemoerAndTester aDemoer = createDemoer(true);
		aDemoer.demo();
		aDemoer.terminate();

	}

}
//END OF FILE
//START OF FILE: src/echo/modular/launcherofmodularechotester.java
package echo.modular;

import trace.echo.EchoTraceChecker;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.echo.modular.EchoTracerSetter;
import util.misc.ThreadSupport;
import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfModularEchoTester {
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AModularEchoDemoerAndTester(anInteractive);
	}
	public static void main(String args[]) {
		// make sure that AnEchoerComposerAndLauncher has echoing of tracer
		ConsoleTraceSetter.traceConsole();	// needed for Echo Tracer
//		EchoTracerSetter.traceEchoer();
		DemoerAndTester aDemoer = createDemoer(false);
		// correct
//		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
		// test
		Boolean retVal = aDemoer.executeLoadAndTest(false, true);
		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/echo/monolithic/amonolithicechodemoerandtester.java
package echo.monolithic;

import static im.IMUtililties.remoteEchoOf;
import static util.models.ConsoleModelUtility.containsText;
import static util.models.ConsoleModelUtility.getText;
import static util.models.ConsoleModelUtility.isConsole;
import static util.models.ConsoleModelUtility.isInfo;
import static util.models.ConsoleModelUtility.isOutput;
import static util.models.ConsoleModelUtility.isOutputLine;
import static util.trace.session.SessionTraceUtility.clientJoined;
import im.AHistoryInCoupler;
import im.BobIM;

import java.beans.PropertyChangeEvent;
import java.util.List;

import trace.echo.EchoTraceChecker;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.im.IMTraceChecker;
import util.annotations.Tags;
import util.misc.ThreadSupport;
import util.models.ConsoleModel;
import util.tags.ApplicationTags;
import util.trace.Traceable;
import bus.uigen.models.ADemoerAndTester;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;
import bus.uigen.trace.TraceUtility;
@Tags(ApplicationTags.ECHOER)
public class AMonolithicEchoDemoerAndTester extends ADemoerAndTester implements DemoerAndTester{
	protected ConsoleModel echoConsole;
	protected boolean echoTestSucceeded;
	protected boolean echoTranscriptTestSucceeded;

	public static long DEFAULT_TIME_OUT = 5000;
//	
//	protected MainClassListLauncher launcher;
	protected String[] poem = {
			"The woods are lovely dark and deep",			 
			"But I have promises to keep",  			 
			"And miles to go before I sleep"
	};
	
	public AMonolithicEchoDemoerAndTester() {
//		computeFinalHistory();
	}
	public AMonolithicEchoDemoerAndTester(boolean anInteractive) {
		super(anInteractive);
	}
	
	
	
	
	@Override
	public void executeAll() {		
		consoleModels = launcher.getOrCreateConsoleModels();
		echoConsole = consoleModels.get(0);
		launcher.addConsolesPropertyChangeListener(this);
		launcher.executeAll();	
		echoConsole.setInput(poem[0]);
		// replace these with wait for clearance etc
//		ThreadSupport.sleep(1000);
		echoConsole.setInput(poem[1]);
		ThreadSupport.sleep(1000);
		echoConsole.setInput(poem[2]);
//		ThreadSupport.sleep(1000);
		ThreadSupport.sleep(getTimeOut());
		notifyInteractionTermination();

	
	}
	public static long getTimeOut() {
		return DEFAULT_TIME_OUT;
	}
	
	
	protected Class echoClass() {
		return 	MonolithicEchoer.class;
	}
	
	protected Class[] composeMainClasses() {
		return new Class[] {
			echoClass()			
		};
	}
	
//	public Boolean executeLoadAndTest(Boolean aGenerateCorrectTranscripts, Boolean aTestAgainstCorrectTranscripts) {
//		super.executeLoadAndTest(aGenerateCorrectTranscripts, aTestAgainstCorrectTranscripts);
////		return EchoTraceChecker.checkEchoer(getGlobalTraceableList());
//		boolean retVal = EchoTraceChecker.checkInputOutSequences(getGlobalTraceableList());
//		return retVal;
//	}
	
	public boolean intraSequenceTest(List<Traceable> aTraceableList) {
//		System.out.println("Intra Sequence Check: Echoer");
		echoTestSucceeded =  EchoTraceChecker.matchInputOutSequences(aTraceableList);
		System.out.println("Intra Sequence Check: Echoer:" + echoTestSucceeded);
		return echoTestSucceeded;
	}
	@Override
	public Boolean test() {
//		echoTestSucceeded = EchoTraceChecker.checkInputOutSequences(getGlobalTraceableList());
//		return echoTestSucceeded;
		return intraSequenceTest(getGlobalTraceableList());
	}
	protected   Boolean testAgainstCorrectTranscripts(List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		echoTranscriptTestSucceeded = EchoTraceChecker.compareInputOutSequences(aTestTraceableList, aCorrectTraceableList);
		System.out.println("Inter sequence echo:" + echoTranscriptTestSucceeded);
		return echoTranscriptTestSucceeded;
				
	}
	@Override
	public Boolean testAgainstCorrectTranscripts() {
		return testAgainstCorrectTranscripts(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//		System.out.println("Comparing echo sequences");
//		echoTranscriptTestSucceeded = EchoTraceChecker.compareInputOutSequences(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//		System.out.println("Inter sequence echo:" + echoTranscriptTestSucceeded);
//
//		return echoTranscriptTestSucceeded;
	}
	
//	public Boolean test(Boolean aTestAgainstCorrectTranscripts) {
////		return EchoTraceChecker.checkEchoer(getGlobalTraceableList());
//		boolean retVal1 = EchoTraceChecker.checkInputOutSequences(getGlobalTraceableList());
//		if (aTestAgainstCorrectTranscripts)
//			return retVal1 & EchoTraceChecker.compareInputOutSequences(getGlobalTraceableList(), getCorrectGlobalTraceableList());
//		else
//			return retVal1;
//	}
	
	public static String echoOf(String anInput) {
		return MonolithicEchoer.echo(anInput);
	}
	
	
	public static boolean echoOf(PropertyChangeEvent aConsoleModelEvent, String anInput) {
		if (!isOutputLine(aConsoleModelEvent)) return false;
		String aText = aConsoleModelEvent.getNewValue().toString();
//		return aText.contains(MonolithicEchoer.echo(anInput));
		return aText.contains(echoOf(anInput));

		
	}





	


}
//END OF FILE
//START OF FILE: src/echo/monolithic/launcherofmonolithicechocorrectloggenerator.java
package echo.monolithic;

import trace.echo.EchoTraceChecker;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.echo.modular.EchoTracerSetter;
import util.misc.ThreadSupport;
import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfMonolithicEchoCorrectLogGenerator extends LauncherOfMonolithicEchoDemoer{
	public static DemoerAndTester createDemoer() {
		return new AMonolithicEchoDemoerAndTester(false);
	}
	public static void main(String args[]) {
		ConsoleTraceSetter.traceConsole(); // needed for comparing outputs
		DemoerAndTester aDemoer = createDemoer();
		
		Boolean retVal = aDemoer.executeLoadAndTest(true, false);

//		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
//		MainClassListLauncher aLauncher = aDemoer.createAndDisplayLauncher();
//		aDemoer.generateCorrectTranscripts();
//		aDemoer.executeAll();
//		aDemoer.waitForInteractionTermination();
//		try {
//			aLauncher.waitForAll();
//		} catch (InterruptedException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		aDemoer.loadTraceables();
////		aLauncher.terminateAll();
//
////		System.out.println(EchoTraceChecker.check(aDemoer.getGlobalTraceableList()));
//		System.out.println(EchoTraceChecker.checkEchoer(aDemoer.getGlobalTraceableList()));
//
//		System.out.println(ModularEchoTraceChecker.checkModularEchoer(aDemoer.getGlobalTraceableList()));

		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/echo/monolithic/launcherofmonolithicechodemoer.java
package echo.monolithic;

import trace.echo.modular.ModularEchoTraceChecker;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfMonolithicEchoDemoer {
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AMonolithicEchoDemoerAndTester(anInteractive);
	}
	public static void main(String args[]) {
		DemoerAndTester aDemoer = createDemoer(true);
		aDemoer.demo();
		aDemoer.terminate();
//		aDemoer.terminate();
//		aDemoer.executeAll();

	}

}
//END OF FILE
//START OF FILE: src/echo/monolithic/launcherofmonolithicechotester.java
package echo.monolithic;

import trace.echo.EchoTraceChecker;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.echo.modular.EchoTracerSetter;
import util.misc.ThreadSupport;
import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfMonolithicEchoTester extends LauncherOfMonolithicEchoDemoer{
	public static DemoerAndTester createDemoer() {
		return new AMonolithicEchoDemoerAndTester(false);
	}
	public static void main(String args[]) {
		ConsoleTraceSetter.traceConsole(); // needed for comparing outputs
		
		DemoerAndTester aDemoer = createDemoer();
		// generate correct
//		Boolean retVal = aDemoer.executeLoadAndTest(false);
		// test
//		Boolean retVal = aDemoer.executeLoadAndTest(true, false);

		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
//		MainClassListLauncher aLauncher = aDemoer.createAndDisplayLauncher();
//		aDemoer.generateCorrectTranscripts();
//		aDemoer.executeAll();
//		aDemoer.waitForInteractionTermination();
//		try {
//			aLauncher.waitForAll();
//		} catch (InterruptedException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		aDemoer.loadTraceables();
////		aLauncher.terminateAll();
//
////		System.out.println(EchoTraceChecker.check(aDemoer.getGlobalTraceableList()));
//		System.out.println(EchoTraceChecker.checkEchoer(aDemoer.getGlobalTraceableList()));
//
//		System.out.println(ModularEchoTraceChecker.checkModularEchoer(aDemoer.getGlobalTraceableList()));

		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/echo/monolithic/monolithicechoer.java
package echo.monolithic;
import im.OperationName;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import trace.echo.modular.ListEditInput;
import trace.echo.modular.ListEditObserved;
import util.annotations.Tags;
import util.tags.ApplicationTags;
import util.tags.InteractiveTags;
@Tags({ApplicationTags.ECHOER})
public class MonolithicEchoer  {
	
	protected static List<String> history = new ArrayList();
	public static final String ECHO_INDICATOR = "[Echo]";
	public static final String QUIT = "quit";
	public static final String HISTORY = "history";	
	public static void main(String[] anArgs) {
		for (;;) {
			System.out.println("Please enter an input line or " +
				     QUIT + " or " + HISTORY);
			Scanner scanner = new Scanner(System.in);
			String nextInput = scanner.nextLine();
			if (nextInput.equals(QUIT)) {
				processQuit();
				break;
			} else if (nextInput.equals(HISTORY))
				printHistory();
			else
			    processInput(nextInput);
		}
	}
	/*
	 * Utlity function for tester not used in this program but should probably be
	 * in this class
	 */
	public static boolean isInput(String anInput) {
		return !anInput.equals(QUIT) && !anInput.equals(HISTORY) ;
		
	}
	public static final String echo(String anInput) {
		return anInput + ECHO_INDICATOR;
	}
	protected static void displayOutput(String newValue) {
		System.out.println(echo(newValue));
	}
	protected  static void addToHistory(String newValue) {
		history.add(history.size(), newValue);
	}
	protected static void processInput(String newValue) {
		addToHistory(newValue);
		displayOutput(newValue);

	}
	protected static void processQuit() {
		System.out.println("Quitting application");
	}
	public static String toString(List aHistory) {
		StringBuilder stringBuilder = new StringBuilder();
		for (int index = 0; index < aHistory.size(); index++) {
			stringBuilder.append(aHistory.get(index));			
			stringBuilder.append((index == aHistory.size() - 1)? "\n":", ");
		}		
		return stringBuilder.toString();
	}
	public static  void printHistory() {
		System.out.println(toString(history));
	}
	

}
//END OF FILE
//START OF FILE: src/echo/monolithic/tester.java
package echo.monolithic;

public interface Tester {
	void test();

}
//END OF FILE
//START OF FILE: src/editor/ot/abobconsistentnpersoneditor.java
package editor.ot;
// need to start OTSessionManagerServer
public class ABobConsistentNPersonEditor {
	public static void main (String[] args) {
		args = new String[] {"localhost", "testsession", "bob"};
		AConsisentNPersonEditor.main(args);
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/acathyconsistentnpersoneditor.java
package editor.ot;
// need to start OTSessionManagerServer
public class ACathyConsistentNPersonEditor {
	public static void main (String[] args) {
		args = new String[] {"localhost", "testsession", "cathy"};
		AConsisentNPersonEditor.main(args);
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/aconsisent2personeditor.java
package editor.ot;
import old.echoerAndIM.ASessionAwarenessProvider;
import old.echoerAndIM.AnIMComposerAndLauncher;
import util.session.ReceivedMessageFilterSelector;
import util.session.SentMessageFilterSelector;
import util.session.Communicator;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.trace.Tracer;
import widgets.AnColabTextFieldComposerAndLauncher;
import widgets.TextField;
public class AConsisent2PersonEditor {
	public static final String APPLICATION_NAME = "Widgets Editor";
	static Communicator communicator;
	public static void main (String[] args) {
		Tracer.showInfo(true);
		Communicator communicator = AnIMComposerAndLauncher.createCommunicator(args, APPLICATION_NAME);
		communicator.addSessionMessageListener(new ASessionAwarenessProvider());
		TextField textField = AnColabTextFieldComposerAndLauncher.createCollaborativeTextField("text 1", communicator);
		communicator.setMinimumDelayToServer(5000);
		addConsistencyModules(args[2], communicator);
		communicator.join();
		
	}
	public static void addConsistencyModules(String userName, Communicator communicator) {
		OTManager otManager;
		if (userName.equals("alice"))
			otManager = new AnOTManager(true);
		else
			otManager = new AnOTManager(false);			
		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = 
			new AnOTReceivedMessageQueuerCreator(otManager);
		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = 
			new AnOTSentMessageQueuerCreator(otManager);
		ReceivedMessageFilterSelector.setMessageFilterFactory(receivedMessageQueuerCreator);
		SentMessageFilterSelector.setMessageFilterCreator(sentMessageQueuerCreator);
	}
}
//END OF FILE
//START OF FILE: src/editor/ot/aconsisentnpersoneditor.java
package editor.ot;
import old.echoerAndIM.ASessionAwarenessProvider;
import old.echoerAndIM.AnIMComposerAndLauncher;
import util.session.ReceivedMessageFilterSelector;
import util.session.SentMessageFilterSelector;
import util.session.Communicator;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.trace.Tracer;
import widgets.AnColabTextFieldComposerAndLauncher;
import widgets.TextField;
public class AConsisentNPersonEditor {
	public static final String APPLICATION_NAME = "Widgets Editor";
	static Communicator communicator;
	public static void main (String[] args) {
		Tracer.showInfo(true);
		addConsistencyModules(args[2], communicator);
		Communicator communicator = AnIMComposerAndLauncher.createCommunicator(args, APPLICATION_NAME);
		communicator.addSessionMessageListener(new ASessionAwarenessProvider());
		TextField textField = AnColabTextFieldComposerAndLauncher.createCollaborativeTextField("text 1", communicator);
		communicator.setMinimumDelayToServer(5000);
		communicator.join();
		
	}
	public static void addConsistencyModules(String userName, Communicator communicator) {
		OTManager otManager;		
		otManager = new AnOTManager(false);			
		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = 
			new AnOTReceivedMessageQueuerCreator(otManager);
		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = 
			new AnOTSentMessageQueuerCreator(otManager);
		ReceivedMessageFilterSelector.setMessageFilterFactory(receivedMessageQueuerCreator);
		SentMessageFilterSelector.setMessageFilterCreator(sentMessageQueuerCreator);
	}
}
//END OF FILE
//START OF FILE: src/editor/ot/atransformableedit.java
package editor.ot;

import widgets.Edit;

public class ATransformableEdit implements TransformableEdit {	
	Edit edit;
	boolean isServer;
	public ATransformableEdit(Edit  theEdit, boolean theIsServer) {
		edit = theEdit;
		isServer = theIsServer;		
	}
	
	public Edit getEdit() {
		return edit;
	}
	
	public void setEdit(Edit newVal) {
		this.edit = newVal;
	}
	
	public boolean isServer() {
		return isServer;
	}
	
	public void setServer(boolean isServer) {
		this.isServer = isServer;
	}
	public String toString() {
		return edit.toString() + " isServer:" + isServer;
	}
	public TransformableEdit copy() {
		return new ATransformableEdit(edit.copy(), isServer);
	}
}
//END OF FILE
//START OF FILE: src/editor/ot/analiceconsistentnpersoneditor.java
package editor.ot;
// need to start OTSessionManagerServer
public class AnAliceConsistentNPersonEditor {
	public static void main (String[] args) {
		args = new String[] {"localhost", "testsession", "alice"};
		AConsisentNPersonEditor.main(args);
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/aneditwithottimestamp.java
package editor.ot;

public class AnEditWithOTTimeStamp implements EditWithOTTimeStamp {
	TransformableEdit edit;
	OTTimeStamp otTimeStamp;
	public AnEditWithOTTimeStamp(TransformableEdit theEdit, OTTimeStamp theTimeStamp ) {
		edit = theEdit;
		otTimeStamp = theTimeStamp;
	}
	public  TransformableEdit getTransformableEdit() {
		return edit;
	}
	public  void setTransformableEdit(TransformableEdit theCharInsertion) {
		edit = theCharInsertion;
	}
//	public TransformableEdit getCharInsertion() {
//		return edit;
//	}
//	public void setCharInsertion(TransformableEdit charInsertion) {
//		this.edit = charInsertion;
//	}
	public OTTimeStamp getOTTimeStamp() {
		return otTimeStamp;
	}
	public void setOTTimeStamp(OTTimeStamp otTimeStamp) {
		this.otTimeStamp = otTimeStamp;
	}
	public String toString() {
		return edit.toString() + " TS:" + otTimeStamp;
	}
	
}
//END OF FILE
//START OF FILE: src/editor/ot/anotmanager.java
package editor.ot;

import java.util.ArrayList;
import java.util.List;

import util.models.ABoundedBuffer;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.trace.Tracer;
import widgets.Edit;

public class AnOTManager implements OTManager {
//	BoundedBuffer<ReceivedMessage> inQueue;
	ABoundedBuffer<SentMessage> outQueue;
	boolean isServer ;
	OTTimeStamp myOTTimeStamp = new AnOTTimeStamp();	
	//Communicator communicator;
	List<SentMessage> sentMessages = new ArrayList();
	OperationTransformer operationTransformer = AnOperationTransfomerSelector.getOperationTransformer();
	
	public AnOTManager (boolean theIsServer) {
		isServer = theIsServer;
	}	

//	@Override
//	public synchronized void put(ReceivedMessage message) {
//		if (message.isUserMessage()) {
//			//Message.info ("OT Manager receiving message:" + message.getUserMessage());
//			EditWithOTTimeStamp receivedTSEdit = 
//				(EditWithOTTimeStamp) message.getUserMessage();			
//			processReceivedMessage(receivedTSEdit);
//			message.setUserMessage(receivedTSEdit.getTransformableEdit().getEdit());
//			//myOTTimeStamp.incrementRemoteCount();
//			//Message.info("After received:" +myOTTimeStamp + " isServer:" + isServer);
//
//		}
//		if (inQueue != null)
//			inQueue.put(message);			
//				
//	}
	
	public void processTimeStampedEdit(EditWithOTTimeStamp receivedTSEdit) {
		Tracer.info("Transforming:" + receivedTSEdit);
		int firstConcurrentMessageIndex = sentMessages.size();
		for (int i = 0; i < sentMessages.size(); i++) {
			EditWithOTTimeStamp sentTSEdit = (EditWithOTTimeStamp )sentMessages.get(i).getUserMessage();
			if (sentTSEdit.getOTTimeStamp().isConcurrent(receivedTSEdit.getOTTimeStamp())) {
				Tracer.info("found concurrent sent message " + sentTSEdit);
				firstConcurrentMessageIndex = i;
				break;
			}
		}
		for (int deleteNum = 0; deleteNum < firstConcurrentMessageIndex; deleteNum++ ) {
			sentMessages.remove(0);			
		}
		TransformableEdit receivedTransformableEdit = receivedTSEdit.getTransformableEdit();
		Tracer.info("Transforming repeatedly received:" + receivedTSEdit);
		//myOTTimeStamp.incrementRemoteCount();
		for (SentMessage sentMessage:sentMessages) {
			EditWithOTTimeStamp sentTSEdit = (EditWithOTTimeStamp )sentMessage.getUserMessage();
			Tracer.info("transforming wrt buffered:" + sentTSEdit);
			TransformableEdit sentTransformableEdit = sentTSEdit.getTransformableEdit();
			Edit transformedReceived = operationTransformer.transform(
						receivedTransformableEdit, sentTransformableEdit);
			Edit transformedSent = operationTransformer.transform(sentTransformableEdit, receivedTransformableEdit);
			sentTransformableEdit.setEdit(transformedSent);

			receivedTransformableEdit.setEdit(transformedReceived);
			sentTSEdit.getOTTimeStamp().incrementRemoteCount();
			receivedTSEdit.getOTTimeStamp().incrementRemoteCount();	
			Tracer.info("buffered transformed to:" + sentTSEdit);
			Tracer.info("Received transformed to:" + receivedTSEdit);
		}
		myOTTimeStamp.incrementRemoteCount();
		Tracer.info("Transformed:" + receivedTSEdit);
		Tracer.info("My Time Stamp:" + myOTTimeStamp);
	}
	
	

//	@Override
//	public synchronized void put(SentMessage message) {
//		if (message.isUserMessage()) {
//			Edit edit = (Edit) message.getUserMessage();
//			EditWithOTTimeStamp timeStampedEdit = processSentEdit(edit);
//			message.setUserMessage(timeStampedEdit);			
////			Message.info ("OT Manager sending message:" + message.getUserMessage());
////			myOTTimeStamp.incrementLocalCount();
////			Edit edit = (Edit) message.getUserMessage();
////			TransformableEdit transformableEdit = new ATransformableEdit(edit, isServer);
////			EditWithOTTimeStamp timeStampedEdit = new AnEditWithOTTimeStamp(transformableEdit, myOTTimeStamp.copy());			
////			message.setUserMessage(timeStampedEdit);
////			Message.info("After send:" +myOTTimeStamp + " isServer:" + isServer);
////			Message.info("Enquing:" + message);
//
//		}
//		if (outQueue != null)
//			outQueue.put(message);
//		SentMessage messageClone = (SentMessage) Misc.deepCopy(message);
//		sentMessages.add(messageClone);
//	}
	public void storeSentMessage(SentMessage message) {
		sentMessages.add(message);
	}
	public EditWithOTTimeStamp processSentEdit(Edit edit ) {
		Tracer.info ("Raw Edit:" + edit);
		myOTTimeStamp.incrementLocalCount();
		TransformableEdit transformableEdit = new ATransformableEdit(edit, isServer);
		EditWithOTTimeStamp timeStampedEdit = new AnEditWithOTTimeStamp(transformableEdit, myOTTimeStamp.copy());			
		return timeStampedEdit;
		
	}
	

//	@Override
//	public void setReceivedMessageQueue(BoundedBuffer<ReceivedMessage> theBuffer) {
//		inQueue = theBuffer;
//	}
//
//	@Override
//	public void setSentMessageQueue(BoundedBuffer<SentMessage> theBuffer) {
//		outQueue = theBuffer;
//	}

	
//	public void setClients(Map<MessageReceiver, String> theClients)	{
//		Collection<String> values = theClients.values();
//		for (String clientName:values) {
//			System.out.println("TS for" + clientName);
//			myOTTimeStamp.addUser(clientName);
//		}
//		
//	}
	
	
	

}
//END OF FILE
//START OF FILE: src/editor/ot/anotreceivedmessagequeuer.java
package editor.ot;

import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.ReceivedMessage;

public class AnOTReceivedMessageQueuer implements MessageFilter<ReceivedMessage> {
	OTManager otManager;
	MessageProcessor<ReceivedMessage> receivedMessageQueue;
	public AnOTReceivedMessageQueuer(OTManager theOTManager) {
		otManager = theOTManager;
	}
	@Override
	public void filterMessage(ReceivedMessage message) {
		if (!message.isUserMessage() ) {
			receivedMessageQueue.processMessage(message);
			return;
		}		
		EditWithOTTimeStamp receivedTSEdit = 
			(EditWithOTTimeStamp) message.getUserMessage();			
		otManager.processTimeStampedEdit(receivedTSEdit);
		message.setUserMessage(receivedTSEdit.getTransformableEdit().getEdit());		
		receivedMessageQueue.processMessage(message);		
	}
	@Override
	public void setMessageProcessor(MessageProcessor<ReceivedMessage> theMesssageProcessor) {
		receivedMessageQueue = theMesssageProcessor;		
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anotreceivedmessagequeuercreator.java
package editor.ot;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;

public class AnOTReceivedMessageQueuerCreator  implements MessageFilterCreator<ReceivedMessage>{
	MessageFilter<ReceivedMessage> receivedMessageQueuer;
	OTManager otManager;
	public AnOTReceivedMessageQueuerCreator(OTManager theOTManager) {
		otManager = theOTManager;
		receivedMessageQueuer =  new AnOTReceivedMessageQueuer(otManager);
	}
	@Override
	public MessageFilter<ReceivedMessage> getMessageFilter() {
		return receivedMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anotsentmessagequeuer.java
package editor.ot;

import util.misc.Common;
import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.SentMessage;
import util.session.SentMessageType;
import widgets.Edit;

public class AnOTSentMessageQueuer implements MessageFilter<SentMessage> {
	OTManager otManager;
	MessageProcessor<SentMessage> sentMessageQueue;
	public AnOTSentMessageQueuer(OTManager theCausalityManager) {
		otManager = theCausalityManager;
	}

	@Override
	public synchronized void filterMessage(SentMessage message) {
		if (!message.isUserMessage() || message.getSentMessageType() != SentMessageType.Others) {
			sentMessageQueue.processMessage(message);
			return;
		}
		Edit edit = (Edit) message.getUserMessage();
		EditWithOTTimeStamp timeStampedEdit = otManager.processSentEdit(edit);
		message.setUserMessage(timeStampedEdit);			
//			Message.info ("OT Manager sending message:" + message.getUserMessage());
//			myOTTimeStamp.incrementLocalCount();
//			Edit edit = (Edit) message.getUserMessage();
//			TransformableEdit transformableEdit = new ATransformableEdit(edit, isServer);
//			EditWithOTTimeStamp timeStampedEdit = new AnEditWithOTTimeStamp(transformableEdit, myOTTimeStamp.copy());			
//			message.setUserMessage(timeStampedEdit);
//			Message.info("After send:" +myOTTimeStamp + " isServer:" + isServer);
//			Message.info("Enquing:" + message);

		//}
		sentMessageQueue.processMessage(message);
		SentMessage messageClone = (SentMessage) Common.deepCopy(message);
		otManager.storeSentMessage(messageClone);
	}

	@Override
	public void setMessageProcessor(MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageQueue = theMesssageProcessor;		
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anotsentmessagequeuercreator.java
package editor.ot;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.SentMessage;

public class AnOTSentMessageQueuerCreator  implements MessageFilterCreator<SentMessage>{
	MessageFilter<SentMessage> sentMessageQueuer;
	OTManager otManager;
	public AnOTSentMessageQueuerCreator(OTManager theOTManager) {
		otManager = theOTManager;
		sentMessageQueuer =  new AnOTSentMessageQueuer(otManager);
	}
	@Override
	public MessageFilter<SentMessage> getMessageFilter() {
		return sentMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anotservermessagequeuer.java
package editor.ot;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import util.misc.Common;
import util.session.ASentMessage;
import util.session.MessageProcessor;
import util.session.SentMessage;
import util.session.SentMessageType;
import util.session.ServerMessageFilter;
import util.trace.Tracer;
import widgets.Edit;
// A multicaster sender that puts the message in multiple queues, one for each client
// Each queue is a separate OT Manager
public class AnOTServerMessageQueuer implements ServerMessageFilter{
	Map<String, OTManager> clientToOTManager = new HashMap();
	MessageProcessor<SentMessage> sentMessageQueue;	
	@Override
	public synchronized void userJoined(String aSessionName, String anApplicationName, String aUserName) {
		OTManager otManager = new AnOTManager(true);
		clientToOTManager.put(aUserName, otManager);
		//otManager.setSentMessageQueue(sentMessageQueue);
		
	}

	@Override
	public void userLeft(String aSessionName, String anApplicationName, String aUserName) {
		// TODO Auto-generated method stub
		
	}
	/*
	 message sent by user u is a message received by all users, U, other than u.	 
	 so it must be treated as a received message by server representing U -u
	 transform this message with respect to all messages sent to u by  the server representing itself as U - u.
	 these messages are stored in u's ot Manager.
	 send transformed message to U - u.
	 store this message, with appropriate time stamp, as sent message in otManagers of U - u
	 each ot Manager will time stamp differently
	 this means message must be unicast
	 */
		
	@Override
	public synchronized void filterMessage(SentMessage message) {		
		if (!message.isUserMessage() || message.getSentMessageType() != SentMessageType.Others) {
			sentMessageQueue.processMessage(message);
			return;
		}
		Tracer.info(this, "START PUT in OTSERVER QUEUE");
		EditWithOTTimeStamp receivedEditWithOTTimeStamp = (EditWithOTTimeStamp) message.getUserMessage();
		OTManager sentOTManager = clientToOTManager.get(message.getSendingUser());
		Tracer.info(this, "OT Manager:" + message.getSendingUser());
		//transform  message with respect to all messages sent to u by  the server representing itself as U - u
		sentOTManager.processTimeStampedEdit(receivedEditWithOTTimeStamp);
		// this will be the edit sent to U - u
		Edit sentEdit = receivedEditWithOTTimeStamp.getTransformableEdit().getEdit();
		//iterate thru U - u and ot Managers of U - u.		
		Set<String> allUsers = clientToOTManager.keySet();
		Tracer.info("All Users n OTSERVER QUEUE:" + allUsers);
		for (String user:allUsers) {
			if (user.equals(message.getSendingUser()))
				continue;
			OTManager receivingOtManager = clientToOTManager.get(user);
			// transform the headers in the message which will include transformed edit
			SentMessage unicastMessage = ASentMessage.toSpecificUser(message, user);			
			// this is the server's sent edit to each U - u
			//Edit clonedEdit = (Edit) Misc.deepCopy(sentEdit);
			// sent edit does not have to be cloned in the sentMessage output buffer
			Tracer.info(this, "OT Manager:" + user);
			EditWithOTTimeStamp sentEditWithOTTimeStamp = receivingOtManager.processSentEdit(sentEdit);
			unicastMessage.setUserMessage(sentEditWithOTTimeStamp);
			Tracer.info(this, "Unicasting message to: " + user);
			sentMessageQueue.processMessage(unicastMessage);
			// store a different copy in the buffer
			SentMessage clonedUnicastMessage = (SentMessage) Common.deepCopy(unicastMessage);
			//Message.info("OT Manager:" + user);
			receivingOtManager.storeSentMessage(clonedUnicastMessage);
			//otManager.put(receivedMessage);
		}
		Tracer.info(this, "END PUT in OTSERVER QUEUE");		
	}

	@Override
	public void setMessageProcessor(MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageQueue = theMesssageProcessor;
		
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anotservermessagequeuercreator.java
package editor.ot;

import util.session.ServerMessageFilter;
import util.session.ServerMessageFilterCreator;

public class AnOTServerMessageQueuerCreator  implements ServerMessageFilterCreator{
	ServerMessageFilter  serverMessageQueuer = new AnOTServerMessageQueuer();
	@Override
	public ServerMessageFilter getMessageQueuer() {
		//return serverMessageQueuer;
		return new AnOTServerMessageQueuer();
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anottimestamp.java
package editor.ot;

import util.trace.Tracer;

public class AnOTTimeStamp implements OTTimeStamp {
	int localCount;
	int remoteCount;
	public AnOTTimeStamp(int theLocalCount, int theRemoteCount) {
		localCount = theLocalCount;
		remoteCount = theRemoteCount;
	}
	public AnOTTimeStamp() {
		
	}
	public  int getLocalCount() {
		return localCount;
	}
	
	public void setLocalCount(int newVal) {
		localCount = newVal;
	}	
	public  int getRemoteCount() {
		return remoteCount;
	}	
	public void setRemoteCount(int newVal) {
		remoteCount = newVal;
	}
	public boolean isConcurrent(OTTimeStamp other) {
		Tracer.info(this, " comparing: " + this + " with:" + other);
		return !isGreaterThanOrEqual(other) && !other.isGreaterThanOrEqual(this);

	}
	public boolean isGreaterThanOrEqual(OTTimeStamp other) {
		Tracer.info(this, " comparing: " + this + " with:" + other);
		return getLocalCount() >= other.getRemoteCount() &&
				getRemoteCount() >= other.getLocalCount();
	}
	public void incrementLocalCount() {
		localCount++;
	}
	
	public void incrementRemoteCount() {
		remoteCount++;
	}
	public String toString() {
//		return "local:" + localCount + " remote:" + remoteCount;
		return "[" + localCount + ", " + remoteCount + "]";

	}
	public OTTimeStamp copy() {
		return new AnOTTimeStamp(localCount, remoteCount);
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anoperationtranformercreator.java
package editor.ot;

public class AnOperationTranformerCreator implements OperationTransformerCreator{

	@Override
	public OperationTransformer getOperationTransformer() {		
		return new AnOperationTransformer();
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anoperationtransfomerselector.java
package editor.ot;

public class AnOperationTransfomerSelector {
	static OperationTransformerCreator factory = new AnOperationTranformerCreator();
	public static OperationTransformerCreator getOperationTransformerCreator() {
		return factory;
	}
	public static void setOperationTransformerCreator(OperationTransformerCreator newVal) {
		factory = newVal;
	}
	public static OperationTransformer getOperationTransformer() {
		return factory.getOperationTransformer();
	}

}
//END OF FILE
//START OF FILE: src/editor/ot/anoperationtransformer.java
package editor.ot;

import widgets.ACharInsertion;
import widgets.CharInsertion;
import widgets.Edit;

public class AnOperationTransformer implements OperationTransformer {
	public Edit transform (TransformableEdit transformed, TransformableEdit other) {
		//Message.info("original:" +  transformed + ", other: " + other);
		int transformedIndex = transformed.getEdit().getIndex();
		char ch;
		if (transformedIndex > other.getEdit().getIndex())
			transformedIndex++;
		else if (transformedIndex == other.getEdit().getIndex()) {
//			if (transformed.getEdit().getChar() == other.getEdit().getChar())
//				return null;
			if (!transformed.isServer())
				transformedIndex++;
		}
		CharInsertion retVal = new ACharInsertion(transformed.getEdit().getName(), 
				transformedIndex, transformed.getEdit().getChar());
		//Message.info("transformed:" +  retVal + ", other: " + other);
		return retVal;
	}
}
//END OF FILE
//START OF FILE: src/editor/ot/editwithottimestamp.java
package editor.ot;

import java.io.Serializable;

public interface EditWithOTTimeStamp extends Serializable{

	public abstract TransformableEdit getTransformableEdit();

	public abstract void setTransformableEdit(TransformableEdit newVal);
	public OTTimeStamp getOTTimeStamp() ;
	public void setOTTimeStamp(OTTimeStamp otTimeStamp) ;

	

}
//END OF FILE
//START OF FILE: src/editor/ot/otmanager.java
package editor.ot;

import util.session.SentMessage;
import widgets.Edit;
// Duplex connection between client and server
public interface OTManager {
	public void processTimeStampedEdit(EditWithOTTimeStamp receivedTSEdit);
	public EditWithOTTimeStamp processSentEdit(Edit edit );
	public void storeSentMessage(SentMessage message);
}
//END OF FILE
//START OF FILE: src/editor/ot/ottimestamp.java
package editor.ot;

import java.io.Serializable;

public interface OTTimeStamp extends Serializable {
   public abstract int getLocalCount();	
	public void setLocalCount(int newVal);	
	public abstract int getRemoteCount();	
	public void setRemoteCount(int newVal);	
	public boolean isConcurrent(OTTimeStamp other);
	public boolean isGreaterThanOrEqual(OTTimeStamp other);	
	public void incrementLocalCount();	
	public void incrementRemoteCount();
	public OTTimeStamp copy();
}
//END OF FILE
//START OF FILE: src/editor/ot/operationtransformer.java
package editor.ot;

import widgets.Edit;

public interface OperationTransformer {
	public Edit transform (TransformableEdit transformed, TransformableEdit other);

}
//END OF FILE
//START OF FILE: src/editor/ot/operationtransformercreator.java
package editor.ot;

public interface OperationTransformerCreator {
	public OperationTransformer getOperationTransformer();
}
//END OF FILE
//START OF FILE: src/editor/ot/transformableedit.java
package editor.ot;

import java.io.Serializable;

import widgets.Edit;
// More like an edit holder, except that it indicates if it is in server
public interface TransformableEdit extends Serializable {

	public abstract Edit getEdit();

	public abstract void setEdit(Edit newVal);

	public abstract boolean isServer();

	public abstract void setServer(boolean isServer);
	
	public TransformableEdit copy();

}
//END OF FILE
//START OF FILE: src/gframeapp/acharacterdrawer.java
package gframeApp;


import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.AGraphicsFrame;
import util.awt.DelegateFramePainter;

public class ACharacterDrawer extends ACursorTrackerOfDelegateFrame implements  DelegateFramePainter {
	final static int CARAT_LENGTH = 10; 
	public ACharacterDrawer(AGraphicsFrame theDelegateFrame) {
		super(theDelegateFrame);
	}
	public void init() {
		super.init();		
		frame.addPainter(this);
	}		
	public void paint (ADelegateFrame theDelegateFrame, Graphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + c, charX, charY);
	}
	public void mouseClicked(MouseEvent event) {
		super.mouseClicked(event);
		frame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		frame.repaint();		
	}	
}
//END OF FILE
//START OF FILE: src/gframeapp/acursortrackerofdelegateframe.java
package gframeApp;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import util.awt.AGraphicsFrame;

public class ACursorTrackerOfDelegateFrame implements MouseListener, KeyListener{
	protected AGraphicsFrame frame;
	protected int charX, charY;
	protected char c;		
	public ACursorTrackerOfDelegateFrame(AGraphicsFrame theFrame) {
		frame = theFrame;
		init();
	}
	public void init() {
		frame.addMouseListener(this);
		frame.addKeyListener(this);
	}	
	public void mousePressed(MouseEvent event) {
		charX = event.getX();
		charY = event.getY();
		//System.out.println("Mouse pressed");
	}
	public void keyTyped(KeyEvent event) {
		c = event.getKeyChar();		
	}	
	public void mouseEntered(MouseEvent event) {	}	
	public void mouseExited(MouseEvent event) {}	
	public void mouseClicked(MouseEvent event) {}	
	public void mouseReleased(MouseEvent event) {}	
	public void keyPressed(KeyEvent event) {}	
	public void keyReleased(KeyEvent event) {} 	
}
//END OF FILE
//START OF FILE: src/im/ahistoryincoupler.java
package im;

import trace.im.ListEditReceived;
import util.session.CommunicatorSelector;
import util.session.PeerMessageListener;
import echo.modular.History;

public class AHistoryInCoupler implements PeerMessageListener {
	protected History<String> history;
	public AHistoryInCoupler(History<String>  theEchoer) {
		history = theEchoer;
	}
	public void objectReceived(Object message, String userName) {
		// need for integration with RPC
		if (message instanceof ListEdit)
			processReceivedListEdit((ListEdit<String>) message, userName);
	}
	public static String remoteEcho(String anInput, String aUserName) {
		return anInput + "[" + aUserName + "]";
	}
	protected void processReceivedListEdit (ListEdit<String> aRemoteEdit, String aUserName) {
		ListEditReceived.newCase(
				CommunicatorSelector.getProcessName(),
				aRemoteEdit.getOperationName(), 
				aRemoteEdit.getIndex(), 
				aRemoteEdit.getElement(), aUserName, 
				this);
		String anInput = aRemoteEdit.getElement();
		// not observable add so we do not get echo message
		// add before we print the message in case some  something reacts to the print
		// before we add
		history.add(aRemoteEdit.getIndex(), anInput);
		System.out.println(remoteEcho(anInput, aUserName));
	
	}

}
//END OF FILE
//START OF FILE: src/im/alistedit.java
package im;

import trace.echo.modular.ListEditInfo;

public class AListEdit<ElementType> implements ListEdit<ElementType>{
	OperationName name;	
	int index;
	ElementType element;
	public AListEdit (OperationName theName, int theIndex, ElementType theElement) {
		index = theIndex;
		element = theElement;
		name = theName;
	}	
	public int getIndex() {
		return index;
	}
	
	public void setIndex(int index) {
		this.index = index;
	}
	
	public ElementType getElement() {
		return element;
	}
	
	public void setElement(ElementType anElement) {
		this.element = anElement;
	}
	public OperationName getOperationName() {
		return name;
	}
	public void setOperationName(OperationName anOperationName) {
		this.name = anOperationName;
	}
	public String toString() {
		return "[" + index + "; " + element + "]"; 
	}
	public ListEdit copy() {
		return new AListEdit(name, index, element);
	}
	
	public ListEditInfo toListEditInfo() {
		return new ListEditInfo(name, index, element );
	}
	
}
//END OF FILE
//START OF FILE: src/im/areplicatedhistory.java
package im;

import trace.im.ListEditSent;
import util.session.Communicator;
import util.trace.Tracer;
import util.trace.session.AddressedSentMessageInfo;
import echo.modular.AHistory;

public class AReplicatedHistory<ElementType> extends AHistory<ElementType> implements ReplicatedHistory<ElementType> {
	Communicator communicator;
	public AReplicatedHistory(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	
	public synchronized void replicatedAdd(ElementType anInput) {
		int anIndex = size();
		super.observableAdd(anIndex, anInput);
//		communicator.toOthers(new ARemoteInput(input));
//		communicator.toOthers(input);
		ListEdit listEdit = new AListEdit<ElementType>(OperationName.ADD, anIndex, anInput);
		ListEditSent.newCase(
				communicator.getClientName(),
				listEdit.getOperationName(), 
				listEdit.getIndex(), 
				listEdit.getElement(), 
			AddressedSentMessageInfo.OTHERS, this);
		communicator.toOthers(listEdit);

	}

	
}
//END OF FILE
//START OF FILE: src/im/aliceim.java
package im;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;

@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_1, ApplicationTags.IM})
public class AliceIM implements ExampleIMSession{
	public static final String USER_NAME = DistributedTags.CLIENT_1;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);
//		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new AnIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/animcomposerandlauncher.java
package im;

import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.PeerMessageListener;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
import echo.modular.AnEchoComposerAndLauncher;
import echo.modular.EchoerInteractor;
import echo.modular.History;
public class AnIMComposerAndLauncher extends AnEchoComposerAndLauncher implements IMComposerAndLauncher{
	public static final String DEFAULT_APPLICATION_NAME = "IM";

	protected Communicator communicator;	
	protected PeerMessageListener inCoupler;
	
//	public void composeAndLaunch(String[] args) {
//		communicator = createCommunicator(args, getApplicationName());
//		super.composeAndLaunch(args);
//	}
	
	
	public String getApplicationName() {
		return DEFAULT_APPLICATION_NAME;
	}
	protected History<String> createHistory() {
		return new AReplicatedHistory<String>(communicator);
	}
	// factory method
	protected EchoerInteractor createInteractor() {
		return new AnIMInteractor((ReplicatedHistory) history, communicator);
	}	
	protected void addCollaborationFunctions() {
		addInCoupler(communicator, history);
	}	
	public void compose(String[] args) {
		communicator = createCommunicator(args);
		super.compose(args);
		addCollaborationFunctions();
		communicator.join();
	}	

	public void checkArgs(String[] args) {
		if (args.length < 5) {
			System.out.println("Please supply server host name, session name,  user name and application name as main arguments");
			System.exit(-1);
		}
	}
	// parameters to factory
	public  Communicator createCommunicator(String args[]) {
		checkArgs(args);
		if (args.length == 5) {
			if (args[4].equalsIgnoreCase(Communicator.DIRECT))
				CommunicatorSelector.selectDirectCommunicator();
			else if (args[4].equalsIgnoreCase(Communicator.RELAYED))
				CommunicatorSelector.selectRelayerCommunicator();				
		}
		return CommunicatorSelector.getCommunicator(args[0],args[1],args[2], args[3]);
//		CommunicatorCreator communicatorFactory = ACommunicatorSelector.getCommunicatorFactory();
//		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
	}
	protected  void addInCoupler(Communicator communicator, History<String> echoerAndLogger) {
		inCoupler = new AHistoryInCoupler(echoerAndLogger);
		communicator.addPeerMessageListener(inCoupler);
	}
	public Communicator getCommunicator() {
		return communicator;
	}
	public PeerMessageListener getRemoteInputEchoer() {
		return inCoupler;
	}

	public static void main (String[] args) {
		Tracer.showInfo(true);
		SessionTracerSetter.setSessionPrintStatus();
		(new AnIMComposerAndLauncher()).composeAndLaunch(args);
	}
}
//END OF FILE
//START OF FILE: src/im/animdemoerandtester.java
package im;

import static im.IMUtililties.remoteEchoOf;
import static echo.monolithic.AMonolithicEchoDemoerAndTester.echoOf;
import static util.models.ConsoleModelUtility.containsText;
import static util.models.ConsoleModelUtility.getText;
import static util.models.ConsoleModelUtility.isConsole;
import static util.models.ConsoleModelUtility.isInfo;
import static util.models.ConsoleModelUtility.isOutput;
import static util.models.ConsoleModelUtility.isOutputLine;
import static util.trace.session.SessionTraceUtility.clientJoined;
import im.ot.AliceOTIM;
import im.ot.BobOTIM;
import im.ot.CathyOTIM;
import im.ot.OTSessionManagerServerStarter;




import java.beans.PropertyChangeEvent;
import java.util.List;
import java.util.Set;

import echo.modular.AHistory;
import echo.modular.AModularEchoDemoerAndTester;
import echo.modular.AnEchoInteractor;
import echo.modular.EchoerInteractor;
import echo.modular.History;
import trace.echo.modular.ModularEchoTraceChecker;
import trace.im.IMTraceChecker;
import util.misc.ThreadSupport;
import util.models.AConsoleModel;
import util.models.ConsoleModel;
import util.tags.DistributedTags;
import util.trace.Traceable;
import bus.uigen.models.ADemoerAndTester;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;
import bus.uigen.trace.TraceUtility;

public class AnIMDemoerAndTester extends AModularEchoDemoerAndTester {
	protected boolean causalPhaseStarted;
	protected String aliceInput, bobInput, cathyInput;
	protected boolean aliceJoined, bobJoined, cathyJoined;
	// protected boolean causalPoemEntered;
	protected boolean aliceInputOver, bobInputOver, cathyInputOver;
	protected boolean aliceFinalOutputOver, bobFinalOutputOver,
			cathyFinalOutputOver;
	protected boolean aliceReceivedCathyCausalInput,
			bobReceivedCathyCausalInput, cathyReceivedCathyCausalOutput;
	// not necessary but adding for debugging delays
	protected boolean aliceReceivedBobCausalInput, bobReceivedAliceCausalInput,
			cathyReceivedAliceCausalInput, cathyReceivedBobCausalInput;

	// protected boolean aliceCorrect, bobCorrect, cathyCorrect;
	protected ConsoleModel aliceConsole, bobConsole, cathyConsole,
			sessionManagerConsole;

	protected boolean joinPhaseTerminated;
	protected boolean causalPhaseTerminated;
	protected boolean causalPhasesTerminated;
	protected boolean viewOutputPhaseStarted;

	// protected boolean inputOver;
	protected String finalOutput;

	protected String aliceFinalOutput, bobFinalOutput, cathyFinalOutput;

	History history;

	int numCausalPhases = 2;
	protected boolean enterDummyStrings = true;
	protected boolean waitBeforeDummy = true;

	protected boolean aliceEqualsBobOutput;
	protected boolean aliceEqualsCathyOutput;
	protected boolean bobEqualsCathyOutput;
	
	public AnIMDemoerAndTester(boolean anInteractive) {
		super(anInteractive);
		history = new AHistory();
	}
	
	public AnIMDemoerAndTester() {
		this(true);
	}

	public void initCausalPhase() {
		System.out.println("Causal initialized");
		// causalPhaseStarted = false;
		// causalPoemEntered = false;
		causalPhaseTerminated = false;
		aliceInputOver = false;
		bobInputOver = false;
		cathyInputOver = false;
		aliceReceivedCathyCausalInput = false;
		bobReceivedCathyCausalInput = false;
		cathyReceivedCathyCausalOutput = false;
		aliceReceivedBobCausalInput = false;
		bobReceivedAliceCausalInput = false;
		cathyReceivedAliceCausalInput = false;
		cathyReceivedBobCausalInput = false;

	}

	

	void computeFinalHistory() {
		// History aHistory = new AHistory();
		// aHistory.add(0, poem[0]);
		// aHistory.add(1, poem[1]);
		// aHistory.add(2, poem[2]);
		// finalOutput = AnEchoerInteractor.toString(aHistory);

	}

	protected boolean causalPoemEntered() {
		return aliceReceivedCathyCausalInput && bobReceivedCathyCausalInput
				&& cathyReceivedCathyCausalOutput;
	}

	@Override
	public void executeAll() {
		consoleModels = launcher.getOrCreateConsoleModels();
		aliceConsole = consoleModels.get(1);
		bobConsole = consoleModels.get(2);
		cathyConsole = consoleModels.get(3);
		launcher.addConsolesPropertyChangeListener(this); // input added in
															// response to
															// events
		launcher.executeAll();
	}

	protected Class[] composeMainClasses() {
		return new Class[] { sessionManagerClass(), aliceClass(), bobClass(),
				cathyClass() };
	}

	protected Class sessionManagerClass() {
		return SessionManagerServerStarter.class;
		// return OTSessionManagerServerStarter.class;

	}

	protected Class aliceClass() {
		return AliceIM.class;
		// return AliceOTIM.class;
	}

	protected Class bobClass() {
		return BobIM.class;
		// return BobOTIM.class;
	}

	protected Class cathyClass() {
		return CathyIM.class;
		// return CathyOTIM.class;
	}

	protected boolean allJoined() {
		return aliceJoined && bobJoined && cathyJoined;
	}

	// protected boolean allCorrect() {
	// return aliceOutptCorrect && bobCorrect && cathyCorrect;
	// }

	protected void processAllJoined() {
		startCausalPhase();

	}

	protected void startCausalPhase() {
		System.out.println("causal phase started");
		causalPhaseStarted = true;
		enterAlicePart();

	}

	protected void enterAlicePart() {
		if (enterDummyStrings)
		enterAliceDummyString();
		aliceInput = poem[0];
		aliceConsole.setInput(aliceInput);
		history.add(aliceInput);
	}

	int nextDummy = 0;

	protected void enterAliceDummyString() {
		String aDummyString = DistributedTags.CLIENT_1 + nextDummy;
		history.add(aDummyString);
		aliceConsole.setInput(aDummyString);
		nextDummy++;
		if (waitBeforeDummy)
		ThreadSupport.sleep(100);
	}

	protected void enterBobDummyString() {
		String aDummyString = DistributedTags.CLIENT_2 + nextDummy;
		history.add(aDummyString);
		bobConsole.setInput(aDummyString);
		nextDummy++;
		if (waitBeforeDummy)

		ThreadSupport.sleep(100);

	}

	protected void enterCathyDummyString() {
		String aDummyString = DistributedTags.CLIENT_3 + nextDummy;
		history.add(aDummyString);
		cathyConsole.setInput(aDummyString);
		nextDummy++;
		if (waitBeforeDummy)

		ThreadSupport.sleep(100);

	}

	protected void enterBobPart() {
		if (enterDummyStrings)

		enterBobDummyString();
		bobInput = poem[1];
		bobConsole.setInput(bobInput);
		history.add(bobInput);
	}

	protected void enterCathyPart() {
		if (enterDummyStrings)

		enterCathyDummyString();
		cathyInput = poem[2];
		cathyConsole.setInput(cathyInput);
		history.add(cathyInput);

	}

	protected boolean maybeProcessJoinPhase(
			PropertyChangeEvent aConsoleModelEvent) {
		if (allJoined())
			return false; // go to next phase
		if (!isOutputLine(aConsoleModelEvent))
			return true;
		// we are only processing server events
		if (!isConsole(aConsoleModelEvent, DistributedTags.SERVER)
		// || !isOutputLine(aConsoleModelEvent)
				|| !isInfo(aConsoleModelEvent))
			return true; // irrelevant event, but join phase is not over
		Traceable traceable = TraceUtility
				.toTraceable(getText(aConsoleModelEvent));
		if (traceable != null) {
			if (clientJoined(traceable, DistributedTags.CLIENT_1))
				aliceJoined = true;
			else if (clientJoined(traceable, DistributedTags.CLIENT_2))
				bobJoined = true;
			else if (clientJoined(traceable, DistributedTags.CLIENT_3))
				cathyJoined = true;

			// move this to main loop
			if (allJoined()) {
				// the main loop has to be told about this

				joinPhaseTerminated = true;
				// this phase is over, trigger the next phase by
				// making alice start the poem
				// aliceConsole.setInput(poem[0]);
				return false;

				// processAllJoined();
			}
		}
		return true;
	}

	protected boolean inputOver() {
		return aliceInputOver && bobInputOver && cathyInputOver;
	}

	protected boolean outputOver() {
		return aliceFinalOutputOver && bobFinalOutputOver
				&& cathyFinalOutputOver;
	}

	public static Traceable toTraceable(PropertyChangeEvent aConsoleModelEvent) {
		return Traceable.toTraceable((String) aConsoleModelEvent.getNewValue());
	}

	// protected void lookForHistoryOutput(PropertyChangeEvent
	// aConsoleModelEvent) {
	// String anOutputLine = (String) aConsoleModelEvent.getNewValue();
	// if (isInfo(aConsoleModelEvent) ) return;
	// if (isConsole(aConsoleModelEvent, aliceClass())
	// && anOutputLine.equals(finalOutput)) {
	//
	// aliceOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } if (isConsole(aConsoleModelEvent, bobClass())
	// && anOutputLine.equals(finalOutput)) {
	//
	// bobOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } if (isConsole(aConsoleModelEvent, cathyClass())
	// && anOutputLine.equals(finalOutput)) {
	//
	// cathyOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// }
	//
	//
	//
	//
	// }

	// protected void interactiveEnterPoem(PropertyChangeEvent
	// aConsoleModelEvent) {
	// if (isConsole(aConsoleModelEvent, bobClass())
	// && !isInfo(aConsoleModelEvent) && // we will get output echoed
	// // as info, so let us ignore
	// // the info part
	// remoteEchoOf(aConsoleModelEvent, poem[0], DistributedTags.ALICE)) {
	// enterBobPart();
	// // when bob hears remote echo of
	// // alice's first line, he utters
	// // next line
	// // bobInput = poem[1];
	// // bobConsole.setInput(bobInput);
	// // history.add(bobInput);
	// } else if (isConsole(aConsoleModelEvent, cathyClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[1], DistributedTags.BOB)) {
	// // similarly cathy follows bob
	// // cathyInput = poem[2];
	// // cathyConsole.setInput(cathyInput);
	// // history.add(cathyInput);
	// enterCathyPart();
	// poemEntered = true;
	// finalOutput = AnEchoInteractor.toString(history);
	//
	// // inputOver = true; // for some reason this was deleted
	// }
	//
	// }
	protected boolean causalInteractiveEnterPoem(
			PropertyChangeEvent aConsoleModelEvent) {

		// we will get output echoed
		// as info, so let us ignore
		// the info part
		if (isInfo(aConsoleModelEvent))
			return true; // keep going
		if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_2, aliceInput,
				DistributedTags.CLIENT_1)) {
			// if (isConsole(aConsoleModelEvent, bobClass())
			// && !isInfo(aConsoleModelEvent) && // we will get output echoed
			// // as info, so let us ignore
			// // the info part
			// remoteEchoOf(aConsoleModelEvent, poem[0], DistributedTags.ALICE)) {
			enterBobPart();
			bobReceivedAliceCausalInput = true;
			System.out.println(numCausalPhases
					+ "Bob received alice causal input:" + aliceInput);

			// when bob hears remote echo of
			// alice's first line, he utters
			// next line

		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_3,
				bobInput, DistributedTags.CLIENT_2)) {

			// isConsole(aConsoleModelEvent, cathyClass())
			// && !isInfo(aConsoleModelEvent) && //
			// remoteEchoOf(aConsoleModelEvent, poem[1], DistributedTags.BOB)) {
			// // similarly cathy follows bob
			System.out.println(numCausalPhases
					+ "Cathy received bob causal input:" + bobInput);

			cathyReceivedBobCausalInput = true;

			enterCathyPart();
			// causalPoemEntered = true;
			// finalOutput = AnEchoInteractor.toString(history);

			// inputOver = true; // for some reason this was deleted
		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_1,
				cathyInput, DistributedTags.CLIENT_3)) {
			aliceReceivedCathyCausalInput = true;
			System.out.println(numCausalPhases
					+ "Alice received cathy causal input:" + cathyInput);

		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_2,
				cathyInput, DistributedTags.CLIENT_3)) {
			bobReceivedCathyCausalInput = true;
			System.out.println(numCausalPhases
					+ "Bob received cathy causal input:" + cathyInput);

		} else if (receivedLocalEcho(aConsoleModelEvent, DistributedTags.CLIENT_3,
				cathyInput)) {
			cathyReceivedCathyCausalOutput = true;
		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_2,
				aliceInput, DistributedTags.CLIENT_1)) {
			bobReceivedAliceCausalInput = true;
			System.out.println(numCausalPhases
					+ "Bob received alice causal input:" + aliceInput);
		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_1,
				bobInput, DistributedTags.CLIENT_2)) {
			aliceReceivedBobCausalInput = true;
			System.out.println(numCausalPhases
					+ "Alice received bob causal input:" + bobInput);
		}
		return causalPoemEntered();
		// return true;

	}

	public static boolean receivedRemoteEcho(
			PropertyChangeEvent aConsoleModelEvent, Class aReceiver,
			String anEntry, String aSender) {
		// System.out.println("Checking for remote Entry:" +
		// aConsoleModelEvent.getSource() + " " +
		// aConsoleModelEvent.getNewValue());
		return isConsole(aConsoleModelEvent, aReceiver) &&
		// !isInfo(aConsoleModelEvent) && //
				remoteEchoOf(aConsoleModelEvent, anEntry, aSender);
	}
	public static boolean receivedRemoteEcho(
			PropertyChangeEvent aConsoleModelEvent, String aReceiver,
			String anEntry, String aSender) {
		// System.out.println("Checking for remote Entry:" +
		// aConsoleModelEvent.getSource() + " " +
		// aConsoleModelEvent.getNewValue());
		return isConsole(aConsoleModelEvent, aReceiver) &&
		// !isInfo(aConsoleModelEvent) && //
				remoteEchoOf(aConsoleModelEvent, anEntry, aSender);
	}

	public static boolean receivedLocalEcho(
			PropertyChangeEvent aConsoleModelEvent, Class aReceiver,
			String anEntry) {
		return isConsole(aConsoleModelEvent, aReceiver) &&
		// !isInfo(aConsoleModelEvent) && //
				echoOf(aConsoleModelEvent, anEntry);
	}
	
	public static boolean receivedLocalEcho(
			PropertyChangeEvent aConsoleModelEvent, String aReceiver,
			String anEntry) {
		return isConsole(aConsoleModelEvent, aReceiver) &&
		// !isInfo(aConsoleModelEvent) && //
				echoOf(aConsoleModelEvent, anEntry);
	}

	/*
	 * output for one user may be over before input for another starts, so the
	 * history command input and output are mixed
	 */
	// protected void enterHistory(PropertyChangeEvent aConsoleModelEvent) {
	// if (isInfo(aConsoleModelEvent) ) return;
	// String anOutputWithNewLine = (String) aConsoleModelEvent.getNewValue() +
	// "\n";
	//
	// if (isConsole(aConsoleModelEvent, aliceClass()) &&
	// // !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// aliceConsole.setInput(EchoerInteractor.HISTORY);
	// aliceInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, bobClass()) &&
	// // && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// bobConsole.setInput(EchoerInteractor.HISTORY);
	// bobInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, cathyClass()) &&
	// // !isInfo(aConsoleModelEvent) && //
	// echoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// cathyConsole.setInput(EchoerInteractor.HISTORY);
	// cathyInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } if (aliceInputOver && isConsole(aConsoleModelEvent, aliceClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// aliceCorrectOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } if (bobInputOver && isConsole(aConsoleModelEvent, bobClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// bobCorrectOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } if (cathyInputOver && isConsole(aConsoleModelEvent, cathyClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// cathyCorrectOutputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// }
	//
	// }

	void enterAliceHistory() {
		aliceInputOver = true; // set it before property changed
		aliceConsole.setInput(EchoerInteractor.HISTORY);
	}

	void enterBobHistory() {
		bobInputOver = true;
		bobConsole.setInput(EchoerInteractor.HISTORY);
	}

	void enterCathyHistory() {
		cathyInputOver = true;
		cathyConsole.setInput(EchoerInteractor.HISTORY);
	}

	/*
	 * output for one user may be over before input for another starts, so the
	 * history command input and output are mixed
	 */
	// protected boolean enterHistoryAndViewOutput(
	// PropertyChangeEvent aConsoleModelEvent) {
	// if (isInfo(aConsoleModelEvent))
	// return true;
	// String anOutputWithNewLine = (String) aConsoleModelEvent.getNewValue()
	// + "\n";
	//
	// if (receivedRemoteEcho(aConsoleModelEvent, aliceClass(), cathyInput,
	// DistributedTags.CATHY)) {
	// aliceConsole.setInput(EchoerInteractor.HISTORY);
	// aliceInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (receivedRemoteEcho(aConsoleModelEvent, bobClass(),
	// cathyInput, DistributedTags.CATHY)) {
	// bobConsole.setInput(EchoerInteractor.HISTORY);
	// bobInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (receivedLocalEcho(aConsoleModelEvent, cathyClass(),
	// cathyInput)) {
	// cathyConsole.setInput(EchoerInteractor.HISTORY);
	// cathyInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// }
	// if (aliceInputOver && isConsole(aConsoleModelEvent, aliceClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// aliceFinalOutputOver = true;
	// aliceFinalOutput = anOutputWithNewLine;
	// // inputOver = true; // for some reason this was deleted
	// }
	// if (bobInputOver && isConsole(aConsoleModelEvent, bobClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// bobFinalOutputOver = true;
	// bobFinalOutput = anOutputWithNewLine;
	// // inputOver = true; // for some reason this was deleted
	// }
	// if (cathyInputOver && isConsole(aConsoleModelEvent, cathyClass())
	// && anOutputWithNewLine.equals(finalOutput)) {
	//
	// cathyFinalOutputOver = true;
	// cathyFinalOutput = anOutputWithNewLine;
	// // inputOver = true; // for some reason this was deleted
	// }
	// return true;
	//
	// }
	static final String aPromptWithNewLine = AnEchoInteractor.PROMPT + "\n";

	public static boolean isApplicationOutput(String aStringWithNewLine) {
		return !aStringWithNewLine.equals(aPromptWithNewLine)
				&& !aStringWithNewLine
						.startsWith(AConsoleModel.DEFAULT_INPUT_PROMPT)
				&& !aStringWithNewLine.equals("\n");
	}

	protected boolean viewHistoryOutput(PropertyChangeEvent aConsoleModelEvent) {
		if (isInfo(aConsoleModelEvent))
			return true;
		String anOutputWithNewLine = (String) aConsoleModelEvent.getNewValue()
				+ "\n";

		if (aliceInputOver && isConsole(aConsoleModelEvent, DistributedTags.CLIENT_1)
		// && anOutputWithNewLine.equals(finalOutput))
				&& isApplicationOutput(anOutputWithNewLine)

		) {

			aliceFinalOutputOver = true;
			aliceFinalOutput = anOutputWithNewLine;

			// inputOver = true; // for some reason this was deleted
		} else if (bobInputOver && isConsole(aConsoleModelEvent, DistributedTags.CLIENT_2)
		// && anOutputWithNewLine.equals(finalOutput))
				&& isApplicationOutput(anOutputWithNewLine))

		{

			bobFinalOutputOver = true;
			bobFinalOutput = anOutputWithNewLine;
			// inputOver = true; // for some reason this was deleted
		} else if (cathyInputOver
				&& isConsole(aConsoleModelEvent, DistributedTags.CLIENT_3)
				// && anOutputWithNewLine.equals(finalOutput))
				&& isApplicationOutput(anOutputWithNewLine))

		{

			cathyFinalOutputOver = true;
			cathyFinalOutput = anOutputWithNewLine;
			// inputOver = true; // for some reason this was deleted
		}
		// return true;
		return !outputOver(); // return false is output is over so next phase can go

	}

	// protected boolean maybeProcessInputPhase(
	// PropertyChangeEvent aConsoleModelEvent) {
	// if (outputOver())
	// return false;
	// if (!isOutputLine(aConsoleModelEvent)) // continue phase, but it is not
	// // over
	// return true;
	//
	//
	// if (isConsole(aConsoleModelEvent, DistributedTags.BOB)
	// && !isInfo(aConsoleModelEvent) && // we will get output echoed
	// // as info, so let us ignore
	// // it
	// remoteEchoOf(aConsoleModelEvent, poem[0], DistributedTags.ALICE)) {
	// bobConsole.setInput(poem[1]); // when bob hears remote echo of
	// // alice's first line, he utters
	// // next line
	// } else if (isConsole(aConsoleModelEvent, cathyClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[1], DistributedTags.BOB)) {
	// cathyConsole.setInput(poem[2]); // similarly cathy follows bob
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, aliceClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// aliceInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, aliceClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// aliceConsole.setInput(EchoerInteractor.HISTORY);
	// aliceInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, bobClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// bobConsole.setInput(EchoerInteractor.HISTORY);
	// bobInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (isConsole(aConsoleModelEvent, cathyClass())
	// && !isInfo(aConsoleModelEvent) && //
	// echoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// cathyConsole.setInput(EchoerInteractor.HISTORY);
	// cathyInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// } else if (aliceInputOver &&
	// isConsole(aConsoleModelEvent, aliceClass())
	// && !isInfo(aConsoleModelEvent) && //
	// remoteEchoOf(aConsoleModelEvent, poem[2], DistributedTags.CATHY)) {
	// aliceConsole.setInput(EchoerInteractor.HISTORY);
	// aliceInputOver = true;
	// // inputOver = true; // for some reason this was deleted
	// }
	//
	// return true;
	//
	// }
	public   boolean intraSequenceTest(List<Traceable> aTraceableList) {
		boolean superTest = super.intraSequenceTest(aTraceableList);
		boolean imTest = IMTraceChecker.intraSequenceCheckIM(aTraceableList);
		return superTest && imTest;
				
	}

	protected Boolean intraSequenceTest() {
		Set<String> titles = titleToLocalTraceableList.keySet();
		boolean retVal = true;
		for (String title : titles) {
			if (title.contains(DistributedTags.SERVER))
				continue;
			System.out.println("intra sequence tes for:"
					+ title);
			List<Traceable> aTestTraceableList = titleToLocalTraceableList
					.get(title);
			
			retVal = retVal & intraSequenceTest(aTestTraceableList);
//			modularityTranscriptTestSucceeded = super.testAgainstCorrectTranscripts(testTranscript, correctTranscript);
////			if (!modularityTranscriptTestSucceeded)
////				System.out.println("Modularity test failed");
//			
//			if (!IMTraceChecker.compareIMSequences(testTranscript,
//					correctTranscript)) {
//				retVal = false;
//				System.out.println("IM Sequence Test failed");
//
//			}
		}

		return retVal;

	}
	@Override
	protected   Boolean testAgainstCorrectTranscripts(List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		return super.testAgainstCorrectTranscripts(aTestTraceableList, aCorrectTraceableList)
		& IMTraceChecker.compareIMSequences(aTestTraceableList,
				aCorrectTraceableList);
				
	}
	

	@Override
	public Boolean testAgainstCorrectTranscripts() {
		Set<String> titles = titleToLocalTraceableList.keySet();
		boolean retVal = true;
		for (String title : titles) {
			if (title.contains(DistributedTags.SERVER))
				continue;
			System.out.println("Comparing test and local transcripts for:"
					+ title);
			List<Traceable> aTestTraceableList = titleToLocalTraceableList
					.get(title);
			List<Traceable> aCorrectTraceableList = titleToCorrectTraceableList
					.get(title);
			testAgainstCorrectTranscripts(aTestTraceableList, aCorrectTraceableList);
//			modularityTranscriptTestSucceeded = super.testAgainstCorrectTranscripts(testTranscript, correctTranscript);
////			if (!modularityTranscriptTestSucceeded)
////				System.out.println("Modularity test failed");
//			
//			if (!IMTraceChecker.compareIMSequences(testTranscript,
//					correctTranscript)) {
//				retVal = false;
//				System.out.println("IM Sequence Test failed");
//
//			}
		}

		return retVal;

	}

	protected void processCausalPhasesFinished(
			PropertyChangeEvent aConsoleModelEvent) {
		// finalOutput = AnEchoInteractor.toString(history);
		// enterAliceHistory();
		// enterBobHistory();
		// enterCathyHistory();
		causalPhasesTerminated = true;
		enterHistoryCommands(aConsoleModelEvent);

//		processAllPhasesFinished(aConsoleModelEvent);
	}
	// not called currently
	protected void processAllPhasesFinished(
			PropertyChangeEvent aConsoleModelEvent) {
		System.out.println("All phases finished");
//		System.out.println("causal poem entered" + causalPoemEntered());
		finalOutput = AnEchoInteractor.toString(history);
		enterAliceHistory();
		enterBobHistory();
		enterCathyHistory();
	}
	
	protected void enterHistoryCommands(PropertyChangeEvent aConsoleModelEvent) {
		finalOutput = AnEchoInteractor.toString(history);
		enterAliceHistory();
		enterBobHistory();
		enterCathyHistory();
	}

	protected void restartCausalPhase(PropertyChangeEvent aConsoleModelEvent) {
		initCausalPhase();
		startCausalPhase();
		// enterAlicePart();
	}

	protected void startPhaseAfterCausalPhase(
			PropertyChangeEvent aConsoleModelEvent) {
		restartCausalPhase(aConsoleModelEvent);

	}

	protected void processCausalPhaseFinished(
			PropertyChangeEvent aConsoleModelEvent) {
		// causalInteractiveEnterPoem(aConsoleModelEvent);
		if (causalPoemEntered()) {
			numCausalPhases--;
			if (numCausalPhases > 0) {
				// causalPoemEntered = false;
				// initCausalPhase();
				// enterAlicePart();
				// restartCausalPhase(aConsoleModelEvent);
				startPhaseAfterCausalPhase(aConsoleModelEvent);
			} else {
				causalPhasesTerminated = true;
				processCausalPhasesFinished(aConsoleModelEvent);

			}

		}

	}

	protected boolean maybeProcessCausalIOPhase(
			PropertyChangeEvent aConsoleModelEvent) {
		// do we need this?
		// if (!causalPhaseStarted) // continue phase, but it is not over
		//
		// return true;
		// if (outputOver()) {
		// return false;
		// }
		if (!isOutputLine(aConsoleModelEvent)) // continue phase, but it is not
												// over
			return true;

		if (causalPoemEntered()) {
//			viewHistoryOutput(aConsoleModelEvent);
			return false;
		} else {
			causalInteractiveEnterPoem(aConsoleModelEvent);
			// causalInteractiveEnterPoem(aConsoleModelEvent);
			if (causalPoemEntered()) {
				causalPhaseTerminated = true;
				// processCausalPhaseFinished(aConsoleModelEvent);
				return false;

			}

			// numCausalPhases--;
			// if (numCausalPhases > 0) {
			// // causalPoemEntered = false;
			// initCausalPhase();
			// enterAlicePart();
			// } else {
			// finalOutput = AnEchoInteractor.toString(history);
			// enterAliceHistory();
			// enterBobHistory();
			// enterCathyHistory();
			//
			// }
			// }
		}
		return true;

	}

	// should make sure property changes are serialized
	@Override
	public void propertyChange(PropertyChangeEvent aConsoleModelEvent) {
		// process each of the phases after the preceding ones have finished
		
		// these maybes should return three values: continue, next step, or
		// return;
		if (maybeProcessJoinPhase(aConsoleModelEvent))
			return;
		else if (joinPhaseTerminated) {
			joinPhaseTerminated = false;
			processAllJoined(); // trigger more events, and these events and state changes made by them will not be consumed by previous phase
			return;
			// this will consume join phase event but it will be ignored
			// as it is of different type
			// should have transition here also

		} else if (maybeProcessCausalIOPhase(aConsoleModelEvent))
			return;
		else if (causalPhaseTerminated) {
			causalPhaseTerminated = false;
			// we do not really need the event do we?
			processCausalPhaseFinished(aConsoleModelEvent);
			return;
//		} 
//		else if (causalPhasesTerminated) {
//			causalPhasesTerminated = false; // do not consume event
////			processCausalPhaseFinished(aConsoleModelEvent);
//
//			return;
//		} 
//		else if (!viewOutputPhaseStarted) {
//			enterHistoryCommands(aConsoleModelEvent);
		} else if (viewHistoryOutput(aConsoleModelEvent))
			return;
		// if (maybeProcessTestPhase(aConsoleModelEvent)) return; // for some
		// reason
		// launcher.terminateAll();
		else if (!isTerminated())
			notifyInteractionTermination();

	}

	@Override
	public Boolean test() {
//		boolean superTestSucceeded = super.test();
		aliceEqualsBobOutput = aliceFinalOutput.equals(bobFinalOutput);
		aliceEqualsCathyOutput = aliceFinalOutput.equals(cathyFinalOutput);
		bobEqualsCathyOutput = bobFinalOutput.equals(cathyFinalOutput);
		boolean historiesEqual = aliceFinalOutput != null
				&& aliceEqualsBobOutput &&aliceEqualsCathyOutput
				&& bobEqualsCathyOutput;
		boolean intraSequenceTest = intraSequenceTest();
		System.out.println("AnIMDemoerAndATest result:" + historiesEqual);
		return historiesEqual;

	}

}
//END OF FILE
//START OF FILE: src/im/animinteractor.java
package im;

import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.InteractiveTags;
import echo.modular.AnEchoInteractor;
import echo.modular.History;
@Tags({ApplicationTags.IM, InteractiveTags.INTERACTOR})

public class AnIMInteractor extends AnEchoInteractor  {
	protected Communicator communicator;
	public AnIMInteractor(History<String> aHistory, Communicator aCommunicator) {
		super(aHistory);
		communicator = aCommunicator;
	}
	
	protected void addToHistory(String newValue) {
//		((ReplicatedHistory) history).replicatedAdd(history.size(), newValue);
		((ReplicatedHistory) history).replicatedAdd(newValue);

	}
	protected void processQuit() {
		super.processQuit();
		communicator.leave();
	}
}
//END OF FILE
//START OF FILE: src/im/bobim.java
package im;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.SessionTracerSetter;


@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_2, ApplicationTags.IM})

public class BobIM implements ExampleIMSession{
	public static final String USER_NAME = DistributedTags.CLIENT_2;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.RELAYED};
//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);

//		SessionTracerSetter.setSessionPrintStatus();

		(new AnIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/cathyim.java
package im;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_3, ApplicationTags.IM})
public class CathyIM implements ExampleIMSession{
	public static final String USER_NAME = DistributedTags.CLIENT_3;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.RELAYED};

//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
//		SessionTracerSetter.setSessionPrintStatus();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);


		(new AnIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/demoerofim.java
package im;

import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfIM {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceIM.class,
				BobIM.class,
				CathyIM.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/exampleimsession.java
package im;

public interface ExampleIMSession {
	public static final String SESSION_NAME = "FrostySession";
	public static final String APPLICATION_NAME = "IM";
	public static final String SESSION_SERVER_HOST = "localhost";

}
//END OF FILE
//START OF FILE: src/im/imcomposerandlauncher.java
package im;

import replicatedWindow.CommunicatorBasedComposerAndLauncher;
import util.session.Communicator;
import util.session.PeerMessageListener;
import echo.modular.EchoerComposerAndLauncher;

public interface IMComposerAndLauncher extends EchoerComposerAndLauncher,  CommunicatorBasedComposerAndLauncher {
//	public static final String DIRECT = "P2P";
//	public static final String RELAYED = "Relayed";
//	public String getApplicationName();
	public PeerMessageListener getRemoteInputEchoer();
//	public Communicator getCommunicator();

}
//END OF FILE
//START OF FILE: src/im/imtags.java
package im;

public interface IMTags {
	String IM = "IM";

}
//END OF FILE
//START OF FILE: src/im/imutililties.java
package im;

import static util.models.ConsoleModelUtility.isOutputLine;

import java.beans.PropertyChangeEvent;

public class IMUtililties {
	public static boolean remoteEchoOf(PropertyChangeEvent aConsoleModelEvent, String anInput, String aUserName ) {
		if (!isOutputLine(aConsoleModelEvent)) return false;
		String aText = aConsoleModelEvent.getNewValue().toString();
		return aText.contains(AHistoryInCoupler.remoteEcho(anInput, aUserName));
		
	}
	
	
	
	

}
//END OF FILE
//START OF FILE: src/im/launcherofimcorrectloggenerator.java
package im;

import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;

public class LauncherOfIMCorrectLogGenerator extends LauncherOfIMDemoer {
	public static void main(String args[]) {
		// needed for Echo Tracer
		ConsoleTraceSetter.traceConsole();	
		DemoerAndTester aDemoer = createDemoer(true);
		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
//		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/im/launcherofimdemoer.java
package im;

import echo.modular.LauncherOfModularEchoTester;
import trace.echo.modular.ModularEchoTraceChecker;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfIMDemoer extends LauncherOfModularEchoTester{
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AnIMDemoerAndTester(anInteractive);
	}
	public static DemoerAndTester createDemoer() {
		return new AnIMDemoerAndTester();
	}
	public static void main(String args[]) {
		DemoerAndTester demoer = createDemoer(true);
		MainClassListLauncher aLauncher = demoer.createAndDisplayLauncher();
//		demoer.generateCorrectTranscripts();
		demoer.executeAll();
//		demoer.loadTraceables(null);
//		aLauncher.executeAll();
		
		
//		MainClassListLauncher aLauncher = demo();
//		animatingTest(aLauncher);
	}

}
//END OF FILE
//START OF FILE: src/im/launcherofimtester.java
package im;

import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;

public class LauncherOfIMTester extends LauncherOfIMDemoer {
	public static void main(String args[]) {
		// needed for Echo Tracing
		ConsoleTraceSetter.traceConsole();	
		DemoerAndTester aDemoer = createDemoer(true);
//		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/im/listedit.java
package im;

import java.io.Serializable;

import trace.echo.modular.ListEditInfo;

public interface ListEdit<ElementType> extends Serializable {	
	int getIndex();
	void setIndex(int anIndex);
	ElementType getElement();
	void setElement(ElementType anElement);
	OperationName getOperationName();
	void setOperationName(OperationName name);
	ListEdit copy();
	public ListEditInfo toListEditInfo();

}
//END OF FILE
//START OF FILE: src/im/operationname.java
package im;

import util.misc.Common;

public enum OperationName {
	ADD,
	DELETE,
	REPLACE;
	
	public static OperationName fromString(String aString) {
		return (OperationName) Common.fromString(OperationName.class, aString);
		
	}
	

}
//END OF FILE
//START OF FILE: src/im/replicatedhistory.java
package im;

import echo.modular.History;

public interface ReplicatedHistory<ElementType> extends History<ElementType> {
	void replicatedAdd(ElementType newVal);
	

}
//END OF FILE
//START OF FILE: src/im/sessionmanagerserverstarter.java
package im;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.ASessionManager;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.ImplicitKeywordKind;
import util.trace.MessagePrefixKind;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.SERVER, DistributedTags.SESSION_MANAGER, ApplicationTags.IM})
public class SessionManagerServerStarter {
	static ASessionManager server;
	public static void main (String[] args) {
		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
//		Tracer.setKeywordPrintStatus(ServerClientJoined.class, true);
		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
		Tracer.setKeywordPrintStatus(ServerClientJoined.class, true);

//		SessionTracerSetter.setSessionPrintStatus();
		
		server = new ASessionManager();
		server.register();
	}
}
//END OF FILE
//START OF FILE: src/im/access/acontrolledreplicatedhistory.java
package im.access;

import im.AReplicatedHistory;

import java.util.ArrayList;
import java.util.List;

import util.session.Communicator;

public class AControlledReplicatedHistory<ElementType> 
		extends AReplicatedHistory<ElementType> 
		implements ControlledReplicatedHistory<ElementType>  {	
	List<Vetoer<ElementType>> vetoers = new ArrayList();
	public AControlledReplicatedHistory(Communicator theCommunicator) {
		super(theCommunicator);		
	}
	public synchronized void replicatedAdd(ElementType anInput) {
		if (vetoed(anInput))
				return;
		super.replicatedAdd(anInput);
		
	}		
	public void addVetoer(Vetoer theVetoer) {
		vetoers.add(theVetoer);		
	}
	public void removeVetoer(Vetoer theVetoer) {
		vetoers.remove(theVetoer);		
	}
	boolean vetoed(ElementType theValue) {
		for (Vetoer vetoer:vetoers) {
			if (vetoer.veto(theValue)) return true;
		}
		return false;
	}
}
//END OF FILE
//START OF FILE: src/im/access/amessage.java
package im.access;

import java.io.Serializable;

public class AMessage<DataType> implements Serializable, Message<DataType> {
	DataType messageData;
	public AMessage(DataType theData) {
		messageData = theData;
	}
	public DataType getData() {
		return messageData;
	}
}
//END OF FILE
//START OF FILE: src/im/access/accesscontroller.java
package im.access;

public interface AccessController extends Vetoer {
	boolean canInput(String theUser);
	boolean canAdminister(String theUser);
	void addAdministrator(String newAdminsitrator);
	void addInputter(String newInputter);
	void addAdministratorLocal(String newAdminsitrator);
	void addInputterLocal(String newInputter);
	void setOwner(String theOwner);
}
//END OF FILE
//START OF FILE: src/im/access/aliceaccesscontrolledim.java
package im.access;

import im.AliceIM;
import im.AnIMComposerAndLauncher;
import trace.im.aware.AwareIMTracerSetter;
import util.session.Communicator;
import util.trace.TraceableInfo;

public class AliceAccessControlledIM extends AliceIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
		AwareIMTracerSetter.traceAwareIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME, Communicator.DIRECT};
		(new AnAccessControlledIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}	
}
//END OF FILE
//START OF FILE: src/im/access/anaccesscontrolledimcomposerandlauncher.java
package im.access;

import echo.modular.History;
import im.AReplicatedHistory;
import im.ReplicatedHistory;
import im.aware.ASessionAwarenessProvider;
import im.aware.AnAwareIMComposerAndLauncher;
import util.session.Communicator;
import util.session.ReceivedMessageListener;
import util.session.SessionMessageListener;
import bus.uigen.ObjectEditor;

public class AnAccessControlledIMComposerAndLauncher extends AnAwareIMComposerAndLauncher {	
	static String APPLICATION_NAME = "Access Controlled IM";	
	protected void addCollaborationFunctions() {
		super.addCollaborationFunctions();
		addAccessControl();	
	}
	protected History<String> createHistory() {
		return new AControlledReplicatedHistory<String>(communicator);
	}	
	public  void addAccessControl() {	
		AccessController accessController = new AnAccessController(communicator);		
		ReceivedMessageListener accessReceiver = new AnAccessReceiver(communicator, accessController);
		communicator.addReceivedMessageListener(accessReceiver);
		controlledReplicatedHistory().addVetoer(accessController);
		ObjectEditor.edit(accessController);

	}	
	protected ControlledReplicatedHistory<String> controlledReplicatedHistory() {
		return (ControlledReplicatedHistory<String>) history;
	}
	
	
}
//END OF FILE
//START OF FILE: src/im/access/anaccesscontroller.java
package im.access;

import java.util.ArrayList;
import java.util.List;

import javax.swing.JOptionPane;

import util.annotations.Visible;
import util.session.Communicator;

public class AnAccessController implements AccessController {
	Communicator communicator;
	List<String> inputers = new ArrayList();
	List<String> administrators = new ArrayList();
	String owner;
	public AnAccessController(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	@Visible(false)
	public boolean hasOwnership(String theUser) {
		return theUser.equals(owner);
	}
	@Visible(false)
	public void setOwner(String theOwner) {
		JOptionPane.showMessageDialog(null, theOwner + " is the owner");
		owner = theOwner;
	}
	@Visible(false)
	public boolean canInput(String theUser) {
		return  inputers.contains(theUser);
	}
	@Visible(false)
	public void addInputterLocal(String newInputer) {
		inputers.add(newInputer);
		JOptionPane.showMessageDialog(null, newInputer + " can input");
	}
	public void addInputter(String aNewInputer) {
		String aUserName = communicator.getClientName();
		if (!canAdminister(aUserName)) {
				JOptionPane.showMessageDialog(null, aUserName +
						" does not have authorization to administer");
			return;
		}
		communicator.toAll(new AnInputAuthorization(aNewInputer));
	}
	@Visible(false)
	public boolean canAdminister(String theUser) {
		return administrators.contains(theUser);
	}
	@Visible(false)
	public void addAdministratorLocal(String newAdminsitrator) {
		administrators.add(newAdminsitrator);
		JOptionPane.showMessageDialog(null, newAdminsitrator + " can administer");
	}
	public void addAdministrator(String newAdminsitrator) {
		if (!hasOwnership(communicator.getClientName())) {
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" is not owner");
	        return;
	    }
		communicator.toAll(new AnAdministratorAuthorization(newAdminsitrator));
	}
	@Visible(false)
	public boolean veto(Object theInput) {
		boolean retVal = !canInput (communicator.getClientName());
		if (retVal) {
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" does not have authorization to input");
		}
		return retVal;
	}
}
//END OF FILE
//START OF FILE: src/im/access/anaccessreceiver.java
package im.access;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnAccessReceiver implements ReceivedMessageListener {
	Communicator communicator;
	AccessController accessController;
	public AnAccessReceiver(Communicator theCommunicator,
			AccessController theAccessController) {
		communicator = theCommunicator;
		accessController = theAccessController;
	}
	public void clientJoined(
			String userName, String theApplicationName, 
			String theSessionName, boolean newSession, 
			boolean newApplication, Collection<String> allUsers) {
		if (newApplication) {
			accessController.setOwner(userName);
			accessController.addAdministratorLocal(userName);
			accessController.addInputterLocal(userName);
		}
	}
	public void objectReceived(Object message, String sourceName) {
		if (message instanceof AnInputAuthorization)
			processInputAuthorization((Message<String>) message);
		else if (message instanceof AnAdministratorAuthorization)
			processAdminAuthorization((Message<String>) message);
	}
	void processInputAuthorization(Message<String> message) {
		accessController.addInputterLocal(message.getData());
	}
	void processAdminAuthorization(Message<String> message) {
		accessController.addAdministratorLocal(message.getData());
	}
	public void clientLeft(String userName, String theApplicationName) {}
}
//END OF FILE
//START OF FILE: src/im/access/anadministratorauthorization.java
package im.access;

public class AnAdministratorAuthorization extends AMessage<String> {
	public AnAdministratorAuthorization(String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/im/access/aninputauthorization.java
package im.access;

public class AnInputAuthorization extends AMessage<String> {
	public AnInputAuthorization(String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/im/access/bobaccesscontrolledim.java
package im.access;

import im.AliceIM;
import im.AnIMComposerAndLauncher;
import im.BobIM;
import trace.im.aware.AwareIMTracerSetter;
import util.session.Communicator;
import util.trace.TraceableInfo;

public class BobAccessControlledIM extends BobIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
		AwareIMTracerSetter.traceAwareIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME, Communicator.DIRECT};
		(new AnAccessControlledIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}	
}
//END OF FILE
//START OF FILE: src/im/access/cathyaccesscontrolledim.java
package im.access;

import im.AliceIM;
import im.AnIMComposerAndLauncher;
import im.BobIM;
import trace.im.aware.AwareIMTracerSetter;
import util.session.Communicator;
import util.trace.TraceableInfo;

public class CathyAccessControlledIM extends BobIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
		AwareIMTracerSetter.traceAwareIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME, Communicator.DIRECT};
		(new AnAccessControlledIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}	
}
//END OF FILE
//START OF FILE: src/im/access/controlledreplicatedhistory.java
package im.access;

import im.ReplicatedHistory;

public interface ControlledReplicatedHistory<ElementType> extends ReplicatedHistory<ElementType> {
	public void addVetoer(Vetoer theVetoer);
	public void removeVetoer(Vetoer theVetoer);
}
//END OF FILE
//START OF FILE: src/im/access/demoerofaccesscontrolledim.java
package im.access;

import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfAccessControlledIM {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceAccessControlledIM.class,
				BobAccessControlledIM.class,
				CathyAccessControlledIM.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/access/message.java
package im.access;

public interface Message<DataType> {
	public DataType getData();
}
//END OF FILE
//START OF FILE: src/im/access/vetoer.java
package im.access;

public interface Vetoer<ValueType> {
	boolean veto(ValueType theInput);
}
//END OF FILE
//START OF FILE: src/im/aware/adynamicsessionjoiner.java
package im.aware;

import im.AnIMComposerAndLauncher;

import java.util.Collection;

import javax.swing.JOptionPane;

import bus.uigen.misc.OEMisc;
import util.session.Communicator;
import util.session.CommunicatorSelector;
import util.session.SessionMessageListener;
import util.trace.session.ClientJoinNotificationReceived;
import util.trace.session.ClientLeaveNotificationReceived;

public class ADynamicSessionJoiner implements SessionMessageListener {
	String sessionManagerHost;
	String userName;
	public ADynamicSessionJoiner(String aSessionManagerHost, String aUserName) {
		sessionManagerHost = aSessionManagerHost;
		userName = aUserName;
	}
	public void clientJoined(
			String aUserName, String anApplicationName, String aSessionName,
			boolean aNewSession, boolean aNewApplication, Collection<String> anAllUsers) {
		ClientJoinNotificationReceived.newCase(CommunicatorSelector.getProcessName(), aUserName, (String) anApplicationName, aSessionName, this);
//		String aMessage = computeAwarenessMessage(aUserName, anApplicationName, aSessionName, aNewSession, aNewApplication, anAllUsers);
//		JOptionPane.showMessageDialog(null, aMessage);
		if (aNewApplication && anApplicationName != null && AnIMComposerAndLauncher.DEFAULT_APPLICATION_NAME.equals(anApplicationName))
			joinSession(anApplicationName, aSessionName);
		
	}
	public void joinSession(String anApplicationName, String aSessionName) {
		String[] launcherArgs = {sessionManagerHost, aSessionName, userName, anApplicationName, Communicator.DIRECT};
		OEMisc.runWithObjectEditorConsole(AnIMComposerAndLauncher.class, launcherArgs);
//		Communicator aCommunicator = CommunicatorSelector.
//				getCommunicator(sessionManagerHost, aSessionName, anApplicationName, Communicator.RELAYED);
		
		
	}
	public String computeAwarenessMessage(String aUserName, Object anApplicationName, String aSessionName,
			boolean aNewSession, boolean aNewApplication, Collection<String> anAllUsers) {
		String newOrOldSession = aNewSession?" new ":"";
		String newOrOldApplication = aNewApplication?" new ":"";
		String message = "User: " + aUserName +
				" joined " + newOrOldApplication + " application: " + anApplicationName +
				" in " + newOrOldSession + " session: " + aSessionName +
				getOtherUserNames(anAllUsers, aUserName);
		return message;
	}
	String getOtherUserNames(Collection<String> allUsers, String myName) {
		if (allUsers.size() == 1)
			return "";
		String retVal = " with other users:";
		for (String userName:allUsers) {
			if (userName.equals(myName)) continue;
			retVal += " " + userName;
		}
		return retVal;
	}
	public void clientLeft(String aUserName, String anApplicationName) {
		ClientLeaveNotificationReceived.newCase(CommunicatorSelector.getProcessName(), aUserName, (String) anApplicationName,  this);
		String message = "User left session:" + aUserName;
		JOptionPane.showMessageDialog(null, message);
	}
}
//END OF FILE
//START OF FILE: src/im/aware/ajoiningawareimcomposerandlauncher.java
package im.aware;

import im.AnIMComposerAndLauncher;
import util.session.SessionMessageListener;

public class AJoiningAwareIMComposerAndLauncher extends AnIMComposerAndLauncher implements AwareIMComposerAndLauncher{
	protected SessionMessageListener sessionAwarenesManager;
	public static void main (String[] args) {

		(new AJoiningAwareIMComposerAndLauncher()).composeAndLaunch(args);
	}
	
	protected void addCollaborationFunctions() {
		super.addCollaborationFunctions();
		addAwareness();
	}
	
	public  void addAwareness() {
		sessionAwarenesManager = new ASessionAwarenessProvider();
		communicator.addSessionMessageListener(sessionAwarenesManager);
	}

	public SessionMessageListener getSessionAwarenesManager() {
		return sessionAwarenesManager;
	}
	
}
//END OF FILE
//START OF FILE: src/im/aware/ajoiningimcomposerandlauncher.java
package im.aware;

import im.AnIMComposerAndLauncher;
import util.session.Communicator;
import util.session.CommunicatorSelector;
import util.session.SessionMessageListener;

public class AJoiningIMComposerAndLauncher  {
	protected SessionMessageListener sessionJoiner;
	protected Communicator communicator;	
	String sessionServerHost;
	String userName;


	
	
	protected void addCollaborationFunctions() {
//		super.addCollaborationFunctions();
		addAwareness();
	}
	
	public  void addAwareness() {
		sessionJoiner = new ADynamicSessionJoiner(sessionServerHost, userName);
		communicator.addSessionMessageListener(sessionJoiner);
	}

	public SessionMessageListener getSessionAwarenesManager() {
		return sessionJoiner;
	}
	public void checkArgs(String[] args) {
		if (args.length < 5) {
			System.out.println("Please supply server host name, session name,  user name and application name as main arguments");
			System.exit(-1);
		}
	}
	public  Communicator createCommunicator(String args[]) {
		checkArgs(args);
		sessionServerHost = args[0];
		userName = args[2];
		return CommunicatorSelector.getCommunicator(args[0],args[1],args[2], args[3], args[4]);
//		CommunicatorCreator communicatorFactory = ACommunicatorSelector.getCommunicatorFactory();
//		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
	}
	public void compose(String[] args) {
		communicator = createCommunicator(args);
		addCollaborationFunctions();
		communicator.join();
	}
	
}
//END OF FILE
//START OF FILE: src/im/aware/asessionawarenessprovider.java
package im.aware;

import java.util.Collection;

import javax.swing.JOptionPane;

import util.session.CommunicatorSelector;
import util.session.SessionMessageListener;
import util.trace.session.ClientJoinNotificationReceived;
import util.trace.session.ClientLeaveNotificationReceived;

public class ASessionAwarenessProvider implements SessionMessageListener {
	public void clientJoined(
			String aUserName, String anApplicationName, String aSessionName,
			boolean aNewSession, boolean aNewApplication, Collection<String> anAllUsers) {
		ClientJoinNotificationReceived.newCase(CommunicatorSelector.getProcessName(), aUserName, (String) anApplicationName, aSessionName, this);
		String aMessage = computeAwarenessMessage(aUserName, anApplicationName, aSessionName, aNewSession, aNewApplication, anAllUsers);
		JOptionPane.showMessageDialog(null, aMessage);
	}
	public String computeAwarenessMessage(String aUserName, Object anApplicationName, String aSessionName,
			boolean aNewSession, boolean aNewApplication, Collection<String> anAllUsers) {
		String newOrOldSession = aNewSession?" new ":"";
		String newOrOldApplication = aNewApplication?" new ":"";
		String message = "User: " + aUserName +
				" joined " + newOrOldApplication + " application: " + anApplicationName +
				" in " + newOrOldSession + " session: " + aSessionName +
				getOtherUserNames(anAllUsers, aUserName);
		return message;
	}
	String getOtherUserNames(Collection<String> allUsers, String myName) {
		if (allUsers.size() == 1)
			return "";
		String retVal = " with other users:";
		for (String userName:allUsers) {
			if (userName.equals(myName)) continue;
			retVal += " " + userName;
		}
		return retVal;
	}
	public void clientLeft(String aUserName, String anApplicationName) {
		ClientLeaveNotificationReceived.newCase(CommunicatorSelector.getProcessName(), aUserName, (String) anApplicationName,  this);
		String message = "User left session:" + aUserName;
		JOptionPane.showMessageDialog(null, message);
	}
}
//END OF FILE
//START OF FILE: src/im/aware/aliceimjoiner.java
package im.aware;

import im.AliceIM;
import sasa.echoerAndIM.AnIMComposerAndLauncher;
import trace.im.aware.AwareIMTracerSetter;
import util.session.Communicator;
import util.trace.TraceableInfo;
import util.trace.Tracer;

public class AliceIMJoiner extends AliceIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
		AwareIMTracerSetter.traceAwareIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, null,  Communicator.DIRECT};
//		String[] launcherArgs = {SESSION_SERVER_HOST, "foo", USER_NAME, USER_NAME,  Communicator.DIRECT};

		(new AJoiningIMComposerAndLauncher()).compose(launcherArgs);
	}	
}
//END OF FILE
//START OF FILE: src/im/aware/anawareimcomposerandlauncher.java
package im.aware;

import im.AnIMComposerAndLauncher;
import util.session.SessionMessageListener;

public class AnAwareIMComposerAndLauncher extends AnIMComposerAndLauncher implements AwareIMComposerAndLauncher{
	protected SessionMessageListener sessionAwarenesManager;
	public static void main (String[] args) {

		(new AnAwareIMComposerAndLauncher()).composeAndLaunch(args);
	}
	
	protected void addCollaborationFunctions() {
		super.addCollaborationFunctions();
		addAwareness();
	}
	
	public  void addAwareness() {
		sessionAwarenesManager = new ASessionAwarenessProvider();
		communicator.addSessionMessageListener(sessionAwarenesManager);
	}

	public SessionMessageListener getSessionAwarenesManager() {
		return sessionAwarenesManager;
	}
	
}
//END OF FILE
//START OF FILE: src/im/aware/awareimcomposerandlauncher.java
package im.aware;

import im.IMComposerAndLauncher;
import util.session.SessionMessageListener;

public interface AwareIMComposerAndLauncher extends IMComposerAndLauncher {
	public SessionMessageListener getSessionAwarenesManager();

}
//END OF FILE
//START OF FILE: src/im/aware/demoerofawareim.java
package im.aware;

import im.BobIM;
import im.CathyIM;
import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfAwareIM {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceIMJoiner.class,
				BobIM.class,
				CathyIM.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/causal/acausalimcomposerandlauncher.java
package im.causal;
import im.AnIMComposerAndLauncher;
import util.session.ReceivedMessageFilterSelector;
import util.session.SentMessageFilterSelector;
import util.session.Communicator;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;
import util.session.SentMessage;
public class ACausalIMComposerAndLauncher extends AnIMComposerAndLauncher {
	public static void main (String[] args) {

	}
	public Communicator createCommunicator(String args[]) {
		
		// set factories used to create communicator
//		ACommunicatorSelector.selectDirectCommunicator();
		CausalityManager causalityManager = new ACausalityManager(args[2]);
		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = 
			new ACausalReceivedMessageFilterCreator(causalityManager);
		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = 
			new ACausalSentMessageFilterCreator(causalityManager);
		ReceivedMessageFilterSelector.setMessageFilterFactory(receivedMessageQueuerCreator);
		SentMessageFilterSelector.setMessageFilterCreator(sentMessageQueuerCreator);
//		communicator = super.createCommunicator(args, applicationName);
		communicator = super.createCommunicator(args);

		communicator.addSessionMessageListener(causalityManager);
//		if (args[2].equalsIgnoreCase("alice"))
//			setDelaysAlice(communicator);
		return communicator;
//		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = new ADeTimeStampingReceivedMessageFilterCreator();
//		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = new ATimeStampingSentMessageFilterCreator();
//		AReceivedMessageFilterSelector
//				.setMessageFilterFactory(receivedMessageQueuerCreator);
//		ASentMessageFilterSelector
//				.setMessageFilterCreator(sentMessageQueuerCreator);
		
		
	}
	static void setDelaysAlice(Communicator communicator) {
		communicator.setMinimumDelayToPeer("Cathy", 20000);
	}
	
}
//END OF FILE
//START OF FILE: src/im/causal/acausalreceivedmessagefilter.java
package im.causal;

import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.ReceivedMessage;
// converts  simplex receiver  multicaster abstraction to duplex causal manager
public class ACausalReceivedMessageFilter implements MessageFilter<ReceivedMessage> {
	CausalityManager causalityManager;
	public ACausalReceivedMessageFilter(CausalityManager theCausalityManager) {
		causalityManager = theCausalityManager;
	}

	@Override
	public void filterMessage(ReceivedMessage message) {
		causalityManager.put(message);
	}

	@Override
	public void setMessageProcessor(MessageProcessor<ReceivedMessage> theMesssageProcessor) {
		causalityManager.setReceivedMessageProcessor(theMesssageProcessor);		
	}

}
//END OF FILE
//START OF FILE: src/im/causal/acausalreceivedmessagefiltercreator.java
package im.causal;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;

public class ACausalReceivedMessageFilterCreator  implements MessageFilterCreator<ReceivedMessage>{
	MessageFilter<ReceivedMessage> receivedMessageQueuer;
	CausalityManager causalityManager;
	public ACausalReceivedMessageFilterCreator(CausalityManager theCausalityManager) {
		causalityManager = theCausalityManager;
		receivedMessageQueuer =  new ACausalReceivedMessageFilter(causalityManager);
	}
	@Override
	public MessageFilter<ReceivedMessage> getMessageFilter() {
		return receivedMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/causal/acausalsentmessagefilter.java
package im.causal;

import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.SentMessage;
//converts  simplex sending  multicaster abstraction to duplex causal manager

public class ACausalSentMessageFilter implements MessageFilter<SentMessage> {
	CausalityManager causalityManager;
	MessageProcessor<SentMessage> sentMessageProcessor;
	public ACausalSentMessageFilter(CausalityManager theCausalityManager) {
		causalityManager = theCausalityManager;
	}

	@Override
	public void filterMessage(SentMessage message) {
//		causalityManager.put(message);	
		if (message.isUserMessage()) {
//			myVectorTimeStamp.addMessage(myUserName);
//			MessageWithVectorTimeStamp wrappedMessage = 
//				new AMessageWithVectorTimeStamp(message.getUserMessage(), (VectorTimeStamp) myVectorTimeStamp.clone());
			message.setUserMessage(causalityManager.timeStamp(message));
		}
		sentMessageProcessor.processMessage(message);	
	}

	@Override
	public void setMessageProcessor(MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageProcessor = theMesssageProcessor;
//		causalityManager.setSentMessageProcessor(theMesssageProcessor);		
	}

}
//END OF FILE
//START OF FILE: src/im/causal/acausalsentmessagefiltercreator.java
package im.causal;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.SentMessage;

public class ACausalSentMessageFilterCreator  implements MessageFilterCreator<SentMessage>{
	MessageFilter<SentMessage> sentMessageQueuer;
	CausalityManager causalityManager;
	public ACausalSentMessageFilterCreator(CausalityManager theCausalityManager) {
		causalityManager = theCausalityManager;
		sentMessageQueuer =  new ACausalSentMessageFilter(causalityManager);
	}
	@Override
	public MessageFilter<SentMessage> getMessageFilter() {
		return sentMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/causal/acausalitymanager.java
package im.causal;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import util.session.MessageProcessor;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.trace.Tracer;

public class ACausalityManager implements CausalityManager {
	MessageProcessor<ReceivedMessage> receivedMessageProcessor; // the succeeding queue to which incoming messages are sent after removing time stamp
	MessageProcessor<SentMessage> sentMessageProcessor; // the succeeding queue to which time stamped message is sent
	String myUserName ;
	VectorTimeStamp myVectorTimeStamp = new AVectorTimeStamp();	
	List<ReceivedMessage> pendingReceivedMessages = new ArrayList(); // a received message is pending until its preceding message arrives
	
	public ACausalityManager (String theMyUserName) {
		myUserName = theMyUserName;
	}
	int compareTo(ReceivedMessage message1, ReceivedMessage message2) {
		MessageWithVectorTimeStamp wrappedMessage1 = (MessageWithVectorTimeStamp) message1.getUserMessage();
		MessageWithVectorTimeStamp wrappedMessage2 = (MessageWithVectorTimeStamp) message2.getUserMessage();
		return wrappedMessage1.getVectorTimeStamp().compareTo(wrappedMessage2.getVectorTimeStamp());
		
	}
	boolean isSuccessor(ReceivedMessage message) {
		MessageWithVectorTimeStamp wrappedMessage = (MessageWithVectorTimeStamp) message.getUserMessage();
		
		return myVectorTimeStamp.isSuccessor(wrappedMessage.getVectorTimeStamp());
		
	}
	void insertIntSortedPendingMessages (ReceivedMessage receivedMessage) {
		int insertionIndex = 0;
		for (int i=0; i < pendingReceivedMessages.size(); i++) {
			if (compareTo(receivedMessage, pendingReceivedMessages.get(i)) <= 0)
				insertionIndex++;
			else
				break;
		}
		pendingReceivedMessages.add(insertionIndex, receivedMessage);			
		
	}
	// return false if next message is also not ready for processing
	boolean processNextPendingMessage() {
		if (pendingReceivedMessages.size() == 0)
			return false;
		ReceivedMessage nextPendingMessage = pendingReceivedMessages.get(0);
		if (isSuccessor(nextPendingMessage)) {
			processReadyReceivedMessage(nextPendingMessage);
			pendingReceivedMessages.remove(0);
			return true;
		}
		return false;
		
	}
	void  processPendingMessages() {
		// while next message is processsable, process (and remove) next message
		if (processNextPendingMessage()) //  side effect as in iterator
			processPendingMessages();		
	}
	
	void processReadyReceivedMessage(ReceivedMessage receivedMessage) {
		MessageWithVectorTimeStamp wrappedMessage = 
			(MessageWithVectorTimeStamp) receivedMessage.getUserMessage();
		Object actualMessage =  wrappedMessage.getMessage();
		receivedMessage.setUserMessage(actualMessage);
		myVectorTimeStamp.addMessage(receivedMessage.getClientName());
		receivedMessageProcessor.processMessage(receivedMessage);		
	}

	@Override
	public void put(ReceivedMessage message) {
		if (message.isUserMessage()) {
			MessageWithVectorTimeStamp wrappedMessage = 
				(MessageWithVectorTimeStamp) message.getUserMessage();			
			if (wrappedMessage.getVectorTimeStamp().isConcurrent(myVectorTimeStamp))
				processReadyReceivedMessage(message); // concurrent messages  delivered immediately, as they should be stopped by other means
			else {				
				insertIntSortedPendingMessages(message);	
				processPendingMessages();
			}
		} else {
			receivedMessageProcessor.processMessage(message);
		}				
	}

	@Override
	public void put(SentMessage message) {
		
		if (message.isUserMessage()) {
//			myVectorTimeStamp.addMessage(myUserName);
//			MessageWithVectorTimeStamp wrappedMessage = 
//				new AMessageWithVectorTimeStamp(message.getUserMessage(), (VectorTimeStamp) myVectorTimeStamp.clone());
			message.setUserMessage(timeStamp(message));
		}
		sentMessageProcessor.processMessage(message);		
	}
	@Override
	public  MessageWithVectorTimeStamp timeStamp(SentMessage message) {
		myVectorTimeStamp.addMessage(myUserName);
		MessageWithVectorTimeStamp wrappedMessage = 
			new AMessageWithVectorTimeStamp(message.getUserMessage(), (VectorTimeStamp) myVectorTimeStamp.clone());
		return wrappedMessage;
	}

	@Override
	public void setReceivedMessageProcessor(MessageProcessor<ReceivedMessage> theMessageProcessor) {
		receivedMessageProcessor = theMessageProcessor;
	}

	@Override
	public void setSentMessageProcessor(MessageProcessor<SentMessage> theMessageProcessor) {
		sentMessageProcessor = theMessageProcessor;
	}

	

	@Override
	public void clientJoined(String userName, String theApplicationName,
			String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
//		Tracer.info("Caisuality Manager: User Joined" + userName);		
		if (userName.equals(myUserName)) {
			myVectorTimeStamp.addUser(userName);
			for (String clientName:allUsers) {				
				myVectorTimeStamp.addUser(clientName);
//				Tracer.info("Vector TS:" + clientName + " :" + myVectorTimeStamp);
			}
		} else {
			myVectorTimeStamp.addUser(userName);
			//System.out.println("TS for" + userName);
//			Tracer.info("Vector TS:" + userName + " :" + myVectorTimeStamp);
		}
//		if (userName.equals(communicator.getUserName())) {
//			setClients(communicator.getClients());
//			
//		} 
//		myVectorTimeStamp.addUser(userName)	;
//		System.out.println(communicator.getUserName() + " joined by " + userName + " TS size:" + myVectorTimeStamp.size());
		
	}
	@Override
	public void clientLeft(String userName, String theApplicationName) {
		// TODO Auto-generated method stub
		
	}

}
//END OF FILE
//START OF FILE: src/im/causal/amessagewithvectortimestamp.java
package im.causal;

public class AMessageWithVectorTimeStamp implements MessageWithVectorTimeStamp {
	Object message;
	VectorTimeStamp vectorTimeStamp;
	public AMessageWithVectorTimeStamp (Object theMessage, VectorTimeStamp theVectorTimeStamp) {
		message = theMessage;
		vectorTimeStamp = theVectorTimeStamp;
		System.out.println("New Vector Time Stamp of size:" + vectorTimeStamp.size());
	}
	/* (non-Javadoc)
	 * @see causal.MessageWithVectorTimeStamp#getMessage()
	 */
	public Object getMessage() {
		return message;
	}
	/* (non-Javadoc)
	 * @see causal.MessageWithVectorTimeStamp#getVectorTimeStamp()
	 */
	public VectorTimeStamp getVectorTimeStamp() {
		return vectorTimeStamp;
	}
	public String toString() {
		return message.toString() + " " + vectorTimeStamp.toString();
	}

}
//END OF FILE
//START OF FILE: src/im/causal/anoncausalimcomposerandlauncher.java
package im.causal;
import old.echoerAndIM.AnIMComposerAndLauncher;
import old.echoerAndIM.AnOutCoupledEchoer;
import old.echoerAndIM.Echoer;
import util.session.Communicator;
public class ANonCausalIMComposerAndLauncher extends AnIMComposerAndLauncher {
	static String userName;
	public static void main (String[] args) {
		Communicator communicator = createCommunicator(args, APPLICATION_NAME);
		setDelaysAlice(communicator);
		Echoer outCouplerAndEchoer =  new AnOutCoupledEchoer(communicator);
		addAwarenessAndInCoupler(communicator, outCouplerAndEchoer);
		communicator.join();
		outCouplerAndEchoer.doInput();	
	}
	static void setDelaysAlice(Communicator communicator) {
		communicator.setMinimumDelayToPeer("cathy", 20000);
	}
	
}
//END OF FILE
//START OF FILE: src/im/causal/avectortimestamp.java
package im.causal;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class AVectorTimeStamp implements VectorTimeStamp {
	Map<String, Integer> userToCounter = new HashMap();

	@Override
	public void addMessage(String user) {
		userToCounter.put(user, userToCounter.get(user) + 1);
	}

	@Override
	public void addUser(String user) {
		userToCounter.put(user, 0);
	}

	@Override
	// assuming that the two time stamps are not concurrent
	public int compareTo(VectorTimeStamp other) {
		if (other.size() != size()) {
			throw new RuntimeException("Incomparable vector time stamps" + ". Others.size:" + other.size() );
		}
		Set<String> keys = userToCounter.keySet();
		
		for (String key: keys) {
			int myValue = get(key);
			int otherValue = other.get(key);
			int diff = otherValue - myValue;
			if (diff < 0)
				return -1;
			else if (diff > 0)
				return 1;			
		}
		return 0;		
	}
	public boolean isConcurrent(VectorTimeStamp other) {
		if (other.size() != size()) {
//			throw new RuntimeException("Incomparable vector time stamps: this:" + this + " other:" + other );
			throw new IncomparableVectorTimeStampException("Incomparable vector time stamps: this:" + this + " other:" + other );

		}
		Set<String> keys = userToCounter.keySet();
		boolean otherGreater = false;
		boolean thisGreater = false;
		for (String key: keys) {
			int myValue = get(key);
			int otherValue = other.get(key);
			int diff = otherValue - myValue;
			if (diff == 0)
				continue;
			else if (diff < 0 && !thisGreater) {
				thisGreater = true;
				if (otherGreater)
					return true;
			}
			else if (diff > 0 && !otherGreater) {
				otherGreater = true;
				if (thisGreater)
					return true;
					
			}
		}
		return false;		
		
	}
	public boolean isSuccessor(VectorTimeStamp other) {
		if (other.size() != size()) {
			throw new RuntimeException("Incomparable vector time stamps" );
		}
		Set<String> keys = userToCounter.keySet();
		boolean foundOneSuccessor= false;
		for (String key: keys) {
			int myValue = get(key);
			int otherValue = other.get(key);
			int diff = otherValue - myValue;
			if (diff == 0)
				continue;
			else if (diff < 0)
				return false;
			else if (diff == 1) {
				if (foundOneSuccessor)
					return false;
				else
					foundOneSuccessor = true;	
			} else 
				return false;			
		}
		return foundOneSuccessor;		
	}
	

	@Override
	public int get(String user) {
		return userToCounter.get(user);
	}

	@Override
	public int size() {
		return userToCounter.size();
	}
	public VectorTimeStamp clone() {
		AVectorTimeStamp retVal = new AVectorTimeStamp();
		Set<String> keys = userToCounter.keySet();
		for (String key: keys)
			retVal.userToCounter.put(key, get(key));
		return retVal;
	}
	public String toString() {
		return userToCounter.toString();
	}

}
//END OF FILE
//START OF FILE: src/im/causal/alicecausalim.java
package im.causal;
import im.IMComposerAndLauncher;
import im.delay.p2p.AliceP2PDelayingIM;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.TraceableInfo;
import util.trace.session.SessionTracerSetter;
public class AliceCausalIM extends AliceP2PDelayingIM {
	
	public static void main (String[] args) {
		IMTracerSetter.traceIM();
		
		TraceableInfo.setPrintThread(true);


//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, IMComposerAndLauncher.DIRECT};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME, Communicator.DIRECT};

		IMComposerAndLauncher composerAndLauncher = (new ACausalIMComposerAndLauncher());
		delayToCathyAndLaunch(composerAndLauncher);
	}
	
}
//END OF FILE
//START OF FILE: src/im/causal/bobcausalim.java
package im.causal;
import im.IMComposerAndLauncher;
import im.delay.p2p.BobP2PIM;
import trace.im.IMTracerSetter;
import util.session.Communicator;
public class BobCausalIM extends BobP2PIM {	
	public static void main (String[] args) {
		IMTracerSetter.traceIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME, Communicator.DIRECT};
		(new ACausalIMComposerAndLauncher()).composeAndLaunch(launcherArgs);

	}
	
}
//END OF FILE
//START OF FILE: src/im/causal/cathycausalim.java
package im.causal;
import im.IMComposerAndLauncher;
import im.delay.p2p.CathyP2PIM;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.ImplicitKeywordKind;
import util.trace.MessagePrefixKind;
import util.trace.Traceable;
import util.trace.TraceableInfo;
import util.trace.Tracer;
import util.trace.session.MessageGivenToFilter;
import util.trace.session.MessageReceived;
import util.trace.session.ProcessInfo;
import util.trace.session.ReceivedMessageDistributedToListeners;
import util.trace.session.SessionTracerSetter;
public class CathyCausalIM extends CathyP2PIM {
	
	public static void main (String[] args) {
		Tracer.showInfo(true);
		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
		TraceableInfo.setPrintSource(false);
		TraceableInfo.setPrintThread(false);
		ProcessInfo.setShowProcessName(false);
//		SessionTracerSetter.setSessionPrintStatus();

		Traceable.setPrintTime(false);
//		Traceable.setPrintThread(true);
		Tracer.setMessagePrefixKind(MessagePrefixKind.SHORT_CLASS_NAME);
//		Tracer.setKeywordPrintStatus(MessageReceived.class, true);
		Tracer.setKeywordPrintStatus(MessageGivenToFilter.class, true);
		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);
//		IMTracerSetter.traceIM();
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME, Communicator.DIRECT};

		(new ACausalIMComposerAndLauncher()).composeAndLaunch(launcherArgs);

	}
	
}
//END OF FILE
//START OF FILE: src/im/causal/causalitymanager.java
package im.causal;

import util.session.MessageProcessor;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.session.SessionMessageListener;

public interface CausalityManager extends SessionMessageListener{
	//public void setCommunicator(Communicator theCommunicator);
	public void put(ReceivedMessage message);
	public void put(SentMessage message);
	public void setReceivedMessageProcessor(MessageProcessor<ReceivedMessage> theMessageProcessor) ;
	public void setSentMessageProcessor(MessageProcessor<SentMessage> theMessageProcessor) ;
	MessageWithVectorTimeStamp timeStamp(SentMessage message);
}
//END OF FILE
//START OF FILE: src/im/causal/demoerofcaualim.java
package im.causal;

import im.BobIM;
import im.CathyIM;
import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfCaualIM {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceCausalIM.class,
				BobCausalIM.class,
				CathyCausalIM.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/causal/incomparablevectortimestampexception.java
package im.causal;

public class IncomparableVectorTimeStampException  extends RuntimeException{
	public IncomparableVectorTimeStampException(String message) {
		super(message);
	}

}
//END OF FILE
//START OF FILE: src/im/causal/messagewithvectortimestamp.java
package im.causal;

import java.io.Serializable;

public interface MessageWithVectorTimeStamp extends Serializable {

	public abstract Object getMessage();

	public abstract VectorTimeStamp getVectorTimeStamp();

}
//END OF FILE
//START OF FILE: src/im/causal/vectortimestamp.java
package im.causal;

import java.io.Serializable;

public interface VectorTimeStamp extends Serializable, Comparable<VectorTimeStamp> {
	public void addUser(String user);
	public void addMessage(String user);
	public int size();
	public int get(String user);
	public boolean isSuccessor(VectorTimeStamp other);
	public boolean isConcurrent(VectorTimeStamp other);
	public VectorTimeStamp clone();
}
//END OF FILE
//START OF FILE: src/im/centralized/acentralizedhistory.java
package im.centralized;

import im.AListEdit;
import im.ListEdit;
import im.OperationName;
import trace.im.ListEditSent;
import util.session.Communicator;
import util.trace.Tracer;
import util.trace.session.AddressedSentMessageInfo;
import echo.modular.AHistory;

public class ACentralizedHistory<ElementType> extends AHistory<ElementType> implements CentralizedHistory<ElementType> {
	Communicator communicator;
	public ACentralizedHistory(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	
	public synchronized void centralizedAdd(ElementType anInput, String aClientName) {
		int anIndex = size();
		super.add(anIndex, anInput);
		UserEdit<ElementType> usertEdit = new AUserEdit<ElementType>(OperationName.ADD, anIndex, anInput, aClientName);
		ListEditSent.newCase(
				communicator.getClientName(),
				usertEdit.getOperationName(), 
				usertEdit.getIndex(), 
				usertEdit.getElement(), 
				AddressedSentMessageInfo.OTHERS, this);
		communicator.toOthers(usertEdit);
	}
	
}
//END OF FILE
//START OF FILE: src/im/centralized/amasterimcomposerandlauncher.java
package im.centralized;

import im.AReplicatedHistory;
import im.AnIMComposerAndLauncher;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.PeerMessageListener;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
import echo.modular.AHistory;
import echo.modular.AnEchoComposerAndLauncher;
import echo.modular.EchoerInteractor;
import echo.modular.History;
public class AMasterIMComposerAndLauncher extends AnIMComposerAndLauncher {
	
		
	protected History<String> createHistory() {
		return new ACentralizedHistory<String>(communicator);
	}
	// no UI, so no interactor
	protected void connectModelInteractor() {
		
	}
	// same reason as above, no input
	public void launch() {
	}

	protected  void addInCoupler(Communicator communicator, History<String> aHistory) {
		inCoupler = new AMasterInCoupler(aHistory);
		communicator.addPeerMessageListener(inCoupler);
	}
	public static void main (String[] args) {
		Tracer.showInfo(true);
		SessionTracerSetter.setSessionPrintStatus();
		(new AMasterIMComposerAndLauncher()).composeAndLaunch(args);
	}
}
//END OF FILE
//START OF FILE: src/im/centralized/amasterincoupler.java
package im.centralized;

import im.AHistoryInCoupler;
import im.ListEdit;
import im.ReplicatedHistory;
import trace.im.ListEditReceived;
import util.session.CommunicatorSelector;
import util.session.PeerMessageListener;
import echo.modular.History;

public class AMasterInCoupler extends AHistoryInCoupler {
	
	public AMasterInCoupler(History<String>  aHistory) {
		super(aHistory);
	}	
//	protected void processReceivedListEdit (ListEdit<String> aRemoteEdit, String aUserName) {
//		history.add(aRemoteEdit.getElement());			
//	}	
	public void objectReceived(Object message, String userName) {
		// need for integration with RPC
		if (message instanceof String)
			((CentralizedHistory<String>) history).centralizedAdd((String) message, userName); 
	}
	protected void connectModelInteractor() {
		
	}

}
//END OF FILE
//START OF FILE: src/im/centralized/aslaveimcomposerandlauncher.java
package im.centralized;

import im.AnIMComposerAndLauncher;
import im.AnIMInteractor;
import im.ReplicatedHistory;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.PeerMessageListener;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
import echo.modular.AHistory;
import echo.modular.AnEchoComposerAndLauncher;
import echo.modular.EchoerInteractor;
import echo.modular.History;
public class ASlaveIMComposerAndLauncher extends AnIMComposerAndLauncher {
	
	
	protected History<String> createHistory() {
		return new AHistory<String>();
	}
	protected EchoerInteractor createInteractor() {
		return new ASlaveIMInteractor( history, communicator);
	}		

	protected  void addInCoupler(Communicator communicator, History<String> aHistory) {
		inCoupler = new ASlaveInCoupler(aHistory, communicator.getClientName());
		communicator.addPeerMessageListener(inCoupler);
	}
	public static void main (String[] args) {
		Tracer.showInfo(true);
		SessionTracerSetter.setSessionPrintStatus();
		(new ASlaveIMComposerAndLauncher()).composeAndLaunch(args);
	}
}
//END OF FILE
//START OF FILE: src/im/centralized/aslaveiminteractor.java
package im.centralized;

import im.AnIMInteractor;
import util.session.Communicator;
import echo.modular.AnEchoInteractor;
import echo.modular.History;

public class ASlaveIMInteractor extends AnIMInteractor  {
	public ASlaveIMInteractor(History<String> aHistory, Communicator aCommunicator) {
		super(aHistory, aCommunicator);
	}
	protected void addToHistory(String newValue) {
		communicator.toClient(MasterIMModelLauncher.CLIENT_NAME, newValue);
	}
	
}
//END OF FILE
//START OF FILE: src/im/centralized/aslaveincoupler.java
package im.centralized;

import im.AHistoryInCoupler;
import im.ListEdit;
import trace.im.ListEditReceived;
import util.session.CommunicatorSelector;
import util.session.PeerMessageListener;
import echo.modular.History;

public class ASlaveInCoupler extends AHistoryInCoupler {
	// History<String> history;
	String localUserName;

	public ASlaveInCoupler(History<String> theEchoer, String aUserName) {
		super(theEchoer);
		localUserName = aUserName;
	}

	@Override
	protected void processReceivedListEdit(ListEdit<String> aRemoteEdit,
			String aUserName) {
		if (!(aRemoteEdit instanceof UserEdit))
			return;
		String anInputterName = ((UserEdit<String>) aRemoteEdit).getUserName();
		if (localUserName.equals(anInputterName)) {
			history.observableAdd(aRemoteEdit.getIndex(),
					aRemoteEdit.getElement());
		} else {
			super.processReceivedListEdit(aRemoteEdit, anInputterName);
		}

	}

}
//END OF FILE
//START OF FILE: src/im/centralized/auseredit.java
package im.centralized;

import im.AListEdit;
import im.OperationName;

public class AUserEdit<ElementType> extends AListEdit<ElementType> implements UserEdit<ElementType>{
	String userName;
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public AUserEdit(OperationName aName, int anIndex, ElementType anElement, String aUserName) {
		super(aName, anIndex, anElement);
		userName = aUserName;
	}
	

}
//END OF FILE
//START OF FILE: src/im/centralized/aliceslaveim.java
package im.centralized;

import im.AliceIM;
import im.ExampleIMSession;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.Tracer;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;


public class AliceSlaveIM extends AliceIM{
//	public static final String USER_NAME = "Alice";
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new ASlaveIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/centralized/bobslaveim.java
package im.centralized;

import im.ExampleIMSession;
import im.BobIM;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.Tracer;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;


public class BobSlaveIM extends BobIM{
//	public static final String USER_NAME = "Bob";
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new ASlaveIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/centralized/centralizedhistory.java
package im.centralized;

import echo.modular.History;

public interface CentralizedHistory<ElementType> extends History<ElementType> {
	void centralizedAdd(ElementType newVal, String aUserName);
	

}
//END OF FILE
//START OF FILE: src/im/centralized/masterimmodellauncher.java
package im.centralized;

import im.ExampleIMSession;
import im.AnIMComposerAndLauncher;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.Tracer;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;


public class MasterIMModelLauncher implements ExampleIMSession{
	public static final String CLIENT_NAME = "Model";
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, CLIENT_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new AMasterIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/centralized/useredit.java
package im.centralized;

import im.ListEdit;

public interface UserEdit<ElementType> extends ListEdit<ElementType>{
	public String getUserName();
	public void setUserName(String userName) ;
}
//END OF FILE
//START OF FILE: src/im/delay/p2p/ademoerofdelayedp2pim.java
package im.delay.p2p;

import im.AnIMDemoerAndTester;
import im.AliceIM;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.List;

import util.misc.ThreadSupport;
import util.models.ConsoleModel;
import util.remote.ProcessExecer;
import bus.uigen.ObjectEditor;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassLaunchingUtility;
import bus.uigen.models.MainClassListLauncher;

public class ADemoerOfDelayedP2PIM extends AnIMDemoerAndTester implements DemoerAndTester{
	
	public static void main(String args[]) {
		DemoerAndTester demoer = createDemoer();
		MainClassListLauncher aLauncher = demoer.createAndDisplayLauncher();
		demoer.executeAll();
	}
	public static DemoerAndTester createDemoer() {
		return new ADemoerOfDelayedP2PIM();
	}
	protected Class aliceClass() {
		return 	AliceP2PDelayingIM.class;
	}
	protected Class bobClass() {
		return 	BobP2PIM.class;
	}
	protected Class cathyClass() {
		return 	CathyP2PIM.class;
	}


	
	
	
	
	
	
	
	
		
	
	
	

}
//END OF FILE
//START OF FILE: src/im/delay/p2p/alicep2pdelayingim.java
package im.delay.p2p;
import im.AliceIM;
import im.AnIMComposerAndLauncher;
import im.IMComposerAndLauncher;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.session.SessionTracerSetter;
public class AliceP2PDelayingIM extends AliceIM {	
	public static final int DELAY_TO_CATHY = 20000;
	public static void main (String[] args) {
		IMComposerAndLauncher composerAndLauncher = (new AnIMComposerAndLauncher());
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();
		delayToCathyAndLaunch(composerAndLauncher);
	}
	public static void delayToCathyAndLaunch(IMComposerAndLauncher composerAndLauncher) {
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, IMComposerAndLauncher.DIRECT};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME, Communicator.DIRECT};

		composerAndLauncher.compose(launcherArgs);
		composerAndLauncher.getCommunicator().setMinimumDelayToPeer(CathyP2PIM.USER_NAME,  DELAY_TO_CATHY);
		composerAndLauncher.launch();
		
	}
	
}
//END OF FILE
//START OF FILE: src/im/delay/p2p/bobp2pim.java
package im.delay.p2p;
import im.AnIMComposerAndLauncher;
import im.BobIM;
import im.IMComposerAndLauncher;
import trace.im.IMTracerSetter;
import util.trace.session.SessionTracerSetter;
public class BobP2PIM extends BobIM {	
	public static void main (String[] args) {
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, IMComposerAndLauncher.DIRECT};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME};

		IMComposerAndLauncher composerAndLauncher = (new AnIMComposerAndLauncher());
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();
		composerAndLauncher.composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/delay/p2p/cathyp2pim.java
package im.delay.p2p;
import im.AnIMComposerAndLauncher;
import im.CathyIM;
import im.IMComposerAndLauncher;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.session.SessionTracerSetter;
public class CathyP2PIM  extends CathyIM {	
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, Communicator.DIRECT};
		IMComposerAndLauncher composerAndLauncher = (new AnIMComposerAndLauncher());
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();
		composerAndLauncher.composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/mixed/ap2pandrelayedimcomposerandlauncher.java
package im.mixed;

import im.AnIMComposerAndLauncher;
import im.aware.ASessionAwarenessProvider;
import im.aware.AwareIMComposerAndLauncher;
import util.misc.ThreadSupport;
import util.session.Communicator;
import util.session.CommunicatorSelector;
import util.session.SessionMessageListener;

public class AP2PAndRelayedIMComposerAndLauncher extends AnIMComposerAndLauncher {
	public static void main (String[] args) {

		(new AP2PAndRelayedIMComposerAndLauncher()).composeAndLaunch(args);
		
	}
	
	
	public void compose(String[] args) {
		super.compose(args);
		Communicator relayerCommunicator =
				
		CommunicatorSelector.getRelayerCommunicator(args[0],
				args[1], args[2], args[3]);
		ThreadSupport.sleep(500); // need to get join notification, otherwise early event
		relayerCommunicator.toOthers("relayed communication");
	}
	
	
}
//END OF FILE
//START OF FILE: src/im/mixed/alicemixedim.java
package im.mixed;

import im.AliceIM;
import im.aware.AnAwareIMComposerAndLauncher;
import sasa.echoerAndIM.AnIMComposerAndLauncher;
import trace.im.IMTracerSetter;
import trace.im.aware.AwareIMTracerSetter;
import util.session.Communicator;
import util.session.CommunicatorSelector;
import util.trace.TraceableInfo;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
/*
 * This does not relaly work, cannot do both direct and p2p
 */
public class AliceMixedIM extends AliceIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
//		AwareIMTracerSetter.traceAwareIM();
		IMTracerSetter.traceIM();
		SessionTracerSetter.setSessionPrintStatus();
		SessionTracerSetter.setSessionPrintStatus();
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, AnIMComposerAndLauncher.DIRECT};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME};

		(new AP2PAndRelayedIMComposerAndLauncher()).composeAndLaunch(launcherArgs);

	}	
}
//END OF FILE
//START OF FILE: src/im/ot/alisteditwithottimestamp.java
package im.ot;

import trace.ot.OTTimeStampedListEditInfo;



public class AListEditWithOTTimeStamp implements ListEditWithOTTimeStamp {
	TransformableListEdit edit;
	OTTimeStamp otTimeStamp;
	public AListEditWithOTTimeStamp(TransformableListEdit theEdit, OTTimeStamp theTimeStamp ) {
		edit = theEdit;
		otTimeStamp = theTimeStamp;
	}
	public  TransformableListEdit getTransformableListEdit() {
		return edit;
	}
	public  void setTransformableListEdit(TransformableListEdit theCharInsertion) {
		edit = theCharInsertion;
	}

	public OTTimeStamp getOTTimeStamp() {
		return otTimeStamp;
	}
	public void setOTTimeStamp(OTTimeStamp otTimeStamp) {
		this.otTimeStamp = otTimeStamp;
	}
	public String toString() {
		return edit.toString() + ", " +  otTimeStamp;
	}
	@Override
	public OTTimeStampedListEditInfo toOTTimeStampedListEditInfo() {
		return new OTTimeStampedListEditInfo(edit.getListEdit().toListEditInfo(), otTimeStamp.toOTTimeStampInfo()) ;
	}
	
}
//END OF FILE
//START OF FILE: src/im/ot/areferencedobject.java
package im.ot;

public class AReferencedObject implements ReferencedObject{
	Object object;
	int referenceCount;
	public AReferencedObject (Object anObject, int aReferenceCount) {
		object = anObject;
		referenceCount = aReferenceCount;		
	}
	@Override
	public Object getObject() {
		return object;
	}
	@Override
	public int getReferenceCount() {
		return referenceCount;
	}
	@Override
	public void incrementReferenceCount() {
		referenceCount++;
	}
	@Override
	public void decrementReferenceCount() {
		referenceCount--;
		
	}
	
	public String toString() {
		return object.toString() + "RC(" + referenceCount + ")";
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/ot/atransformablelistedit.java
package im.ot;

import im.ListEdit;

public class ATransformableListEdit implements TransformableListEdit {	
	ListEdit listEdit;
	boolean isServer;
	public ATransformableListEdit(ListEdit  theEdit, boolean theIsServer) {
		listEdit = theEdit;
		isServer = theIsServer;		
	}
	
	public ListEdit getListEdit() {
		return listEdit;
	}
	
	public void setListEdit(ListEdit newVal) {
		this.listEdit = newVal;
	}
	
	public boolean isServer() {
		return isServer;
	}
	
	public void setServer(boolean isServer) {
		this.isServer = isServer;
	}
	public String toString() {
		return listEdit.toString() + 
				(isServer?"(Server)":"Client");
	}
	public TransformableListEdit copy() {
		return new ATransformableListEdit(listEdit.copy(), isServer);
	}
}
//END OF FILE
//START OF FILE: src/im/ot/aliceotim.java
package im.ot;
import im.IMComposerAndLauncher;
import im.causal.AliceCausalIM;
import trace.ot.OTIMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.ImplicitKeywordKind;
import util.trace.Tracer;
import util.trace.session.MessagePutInQueue;
import util.trace.session.MessageRetrievedFromQueue;
import util.trace.session.MessageSent;
import util.trace.session.ReceivedMessageDelayed;
import util.trace.session.ReceivedMessageDistributedToListeners;
import util.trace.session.SendDataRequest;
import util.trace.session.SentMessageDelayed;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.OT, ApplicationTags.IM, DistributedTags.CLIENT, DistributedTags.CLIENT_1})
public class AliceOTIM extends AliceCausalIM {
	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		OTIMTracerSetter.traceOTIM();
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, true);
//		OTIMTracerSetter.setOTPrintStatus();
//		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
//		Tracer.setKeywordPrintStatus(SentMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);
//		Tracer.setKeywordPrintStatus(MessagePutInQueue.class, true);
//		Tracer.setKeywordPrintStatus(MessageRetrievedFromQueue.class, true);
//		Tracer.setKeywordPrintStatus(MessageSent.class, true);

//		SessionTracerSetter.setSessionPrintStatus();
		

		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, APPLICATION_NAME, Communicator.RELAYED};
		IMComposerAndLauncher composerAndLauncher = (new AnOTIMComposerAndLauncher());
		composerAndLauncher.composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/ot/anotdemoerandtester.java
package im.ot;

import static im.IMUtililties.remoteEchoOf;
import static util.models.ConsoleModelUtility.containsText;
import static util.models.ConsoleModelUtility.getText;
import static util.models.ConsoleModelUtility.isConsole;
import static util.models.ConsoleModelUtility.isInfo;
import static util.models.ConsoleModelUtility.isOutput;
import static util.models.ConsoleModelUtility.isOutputLine;
import static util.trace.session.SessionTraceUtility.clientJoined;
import im.AliceIM;
import im.AnIMDemoerAndTester;
import im.BobIM;
import im.CathyIM;

import java.beans.PropertyChangeEvent;
import java.util.List;

import echo.modular.AModularEchoDemoerAndTester;
import echo.modular.AnEchoInteractor;
import trace.im.IMTraceChecker;
import trace.ot.OTTraceChecker;
import util.misc.ThreadSupport;
import util.models.ConsoleModel;
import util.tags.DistributedTags;
import util.trace.Traceable;
import bus.uigen.models.ADemoerAndTester;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;
import bus.uigen.trace.TraceUtility;

public class AnOTDemoerAndTester extends AnIMDemoerAndTester {
	protected boolean concurrentPhaseStarted;
	protected boolean aliceReceivedBobConcurrentInput;
	protected boolean aliceReceivedCathyConcurrentInput;
	protected boolean bobReceivedAliceConcurrentInput;
	protected boolean bobReceivedCathyConcurrentInput;
	protected boolean cathyReceivedAliceConcurrentInput;
	protected boolean cathyReceivedBobConcurrentInput;
	protected boolean concurrentPoemPartEntered;	
	protected int numConcurrentPhases = 2;
//	protected boolean transition = true;
	protected boolean concurrentPhaseTerminated;
	protected boolean concurrentPhasesTerminated;
	public static final int SERVER_SERIALIZATION_WAIT = 1000;

//	String[] otPoem = {
//			"My little horse must think it queer",  			 
//			"To stop without a farmhouse near",  			 
//			"Between the woods and frozen lake"
//	};

	
	public AnOTDemoerAndTester() {
	}
	
	public void initConcurrentPhase() {
		System.out.println("Initializing concurrent phase:" + numConcurrentPhases);
		concurrentPhaseStarted = true;
		aliceReceivedBobConcurrentInput = false;
		aliceReceivedCathyConcurrentInput = false;
		bobReceivedAliceConcurrentInput = false;
		bobReceivedCathyConcurrentInput = false;
		cathyReceivedAliceConcurrentInput = false;
		cathyReceivedBobConcurrentInput = false;
		concurrentPoemPartEntered = false;
	}
	
	
		
	
//	protected Class[] composeMainClasses() {
//		return new Class[] {
//			sessionManagerClass(),
//			aliceClass(),
//			bobClass(),
//			cathyClass()				
//		};
//	}
	
	protected Class sessionManagerClass() {
		return OTSessionManagerServerStarter.class;
	}
	
	protected Class aliceClass() {
		return 	AliceOTIM.class;
	}
	
	protected Class bobClass() {
		return 	BobOTIM.class;
	}
	
	protected Class cathyClass() {
		return 	CathyOTIM.class;
	}
	
	void enterConcurrentPart() {
//		enterAliceDummyString();
//		ThreadSupport.sleep(100); // avoid race conditions
		enterAlicePart();
		ThreadSupport.sleep(SERVER_SERIALIZATION_WAIT); // make it deterministic
//		enterBobDummyString();
//		ThreadSupport.sleep(100); // avoid race conditions
		enterBobPart();
		ThreadSupport.sleep(SERVER_SERIALIZATION_WAIT);

//		ThreadSupport.sleep(100);
//		enterCathyDummyString();
//		ThreadSupport.sleep(100); // avoid race conditions
		enterCathyPart();
		concurrentPoemPartEntered = true;
	}
	
	protected void processAllJoined() {
		enterConcurrentPart();
	}
	
	
	protected   Boolean testAgainstCorrectTranscripts(List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		return super.testAgainstCorrectTranscripts(aTestTraceableList, aCorrectTraceableList)
		& OTTraceChecker.compareOTSequences(aTestTraceableList,
				aCorrectTraceableList);
				
	}

	

	
//	protected boolean maybeProcessInputPhase(PropertyChangeEvent aConsoleModelEvent) {
//		// 
//		return true;
//		
//	}
//	protected boolean maybeProcessTestPhase(PropertyChangeEvent aConsoleModelEvent) {
//		if (allCorrect())
//			return false;
//		if (!isOutput(aConsoleModelEvent))
//			return true;
//		if (!containsText(aConsoleModelEvent, finalOutput))
//			return true;
//		if (isConsole(aConsoleModelEvent, aliceClass())) {
//				aliceCorrect = true;
//		} else if (isConsole(aConsoleModelEvent, bobClass())) {
//				bobCorrect = true;
//		} else if (isConsole(aConsoleModelEvent, cathyClass())) {
//				cathyCorrect = true;
//		}
//		return true;		
//	}
	protected boolean concurrentInputOver() {
		return aliceReceivedBobConcurrentInput && aliceReceivedCathyConcurrentInput
				&& bobReceivedAliceConcurrentInput && bobReceivedCathyConcurrentInput 
				&& cathyReceivedAliceConcurrentInput && cathyReceivedBobConcurrentInput;
	}
//	protected boolean maybeProcessConcurrentInputPhase(
//			PropertyChangeEvent aConsoleModelEvent) {
//		if (concurrentInputOver())
//			return false;
//		if (!isOutputLine(aConsoleModelEvent)) // continue phase, but it is not
//												// over
//			return true;
//		if (concurrentPoemPartEntered)
//			return 
//		
//		if (causalPoemEntered)
//			enterHistoryAndViewOutput(aConsoleModelEvent);
//		else
//			causalInteractiveEnterPoem(aConsoleModelEvent);
//		return true;
//
//	}
	@Override
	public void propertyChange(PropertyChangeEvent aConsoleModelEvent) {
//		System.out.println("Received property" + aConsoleModelEvent.getSource() + " " + aConsoleModelEvent.getNewValue());

		// process each of the phases after the preceding ones have finished
		if (maybeProcessJoinPhase(aConsoleModelEvent))
			return;
		else if (joinPhaseTerminated) {
			joinPhaseTerminated = false;
			processAllJoined();
			return;

		} else	if (maybeProcessConcurrentIOPhase(aConsoleModelEvent)) return;
		// do  not consume first event after concurrent phase as it was
		// consumed by the concurrent phase
		else if (concurrentPhaseTerminated) {
			// start causal phase here after the event has been consumed
			// and not in processConcurrentPhaseFinished
			concurrentPhaseTerminated = false;
			System.out.println("concurrent phase terminated");
			processConcurrentPhaseFinished(aConsoleModelEvent);
		
//			 do not trigger input here
			return;
//		} else if (!causalPhaseStarted) {
//			processConcurrentPhaseFinished(aConsoleModelEvent);

		} else	if (maybeProcessCausalIOPhase(aConsoleModelEvent)) {
			return;
		} else if (causalPhaseTerminated) {
			causalPhaseTerminated = false;
			// we do not really need the event do we?
			processCausalPhaseFinished(aConsoleModelEvent);
		
	} else if (viewHistoryOutput(aConsoleModelEvent))
		return;
	else if (!isTerminated())
			notifyInteractionTermination();
//		if (maybeProcessConcurrentIOPhase(aConsoleModelEvent)) return;		

//		if (maybeProcessTestPhase(aConsoleModelEvent)) return;
//		launcher.terminateAll();
		
	}
	// be careful about enetring new input as the previous inpt has not been consumed
	// and transition will get confused
	protected void processConcurrentPhasesFinished(PropertyChangeEvent aConsoleModelEvent) {
//		causalPhaseStarted = true;
//		enterAlicePart();
		startCausalPhase();
	}
	
	protected void restartConcurrentPhase(PropertyChangeEvent aConsoleModelEvent) {
		initConcurrentPhase();
		enterConcurrentPart();
	}
	protected void startPhaseAfterConcurrentPhase(PropertyChangeEvent aConsoleModelEvent) {
		restartConcurrentPhase(aConsoleModelEvent);


	}
	
	protected boolean processConcurrentPhaseFinished(PropertyChangeEvent aConsoleModelEvent) {
		numConcurrentPhases --;
		if (numConcurrentPhases > 0)  {
			startPhaseAfterConcurrentPhase(aConsoleModelEvent);
			// let us start another concurrent phase
//			restartConcurrentPhase(aConsoleModelEvent);
//			initConcurrentPhase();
//			enterConcurrentPart();
			return true;
		} else {
			
//		causalPhaseStarted = true;
//		enterAlicePart();
			processConcurrentPhasesFinished(aConsoleModelEvent);
			return false;
		}
	}
	protected boolean maybeProcessConcurrentIOPhase(
			PropertyChangeEvent aConsoleModelEvent) {
		if (!isOutputLine(aConsoleModelEvent)) // continue phase, but it is not
			// over
			return true;

		// do this check so we dont waste time doing the other processing
		if (concurrentInputOver())
			return false;

		// we will get output echoed
		// as info, so let us ignore
		// the info part

		if (isInfo(aConsoleModelEvent))
			return true;
		if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_1, bobInput,
				BobIM.USER_NAME)) {
			aliceReceivedBobConcurrentInput = true;
			System.out.println( numConcurrentPhases + "aliceReceivedBobConcurrentInput:" + bobInput );


		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_1,
				cathyInput, CathyIM.USER_NAME)) {
			aliceReceivedCathyConcurrentInput = true;
			System.out.println(numConcurrentPhases + "aliceReceivedCathyConcurrentInput:" + cathyInput);


		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_2,
				aliceInput, AliceIM.USER_NAME)) {
			bobReceivedAliceConcurrentInput = true;
			System.out.println(numConcurrentPhases + "bobReceivedAliceConcurrentInput:" + aliceInput);

		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_2,
				cathyInput, CathyIM.USER_NAME)) {
			bobReceivedCathyConcurrentInput = true;
			System.out.println(numConcurrentPhases + "bobReceivedCathyConcurrentInput:" + cathyInput);

		}else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_3, bobInput,
				BobIM.USER_NAME)) {
			cathyReceivedBobConcurrentInput = true;
			System.out.println(numConcurrentPhases + "cathyReceivedBobConcurrentInput:" + bobInput );

			// inputOver = true; // for some reason this was deleted
		} else if (receivedRemoteEcho(aConsoleModelEvent, DistributedTags.CLIENT_3,
				aliceInput, AliceIM.USER_NAME)) {
			cathyReceivedAliceConcurrentInput = true;
			System.out.println(numConcurrentPhases + "cathyReceivedAliceConcurrentInput" + aliceInput);

			// inputOver = true; // for some reason this was deleted
		} 

		// do teh check again so we let caller know this phase is over
		// start causal phase
		if (concurrentInputOver()) {
			concurrentPhaseTerminated = true;
			return false;
					
//					processConcurrentPhaseFinished(aConsoleModelEvent);
//			if (numConcurrentPhases > 0)  {
//				// let us start another concurrent phase
//				numConcurrentPhases --;
//				initConcurrentPhase();
//				enterConcurrentPart();
//				return true;
//			} else {
//				
//			causalPhaseStarted = true;
//			enterAlicePart();
//			return false;
//			}
		}
		return true;

	}
	

}
//END OF FILE
//START OF FILE: src/im/ot/anotimcomposerandlauncher.java
package im.ot;

import im.AnIMComposerAndLauncher;
import util.session.ReceivedMessageFilterSelector;
import util.session.SentMessageFilterSelector;
import util.session.Communicator;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;
import util.session.SentMessage;
public class AnOTIMComposerAndLauncher extends AnIMComposerAndLauncher {
	public static void main (String[] args) {
//		Tracer.showInfo(true);
//		ACommunicatorSelector.selectDirectCommunicator();
//		CausalityManager causalityManager = new ACausalityManager(args[2]);
//		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = 
//			new ACausalReceivedMessageFilterCreator(causalityManager);
//		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = 
//			new ACausalSentMessageFilterCreator(causalityManager);
//		AReceivedMessageFilterSelector.setMessageFilterFactory(receivedMessageQueuerCreator);
//		ASentMessageFilterSelector.setMessageFilterCreator(sentMessageQueuerCreator);
//		Communicator communicator = createCommunicator(args, APPLICATION_NAME);
//		communicator.addSessionMessageListener(causalityManager);		
//		if (args[2].equalsIgnoreCase("alice"))
//			setDelaysAlice(communicator);
//		Echoer outCouplerAndEchoer =  new AnOutCoupledEchoer(communicator);
//		addAwarenessAndInCoupler(communicator, outCouplerAndEchoer);
//		//communicator.join();
//		communicator.join();
//		outCouplerAndEchoer.doInput();	
	}
	public Communicator createCommunicator(String args[]) {
		
		// set factories used to create communicator
//		ACommunicatorSelector.selectDirectCommunicator();

		OTManager otManager = new AnOTManager(args[1], args[2], false);
		MessageFilterCreator<ReceivedMessage> receivedMessageFilterCreator = 
				new AnOTReceivedMessageFilterCreator(otManager);
			MessageFilterCreator<SentMessage> sentMessageFilterCreator = 
				new AnOTSentMessageFilterCreator(otManager);
			ReceivedMessageFilterSelector.setMessageFilterFactory(receivedMessageFilterCreator);
			SentMessageFilterSelector.setMessageFilterCreator(sentMessageFilterCreator);
		
		communicator = super.createCommunicator(args);
//		communicator.addSessionMessageListener(new ASessionAwarenessProvider());

//		if (args[2].equalsIgnoreCase("alice"))
//			setDelaysAlice(communicator);
		communicator.setMinimumDelayToServer(4000);
		return communicator;
//		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = new ADeTimeStampingReceivedMessageFilterCreator();
//		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = new ATimeStampingSentMessageFilterCreator();
//		AReceivedMessageFilterSelector
//				.setMessageFilterFactory(receivedMessageQueuerCreator);
//		ASentMessageFilterSelector
//				.setMessageFilterCreator(sentMessageQueuerCreator);
		
		
	}
	
	
}
//END OF FILE
//START OF FILE: src/im/ot/anotmanager.java
package im.ot;

import im.ListEdit;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;

import trace.echo.modular.ListEditInfo;
import trace.ot.ConcurrentEdits;
import trace.ot.InitialOTTimeStampCreated;
import trace.ot.LocalSiteCountIncremented;
import trace.ot.OTTimeStampInfo;
import trace.ot.OTListEditRemoteCountIncremented;
import trace.ot.OTListEditCopied;
import trace.ot.OTListEditSent;
import trace.ot.RemoteSiteCountIncremented;
import trace.ot.TransformationOperands;
import trace.ot.TransformationResult;
import util.models.ABoundedBuffer;
import util.session.CommunicatorSelector;
import util.session.ASessionManagerSelector;
import util.session.ReceivedMessage;
import util.session.SentMessage;
import util.session.SessionManager;
import util.trace.Tracer;
import util.trace.session.MessageBufferReferenceCountDecremented;
import util.trace.session.MessageBuffered;
import util.trace.session.MessageUnBuffered;

public class AnOTManager implements OTManager {
	String userName;
	
//	BoundedBuffer<ReceivedMessage> inQueue;
	ABoundedBuffer<SentMessage> outQueue;
	boolean isServer ;
	OTTimeStamp myOTTimeStamp; 	
	//Communicator communicator;
//	List<ReferencedObject<SentMessage>> sentMessages = new ArrayList();
	List<SentMessage> sentMessages = new ArrayList();

	OperationTransformer operationTransformer = AnOperationTransfomerSelector.getOperationTransformer();
	String location;
	String sessionName;
	public AnOTManager (String theSessionName, String theUserName, boolean theIsServer) {
		sessionName = theSessionName; 
		isServer = theIsServer;
		userName = theUserName;
		myOTTimeStamp = new AnOTTimeStamp();
		location = computedLocation();
		InitialOTTimeStampCreated.newCase(
				location,
				userName, 
				myOTTimeStamp.getLocalCount(), 
				myOTTimeStamp.getRemoteCount(), 
				theIsServer, 
				this);
	}	
	
	String computedLocation() {
		return isServer?SessionManager.SESSION_MANAGER_NAME:userName; // communicator not created when OT manager is instantiated
	}
	
	public String getLocation() {
		return location;
	}

//	@Override
//	public synchronized void put(ReceivedMessage message) {
//		if (message.isUserMessage()) {
//			//Message.info ("OT Manager receiving message:" + message.getUserMessage());
//			EditWithOTTimeStamp receivedTSEdit = 
//				(EditWithOTTimeStamp) message.getUserMessage();			
//			processReceivedMessage(receivedTSEdit);
//			message.setUserMessage(receivedTSEdit.getTransformableEdit().getEdit());
//			//myOTTimeStamp.incrementRemoteCount();
//			//Message.info("After received:" +myOTTimeStamp + " isServer:" + isServer);
//
//		}
//		if (inQueue != null)
//			inQueue.put(message);			
//				
//	}
	
	// trasnform received edit, changing its edit and time stamp, and also change site time stamp
	// clear buffered messages from other sites (server) whose time stamp is strictly less than
	// the one sent by this one 
	
	public void processTimeStampedEdit(ListEditWithOTTimeStamp receivedTSEdit, String fromUser, boolean isServer) { 
		Tracer.info(this, "Transforming:" + receivedTSEdit);
		
		int firstConcurrentMessageIndex = sentMessages.size();
		for (int i = 0; i < sentMessages.size(); i++) {
//			SentMessage aSentMessage = sentMessages.get(i).getObject();
			SentMessage aSentMessage = sentMessages.get(i);

//			ListEditWithOTTimeStamp sentTSEdit = (ListEditWithOTTimeStamp )sentMessages.get(i).getUserMessage();
			ListEditWithOTTimeStamp sentTSEdit = (ListEditWithOTTimeStamp )aSentMessage.getUserMessage();

			if (sentTSEdit.getOTTimeStamp().isConcurrent(receivedTSEdit.getOTTimeStamp())) {
//				Tracer.info(this, "Found concurrent sent message: " + sentTSEdit);
				traceConcurentEdits(receivedTSEdit, fromUser, !this.isServer, sentTSEdit, aSentMessage.getSendingUser(), this.isServer, this);
				firstConcurrentMessageIndex = i;
				break;
			}
		}
	
		for (int deleteNum = 0; deleteNum < firstConcurrentMessageIndex; deleteNum++ ) {
//			SentMessage sentMessage = sentMessages.get(0);
//			Message
//			sentMessages.remove(0);	
			maybeRemoveFirstSentMessage(); // the called method will trace
		}
		
		TransformableListEdit receivedTransformableEdit = receivedTSEdit.getTransformableListEdit(); // just accessing a field
		Tracer.info(this, "Transforming repeatedly received:" + receivedTSEdit);
		//myOTTimeStamp.incrementRemoteCount();
//		for (ReferencedObject<SentMessage> sentMessage:sentMessages) {
		for (SentMessage sentMessage:sentMessages) {

//			ListEditWithOTTimeStamp sentTSEdit = (ListEditWithOTTimeStamp)sentMessage.getObject().getUserMessage();
			ListEditWithOTTimeStamp sentTSEdit = (ListEditWithOTTimeStamp)sentMessage.getUserMessage();

			Tracer.info(this, "transforming wrt buffered:" + sentTSEdit);
			TransformableListEdit sentTransformableEdit = sentTSEdit.getTransformableListEdit();
			ListEdit transformedReceived = operationTransformer.transform(
						receivedTransformableEdit, sentTransformableEdit);
			traceTransformationOperands(receivedTSEdit, fromUser, !isServer, sentTSEdit, sentMessage.getSendingUser(), isServer, this);

//			traceTransformationOperands(receivedTSEdit, fromUser, !isServer, sentTSEdit, sentMessage.getObject().getSendingUser(), isServer, this);
			ListEdit transformedSent = operationTransformer.transform(sentTransformableEdit, receivedTransformableEdit);			
//			traceTransformationOperands(sentTSEdit, sentMessage.getObject().getSendingUser(), isServer, receivedTSEdit, fromUser, !isServer, this);
			traceTransformationOperands(sentTSEdit, sentMessage.getSendingUser(), isServer, receivedTSEdit, fromUser, !isServer, this);

			// change the original edits after both have been transformed
			sentTransformableEdit.setListEdit(transformedSent);			
//			traceTransformationResult(sentTSEdit,sentMessage.getObject().getSendingUser(), this, isServer);			
			traceTransformationResult(sentTSEdit,sentMessage.getSendingUser(), this, isServer);			

			receivedTransformableEdit.setListEdit(transformedReceived);
			traceTransformationResult(receivedTSEdit,fromUser, this, !isServer);
			sentTSEdit.getOTTimeStamp().incrementRemoteCount();			
			traceRemoteCountIncrement(sentTSEdit, userName, this);
			receivedTSEdit.getOTTimeStamp().incrementRemoteCount();	
			traceRemoteCountIncrement(receivedTSEdit, fromUser, this);
			Tracer.info(this, "buffered transformed to:" + sentTSEdit);
			Tracer.info(this, "Received transformed to:" + receivedTSEdit);
		}
		myOTTimeStamp.incrementRemoteCount();		
		RemoteSiteCountIncremented.newCase(
				CommunicatorSelector.getProcessName(),
				userName, 
				myOTTimeStamp.getLocalCount(), 
				myOTTimeStamp.getRemoteCount(), 
//				this.isServer, 
				this);		
		Tracer.info(this, "Transformed:" + receivedTSEdit);
		Tracer.info(this, "My Time Stamp:" + myOTTimeStamp);
	}
	
	
	public void storeSentMessage(SentMessage message) {
		// if in server, then the sent client message becomes a server message
//		((ListEditWithOTTimeStamp)message.getUserMessage()).getTransformableListEdit().setServer(isServer);
//		int referenceCount = 0;
//		try {
//		int	referenceCount = isServer? 1 // a server has buffer for each user, count is 1
////					ASessionManagerSelector.getSessionManager().
////						getOrCreateSession(sessionName).
////							getClientNames().size()
//					:ACommunicatorSelector.getCommunicator().
//						getUserNames().length; // this is all user names
//		} catch (RemoteException e) {
//			e.printStackTrace();
//		}
//		if (referenceCount <= 0) {
//		ReferencedObject referencedObject = new AReferencedObject(message, referenceCount );
//		sentMessages.add(referencedObject);
		
		sentMessages.add(message);
		MessageBuffered.newCase(
				CommunicatorSelector.getProcessName(), 
//				message.getUserMessage(), 
				message,
				userName, 
				sentMessages,
//				referenceCount,
				this);
//		}
	}
	void maybeRemoveFirstSentMessage() {
//		ReferencedObject<SentMessage> sentMessage = sentMessages.get(0);
//		sentMessage.decrementReferenceCount();
//		MessageBufferReferenceCountDecremented.newCase(
//				computedLocation(), 
////				sentMessage.getObject().getUserMessage(), 
//				sentMessage, 
//				userName, 
//				sentMessages,
////				sentMessage.getReferenceCount(),
//				this);
//		if (sentMessage.getReferenceCount() <= 0) {
//		sentMessages.remove(0);	
//		MessageUnBuffered.newCase(
//				computedLocation(), 
////				sentMessage.getObject().getUserMessage(), 
//				sentMessage,
//				userName, 
//				sentMessages,
////				sentMessage.getReferenceCount(),
//				this);
//		}
		SentMessage sentMessage = sentMessages.get(0);
		sentMessages.remove(0);	
		MessageUnBuffered.newCase(
				computedLocation(), 
//				sentMessage.getObject().getUserMessage(), 
				sentMessage,
				userName, 
				sentMessages,
//				sentMessage.getReferenceCount(),
				this);
		
	}
	public ListEditWithOTTimeStamp processSentEdit(ListEdit edit ) { // time stamps and change site time stamp
		Tracer.info (this, "Raw Edit:" + edit);		
		myOTTimeStamp.incrementLocalCount();
		LocalSiteCountIncremented.newCase(
				CommunicatorSelector.getProcessName(),
				userName, 
				myOTTimeStamp.getLocalCount(), 
				myOTTimeStamp.getRemoteCount(), 
//				isServer, 
				this);

		TransformableListEdit transformableEdit = new ATransformableListEdit(edit, isServer);
		ListEditWithOTTimeStamp timeStampedEdit = new AListEditWithOTTimeStamp(transformableEdit, myOTTimeStamp.copy());			
		traceOTEditCopy(timeStampedEdit, this);

		return timeStampedEdit;		
	}
	@Override
	public String getUserName() {
		return userName;
	}
	
	public static void traceRemoteCountIncrement(ListEditWithOTTimeStamp anOTEdit, String aFromUser, OTManager anOTManager) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		OTListEditRemoteCountIncremented.newCase(
				CommunicatorSelector.getProcessName(),
				editInfo,
				otTimeStampInfo,
				aFromUser,
//				anOTManager.isServer(), // will always be true
				anOTManager);
	}
	
	public static void traceTransformationResult(ListEditWithOTTimeStamp anOTEdit, String aFromUser, OTManager anOTManager, boolean anIsServer) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		TransformationResult.newCase(
				anOTManager.getLocation(),
				editInfo,
				otTimeStampInfo,
				aFromUser,
				anIsServer,
				anOTManager);
	}


	
	public static void traceConcurentEdits(
			ListEditWithOTTimeStamp anOTEdit1,
			String aUser1,
			boolean anIsServer1,
			ListEditWithOTTimeStamp anOTEdit2,
			String aUser2,
			boolean anIsServer2,			
			OTManager anOTManager) {
		OTTimeStampInfo otTimeStampInfo1 = anOTEdit1.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo1 = anOTEdit1.getTransformableListEdit().getListEdit().toListEditInfo();
		OTTimeStampInfo otTimeStampInfo2 = anOTEdit2.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo2 = anOTEdit2.getTransformableListEdit().getListEdit().toListEditInfo();
		ConcurrentEdits.newCase(
				CommunicatorSelector.getProcessName(), 
				editInfo1, 
				otTimeStampInfo1, 
				aUser1, 
//				anIsServer1, 
				editInfo2, 
				otTimeStampInfo2, 
				aUser2, 
//				anIsServer2, 
				anOTManager);
	}
	public static void traceTransformationOperands(
			ListEditWithOTTimeStamp anOTEdit1,
			String aUser1,
			boolean anIsServer1,
			ListEditWithOTTimeStamp anOTEdit2,
			String aUser2,
			boolean anIsServer2,			
			OTManager anOTManager) {
		OTTimeStampInfo otTimeStampInfo1 = anOTEdit1.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo1 = anOTEdit1.getTransformableListEdit().getListEdit().toListEditInfo();
		OTTimeStampInfo otTimeStampInfo2 = anOTEdit2.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo2 = anOTEdit2.getTransformableListEdit().getListEdit().toListEditInfo();
		TransformationOperands.newCase(
				CommunicatorSelector.getProcessName(), 
				editInfo1, 
				otTimeStampInfo1, 
				aUser1, 
//				anIsServer1, 
				editInfo2, 
				otTimeStampInfo2, 
				aUser2, 
//				anIsServer2, 
				anOTManager);
	}
	
	
	public static void traceOTEditCopy(ListEditWithOTTimeStamp anOTEdit,  OTManager anOTManager) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		OTListEditCopied.newCase(
				CommunicatorSelector.getProcessName(),
				editInfo,
				otTimeStampInfo,
				anOTManager.getUserName(),
//				anOTManager.isServer(), // will always be true
				anOTManager);
	}
	
	public static void traceOTEditSent(ListEditWithOTTimeStamp anOTEdit,  OTManager anOTManager) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		
		OTListEditSent.newCase(
				CommunicatorSelector.getProcessName(),
				editInfo,
				otTimeStampInfo,
				anOTManager.getUserName(),
//				anOTManager.isServer(), // will always be true
				anOTManager);
	}

//	@Override
//	public void setReceivedMessageQueue(BoundedBuffer<ReceivedMessage> theBuffer) {
//		inQueue = theBuffer;
//	}
//
//	@Override
//	public void setSentMessageQueue(BoundedBuffer<SentMessage> theBuffer) {
//		outQueue = theBuffer;
//	}

	
//	public void setClients(Map<MessageReceiver, String> theClients)	{
//		Collection<String> values = theClients.values();
//		for (String clientName:values) {
//			System.out.println("TS for" + clientName);
//			myOTTimeStamp.addUser(clientName);
//		}
//		
//	}
	@Override
	public boolean isServer() {
		return isServer;
	}
	

}
//END OF FILE
//START OF FILE: src/im/ot/anotreceivedmessagefilter.java
package im.ot;

import trace.echo.modular.ListEditInfo;
import trace.ot.OTTimeStampInfo;
import trace.ot.OTListEditReceived;
import trace.ot.OTListEditFlipped;
import util.session.CommunicatorSelector;
import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.ReceivedMessage;

public class AnOTReceivedMessageFilter implements MessageFilter<ReceivedMessage> {
	OTManager otManager;
	MessageProcessor<ReceivedMessage> receivedMessageQueue;
	public AnOTReceivedMessageFilter(OTManager theOTManager) {
		otManager = theOTManager;
	}
	@Override
	public void filterMessage(ReceivedMessage message) {
		if (!message.isUserMessage() ) {
			receivedMessageQueue.processMessage(message);
			return;
		}		
		ListEditWithOTTimeStamp receivedTSEdit = 
			(ListEditWithOTTimeStamp) message.getUserMessage();	
		String fromUser = message.getClientName();
		
		traceOTEditReceive(receivedTSEdit, fromUser, false, this);
		receivedTSEdit.getOTTimeStamp().flip(); // our OT function compares local with local now
		traceOTEditFlip(receivedTSEdit, fromUser, false, this);

		
//		// start notify tracer
//		OTTimeStampInfo otTimeStampInfo = receivedTSEdit.getOTTimeStamp().toOTTimeStampInfo();		
//		ListEditInfo editInfo = receivedTSEdit.getTransformableListEdit().getListEdit().toListEditInfo();
//		UserOTTimeStampedListEditReceived.newCase(
//				ACommunicatorSelector.getProcessName(),
//				editInfo,
//				otTimeStampInfo,
//				fromUser,
//				receivedTSEdit.getTransformableListEdit().isServer(), // will always be true
//				this);
//		// end notify tracer
		// client receives edit from server
		otManager.processTimeStampedEdit(receivedTSEdit, fromUser, true);		
		message.setUserMessage(receivedTSEdit.getTransformableListEdit().getListEdit());		
		receivedMessageQueue.processMessage(message);		
	}
	@Override
	public void setMessageProcessor(MessageProcessor<ReceivedMessage> theMesssageProcessor) {
		receivedMessageQueue = theMesssageProcessor;		
	}
	
	public static void traceOTEditReceive(ListEditWithOTTimeStamp anOTEdit, String aUser, boolean isServer, Object aFinder) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		OTListEditReceived.newCase(
				CommunicatorSelector.getProcessName(),
				editInfo,
				otTimeStampInfo,
				aUser,
//				isServer,
				aFinder);
	}
	
	public static void traceOTEditFlip(ListEditWithOTTimeStamp anOTEdit, String aUser, boolean isServer, Object aFinder) {
		OTTimeStampInfo otTimeStampInfo = anOTEdit.getOTTimeStamp().toOTTimeStampInfo();		
		ListEditInfo editInfo = anOTEdit.getTransformableListEdit().getListEdit().toListEditInfo();
		OTListEditFlipped.newCase(
				CommunicatorSelector.getProcessName(),
				editInfo,
				otTimeStampInfo,
				aUser,
//				isServer,
				aFinder);
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anotreceivedmessagefiltercreator.java
package im.ot;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;

public class AnOTReceivedMessageFilterCreator  implements MessageFilterCreator<ReceivedMessage>{
	MessageFilter<ReceivedMessage> receivedMessageQueuer;
	OTManager otManager;
	public AnOTReceivedMessageFilterCreator(OTManager theOTManager) {
		otManager = theOTManager;
		receivedMessageQueuer =  new AnOTReceivedMessageFilter(otManager);
	}
	@Override
	public MessageFilter<ReceivedMessage> getMessageFilter() {
		return receivedMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anotreceivedservermessagefilter.java
package im.ot;

import im.ListEdit;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import util.misc.Common;
import util.session.ASentMessage;
import util.session.MessageProcessor;
import util.session.SentMessage;
import util.session.SentMessageType;
import util.session.ServerMessageFilter;
import util.trace.Tracer;
// A multicaster sender that puts the message in multiple queues, one for each client
// Each queue is a separate OT Manager

public class AnOTReceivedServerMessageFilter implements ServerMessageFilter {
	Map<String, OTManager> clientToOTManager = new HashMap();
	MessageProcessor<SentMessage> sentMessageQueue;

	@Override
	public synchronized void userJoined(String aSessionName, String anApplicationName, String userName) {
		OTManager otManager = new AnOTManager(aSessionName, userName, true);
		clientToOTManager.put(userName, otManager);
		// otManager.setSentMessageQueue(sentMessageQueue);

	}

	@Override
	public void userLeft(String aSessionName, String anApplicationName, String userName) {
		// TODO Auto-generated method stub

	}

	/*
	 * message sent by user u is a message received by all users, U, other than
	 * u. so it must be treated as a received message by server representing U
	 * -u transform this message with respect to all messages sent to u by the
	 * server representing itself as U - u. these messages are stored in u's ot
	 * Manager. send transformed message to U - u. store this message, with
	 * appropriate time stamp, as sent message in otManagers of U - u each ot
	 * Manager will time stamp differently this means message must be unicast
	 */

	@Override
	public synchronized void filterMessage(SentMessage message) {
		if (!message.isUserMessage()
				|| message.getSentMessageType() != SentMessageType.Others) {
			sentMessageQueue.processMessage(message);
			return;
		}
		Tracer.info(this, "START PUT in OTSERVER QUEUE");
		ListEditWithOTTimeStamp receivedEditWithOTTimeStamp = (ListEditWithOTTimeStamp) message
				.getUserMessage();
		OTManager sentOTManager = clientToOTManager.get(message
				.getSendingUser());
		Tracer.info(this, "OT Manager:" + message.getSendingUser());
		receivedEditWithOTTimeStamp.getOTTimeStamp().flip(); // our OT function compares local with local now
		AnOTReceivedMessageFilter.traceOTEditFlip(receivedEditWithOTTimeStamp, message.getSendingUser(), false , this);
		// transform message with respect to all messages sent to u by the
		// server representing itself as U - u
		sentOTManager.processTimeStampedEdit(receivedEditWithOTTimeStamp,
				message.getSendingUser(), false);
		// this will be the edit sent to U - u
		ListEdit sentEdit = receivedEditWithOTTimeStamp
				.getTransformableListEdit().getListEdit();
		// iterate thru U - u and ot Managers of U - u.
		Set<String> allUsers = clientToOTManager.keySet();
		Tracer.info(this, "All Users n OTSERVER QUEUE:" + allUsers);
		for (String user : allUsers) {
			if (user.equals(message.getSendingUser()))
				continue;
			OTManager receivingOTManager = clientToOTManager.get(user);
			// transform the headers in the message which will include
			// transformed edit
			SentMessage unicastMessage = ASentMessage.toSpecificUser(message,
					user); // move to communicator? 
			// this is the server's sent edit to each U - u
			// Edit clonedEdit = (Edit) Misc.deepCopy(sentEdit);
			// sent edit does not have to be cloned in the sentMessage output
			// buffer
			Tracer.info(this, "OT Manager:" + user);
			ListEditWithOTTimeStamp sentListEditWithOTTimeStamp = receivingOTManager
					.processSentEdit(sentEdit); // the raw edit has to be time stamped by  receiving ot manager, it should increment local count
			// create a different copy for sent buffer with original time stamp, why different it should have this time stamp, it is as if the server is send
//			SentMessage clonedUnicastMessage = (SentMessage) Common
//					.deepCopy(unicastMessage);
			OTTimeStamp otTimeStamp = sentListEditWithOTTimeStamp
					.getOTTimeStamp();
			// sentListEditWithOTTimeStamp.getOTTimeStamp().flip();			
			// receiver is flipping, so sender does not have to

			unicastMessage.setUserMessage(sentListEditWithOTTimeStamp); //
			Tracer.info(this, "Unicasting message to: " + user);
			sentMessageQueue.processMessage(unicastMessage);
			// store a different copy in the buffer
			// SentMessage clonedUnicastMessage = (SentMessage)
			// Common.deepCopy(unicastMessage);
			// Message.info("OT Manager:" + user);
			
			// create a different copy for sent buffer with time stamp created by receiving OT manager
			SentMessage clonedUnicastMessage = (SentMessage) Common
					.deepCopy(unicastMessage);
			receivingOTManager.storeSentMessage(clonedUnicastMessage); // why not put this in ot manager or make all of this part of ot manager?
			// otManager.put(receivedMessage);
		}
		Tracer.info(this, "END PUT in OTSERVER QUEUE");
	}

	@Override
	public void setMessageProcessor(
			MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageQueue = theMesssageProcessor;

	}

}
//END OF FILE
//START OF FILE: src/im/ot/anotsentmessagefilter.java
package im.ot;

import im.ListEdit;
import trace.echo.modular.ListEditInfo;
import trace.ot.OTTimeStampInfo;
import trace.ot.OTTimeStampedListEditInfo;
import trace.ot.OTListEditReceived;
import trace.ot.OTListEditSent;
import util.misc.Common;
import util.session.CommunicatorSelector;
import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.SentMessage;
import util.session.SentMessageType;
import util.trace.session.MessageCopied;

public class AnOTSentMessageFilter implements MessageFilter<SentMessage> {
	OTManager otManager;
	MessageProcessor<SentMessage> sentMessageProcessor;
	public AnOTSentMessageFilter(OTManager theCausalityManager) {
		otManager = theCausalityManager;
	}

	@Override
	public synchronized void filterMessage(SentMessage message) {
		if (!message.isUserMessage() || message.getSentMessageType() != SentMessageType.Others) {
			sentMessageProcessor.processMessage(message);
			return;
		}
		ListEdit edit = (ListEdit) message.getUserMessage();
		ListEditWithOTTimeStamp timeStampedEdit = timeStamp(edit);
		message.setUserMessage(timeStampedEdit);
		sentMessageProcessor.processMessage(message);
		AnOTManager.traceOTEditSent(timeStampedEdit, otManager);
//
//		SentMessage messageClone = (SentMessage) Common.deepCopy(message); // time stamp copied earlier, now message embedding it
//		MessageCopied.newCase(
//				CommunicatorSelector.getProcessName(), 
//				messageClone.getUserMessage(), 
//				otManager.getUserName(), 
//				this);
//		otManager.storeSentMessage(messageClone); // cloning was done for storing message
		storeClone(message);
	}
	
	ListEditWithOTTimeStamp timeStamp(ListEdit edit) {
		return otManager.processSentEdit(edit);//create time stamped edit
	}
	void storeClone(Object message) {
		SentMessage messageClone = (SentMessage) Common.deepCopy(message); // time stamp copied earlier, now message embedding it
		MessageCopied.newCase(
				CommunicatorSelector.getProcessName(), 
				messageClone.getUserMessage(), 
				otManager.getUserName(), 
				this);
		otManager.storeSentMessage(messageClone); // cloning was done for storing message
	
	}
	
	

	@Override
	public void setMessageProcessor(MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageProcessor = theMesssageProcessor;		
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anotsentmessagefiltercreator.java
package im.ot;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.SentMessage;

public class AnOTSentMessageFilterCreator  implements MessageFilterCreator<SentMessage>{
	MessageFilter<SentMessage> sentMessageQueuer;
	OTManager otManager;
	public AnOTSentMessageFilterCreator(OTManager theOTManager) {
		otManager = theOTManager;
		sentMessageQueuer =  new AnOTSentMessageFilter(otManager);
	}
	@Override
	public MessageFilter<SentMessage> getMessageFilter() {
		return sentMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anotservermessagefiltercreator.java
package im.ot;

import util.session.ServerMessageFilter;
import util.session.ServerMessageFilterCreator;

public class AnOTServerMessageFilterCreator  implements ServerMessageFilterCreator{
	ServerMessageFilter  serverMessageQueuer = new AnOTReceivedServerMessageFilter();
	@Override
	public ServerMessageFilter getMessageQueuer() {
		return new AnOTReceivedServerMessageFilter();
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anottimestamp.java
package im.ot;

import trace.ot.OTTimeStampInfo;
import util.trace.Tracer;

public class AnOTTimeStamp implements OTTimeStamp {
	int localCount;
	int remoteCount;
	public AnOTTimeStamp(int theLocalCount, int theRemoteCount) {
		localCount = theLocalCount;
		remoteCount = theRemoteCount;
	}
	public AnOTTimeStamp() {
		
	}
	public  int getLocalCount() {
		return localCount;
	}
	
	public void setLocalCount(int newVal) {
		localCount = newVal;
	}	
	public  int getRemoteCount() {
		return remoteCount;
	}	
	public void setRemoteCount(int newVal) {
		remoteCount = newVal;
	}
	public boolean isConcurrent(OTTimeStamp other) {
		Tracer.info(this, " comparing: " + this + " with:" + other);
		return !isGreaterThanOrEqual(other) && !other.isGreaterThanOrEqual(this);

	}
	public boolean isGreaterThanOrEqual(OTTimeStamp other) {
		Tracer.info(this, " comparing: " + this + " with:" + other);
//		return getLocalCount() >= other.getRemoteCount() &&
//				getRemoteCount() >= other.getLocalCount();
		return getLocalCount() >= other.getLocalCount() &&
				getRemoteCount() >= other.getRemoteCount();
	}
	public void incrementLocalCount() {
		localCount++;
	}
	
	public void incrementRemoteCount() {
		remoteCount++;
	}
	public String toString() {
//		return "local:" + localCount + " remote:" + remoteCount;
		return  "Counts(" + "L(" + localCount + "), R" + remoteCount + "))";

	}
	public OTTimeStamp copy() {
		return new AnOTTimeStamp(localCount, remoteCount);
	}
	@Override
	public void flip() {
		int temp = localCount;
		localCount = remoteCount;
		remoteCount = temp;		
	}
	@Override
	public OTTimeStampInfo toOTTimeStampInfo() {
		return new OTTimeStampInfo(localCount, remoteCount);
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anoperationtranformercreator.java
package im.ot;

public class AnOperationTranformerCreator implements OperationTransformerCreator{

	@Override
	public OperationTransformer getOperationTransformer() {		
		return new AnOperationTransformer();
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anoperationtransfomerselector.java
package im.ot;

public class AnOperationTransfomerSelector {
	static OperationTransformerCreator factory = new AnOperationTranformerCreator();
	public static OperationTransformerCreator getOperationTransformerCreator() {
		return factory;
	}
	public static void setOperationTransformerCreator(OperationTransformerCreator newVal) {
		factory = newVal;
	}
	public static OperationTransformer getOperationTransformer() {
		return factory.getOperationTransformer();
	}

}
//END OF FILE
//START OF FILE: src/im/ot/anoperationtransformer.java
package im.ot;

import im.AListEdit;
import im.ListEdit;

public class AnOperationTransformer implements OperationTransformer {
	public ListEdit transform (TransformableListEdit transformed, TransformableListEdit other) {
		//Message.info("original:" +  transformed + ", other: " + other);
		int transformedIndex = transformed.getListEdit().getIndex();
//		char ch;
		if (transformedIndex > other.getListEdit().getIndex())
			transformedIndex++;
		else if (transformedIndex == other.getListEdit().getIndex()) {
//			if (transformed.getEdit().getChar() == other.getEdit().getChar())
//				return null;
			if (!transformed.isServer())
				transformedIndex++;
		}
		ListEdit retVal = new AListEdit(transformed.getListEdit().getOperationName(), 
				transformedIndex, transformed.getListEdit().getElement());
		//Message.info("transformed:" +  retVal + ", other: " + other);
		return retVal;
	}
}
//END OF FILE
//START OF FILE: src/im/ot/bobotim.java
package im.ot;
import im.IMComposerAndLauncher;
import im.causal.BobCausalIM;
import trace.ot.OTIMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.OT, ApplicationTags.IM, DistributedTags.CLIENT, DistributedTags.CLIENT_2})
public class BobOTIM extends BobCausalIM {
	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
//		OTIMTracerSetter.setOTPrintStatus();
		OTIMTracerSetter.traceOTIM();

//		SessionTracerSetter.setSessionPrintStatus();


//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, true);

		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, APPLICATION_NAME,
				Communicator.RELAYED};
		IMComposerAndLauncher composerAndLauncher = (new AnOTIMComposerAndLauncher());
		composerAndLauncher.composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/ot/cathyotim.java
package im.ot;
import im.IMComposerAndLauncher;
import im.causal.CathyCausalIM;
import trace.ot.OTIMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.ApplicationTags;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.OT, ApplicationTags.IM, DistributedTags.CLIENT, DistributedTags.CLIENT_3})
public class CathyOTIM extends CathyCausalIM {
	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
//		OTIMTracerSetter.setOTPrintStatus();
		OTIMTracerSetter.traceOTIM();

//		SessionTracerSetter.setSessionPrintStatus();
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, true);

//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, IMComposerAndLauncher.RELAYED};
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME, IMComposerAndLauncher.RELAYED};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, APPLICATION_NAME,
				Communicator.RELAYED};
		IMComposerAndLauncher composerAndLauncher = (new AnOTIMComposerAndLauncher());
		composerAndLauncher.composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/ot/demoerofotim.java
package im.ot;

import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfOTIM {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				OTSessionManagerServerStarter.class,
				AliceOTIM.class,
				BobOTIM.class,
				CathyOTIM.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/im/ot/launcherofotcorrectloggenerator.java
package im.ot;

import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;

public class LauncherOfOTCorrectLogGenerator extends LauncherOfOTDemoer {
	public static void main(String args[]) {
//		ConsoleTraceSetter.traceConsole();	
		DemoerAndTester aDemoer = createDemoer(false);
		// correct transcripts
//		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
		// test transcripts
		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/im/ot/launcherofotdemoer.java
package im.ot;

import im.LauncherOfIMTester;
import echo.modular.LauncherOfModularEchoTester;
import trace.echo.modular.ModularEchoTraceChecker;
import bus.uigen.models.DemoerAndTester;
import bus.uigen.models.MainClassListLauncher;

public class LauncherOfOTDemoer extends LauncherOfIMTester{
	public static DemoerAndTester createDemoer(boolean anInteractive) {
		return new AnOTDemoerAndTester();
	}
	public static void main(String args[]) {
		DemoerAndTester demoer = createDemoer(true);
		MainClassListLauncher aLauncher = demoer.createAndDisplayLauncher();
//		demoer.generateCorrectTranscripts();
		demoer.executeAll();
//		demoer.loadTraceables(null);
//		aLauncher.executeAll();
		
		
//		MainClassListLauncher aLauncher = demo();
//		animatingTest(aLauncher);
	}

}
//END OF FILE
//START OF FILE: src/im/ot/launcherofottester.java
package im.ot;

import util.trace.console.ConsoleTraceSetter;
import bus.uigen.models.DemoerAndTester;

public class LauncherOfOTTester extends LauncherOfOTDemoer {
	public static void main(String args[]) {
//		ConsoleTraceSetter.traceConsole();	
		DemoerAndTester aDemoer = createDemoer(false);
		// correct transcripts
//		Boolean retVal = aDemoer.executeLoadAndTest(true, false);
		// test transcripts
		Boolean retVal = aDemoer.executeLoadAndTest(false, true);

		System.out.println("Test result:" + retVal);
		aDemoer.terminate();
	}

}
//END OF FILE
//START OF FILE: src/im/ot/listeditwithottimestamp.java
package im.ot;

import java.io.Serializable;

import trace.ot.OTTimeStampedListEditInfo;


public interface ListEditWithOTTimeStamp extends Serializable{

	public abstract TransformableListEdit getTransformableListEdit();

	public abstract void setTransformableListEdit(TransformableListEdit newVal);
	public OTTimeStamp getOTTimeStamp() ;
	public void setOTTimeStamp(OTTimeStamp otTimeStamp) ;

	OTTimeStampedListEditInfo toOTTimeStampedListEditInfo();

	

}
//END OF FILE
//START OF FILE: src/im/ot/otmanager.java
package im.ot;

import im.ListEdit;
import util.session.SentMessage;
// Duplex connection between client and server
public interface OTManager {
	public void processTimeStampedEdit(ListEditWithOTTimeStamp receivedTSEdit, String aFromUser, boolean isServer);
	public ListEditWithOTTimeStamp processSentEdit(ListEdit edit );
	public void storeSentMessage(SentMessage message);
	String getUserName();
	boolean isServer();
	String getLocation();
}
//END OF FILE
//START OF FILE: src/im/ot/otsessionmanagerserverstarter.java
package im.ot;
import trace.im.IMTracerSetter;
import trace.ot.OTIMTracerSetter;
import util.annotations.Tags;
import util.session.ServerSentMessageFilterSelector;
import util.session.ASessionManager;
import util.session.ASessionManagerSelector;
import util.session.ServerMessageFilterCreator;
import util.session.SessionManager;
import util.tags.DistributedTags;
import util.trace.ImplicitKeywordKind;
import util.trace.MessagePrefixKind;
import util.trace.Tracer;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;
@Tags({DistributedTags.OT, DistributedTags.SERVER, DistributedTags.SESSION_MANAGER})
public class OTSessionManagerServerStarter {
	static ASessionManager server;
	public static void main (String[] args) {
		Tracer.showInfo(true);
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, true);
		OTIMTracerSetter.setOTPrintStatus();
		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
//		Tracer.setKeywordPrintStatus(ServerClientJoined.class, true);
//		Tracer.showInfo(true);
//		IMTracerSetter.traceIM();
		Tracer.setKeywordPrintStatus(ServerClientJoined.class, true);
//		SessionTracerSetter.setSessionPrintStatus();
		ServerMessageFilterCreator serverMessageQueueCreator = new AnOTServerMessageFilterCreator();
		ServerSentMessageFilterSelector.setMessageFilterFactory(serverMessageQueueCreator);
//		server = new ASessionManager();	
		server =  ASessionManagerSelector.getSessionManager();

		server.register();
	}
}
//END OF FILE
//START OF FILE: src/im/ot/ottimestamp.java
package im.ot;

import java.io.Serializable;

import trace.ot.OTTimeStampInfo;

public interface OTTimeStamp extends Serializable {
   public abstract int getLocalCount();	
	public void setLocalCount(int newVal);	
	public abstract int getRemoteCount();	
	public void setRemoteCount(int newVal);	
	public boolean isConcurrent(OTTimeStamp other);
	public boolean isGreaterThanOrEqual(OTTimeStamp other);	
	public void incrementLocalCount();	
	public void incrementRemoteCount();
	public OTTimeStamp copy();
	public void flip();
	OTTimeStampInfo toOTTimeStampInfo();
}
//END OF FILE
//START OF FILE: src/im/ot/operationtransformer.java
package im.ot;

import im.ListEdit;

public interface OperationTransformer {
	public ListEdit transform (TransformableListEdit transformed, TransformableListEdit other);

}
//END OF FILE
//START OF FILE: src/im/ot/operationtransformercreator.java
package im.ot;

public interface OperationTransformerCreator {
	public OperationTransformer getOperationTransformer();
}
//END OF FILE
//START OF FILE: src/im/ot/referencedobject.java
package im.ot;

public interface ReferencedObject<ObjectType> {
	public ObjectType getObject();
	public int getReferenceCount();
	public void incrementReferenceCount();
	public void decrementReferenceCount();	

}
//END OF FILE
//START OF FILE: src/im/ot/transformablelistedit.java
package im.ot;

import im.ListEdit;

import java.io.Serializable;

public interface TransformableListEdit extends Serializable{
	public abstract ListEdit getListEdit();

	public abstract void setListEdit(ListEdit newVal);

	public abstract boolean isServer();

	public abstract void setServer(boolean isServer);
	
	public TransformableListEdit copy();

}
//END OF FILE
//START OF FILE: src/im/timestamp/acathytimestampedim.java
package im.timestamp;

import sasa.echoerAndIM.AnIMComposerAndLauncher;

public class ACathyTimeStampedIM {
	public static final String SESSION_NAME = "FrostySession";
	public static final String USER_NAME = "Cathy";
	public static final String SESSION_SERVER_HOST = "localhost";
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, AnIMComposerAndLauncher.DIRECT};
		(new ATimeStampingIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/timestamp/adetimestampingreceivedmessagefilter.java
package im.timestamp;

import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.ReceivedMessage;
// converts  simplex receiver  multicaster abstraction to duplex causal manager
public class ADeTimeStampingReceivedMessageFilter implements MessageFilter<ReceivedMessage> {
	MessageProcessor<ReceivedMessage> receivedMessageProcessor;
	@Override
	// called by communicator when a new message is submitted by client
	// unwrap time stamped message and submit it to the next input stage inwards
	public void filterMessage(ReceivedMessage aReceivedMessage) {
		if (aReceivedMessage.isUserMessage()) {
			MessageWithTimeStamp aTimeStampedMessage = (MessageWithTimeStamp) aReceivedMessage
					.getUserMessage();
			displayApproximateMessageDelay(aTimeStampedMessage);
			aReceivedMessage.setUserMessage(aTimeStampedMessage.getMessage());
		}
		receivedMessageProcessor.processMessage(aReceivedMessage);		
	}
	
	void displayApproximateMessageDelay(MessageWithTimeStamp aTimeStampedMessage) {
		Object message = aTimeStampedMessage.getMessage();
		long timeStamp = aTimeStampedMessage.geTimeStamp();
		System.out.println("Received message:" + message
				+ " with approximate delay:"
				+ (System.currentTimeMillis() - timeStamp));
		
	}

	@Override
	// downstream node in the receive pipeline
	public void setMessageProcessor(MessageProcessor<ReceivedMessage> theMesssageProcessor) {
		receivedMessageProcessor = theMesssageProcessor;
	}
}
//END OF FILE
//START OF FILE: src/im/timestamp/adetimestampingreceivedmessagefiltercreator.java
package im.timestamp;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;

public class ADeTimeStampingReceivedMessageFilterCreator  implements MessageFilterCreator<ReceivedMessage>{
	MessageFilter<ReceivedMessage> receivedMessageQueuer;

	public ADeTimeStampingReceivedMessageFilterCreator() {
		receivedMessageQueuer =  new ADeTimeStampingReceivedMessageFilter();
	}
	@Override
	public MessageFilter<ReceivedMessage> getMessageFilter() {
		return receivedMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/timestamp/amessagewithtimestamp.java
package im.timestamp;

import util.trace.Tracer;

public class AMessageWithTimeStamp implements MessageWithTimeStamp {
	Object message;
	long timeStamp;
	public AMessageWithTimeStamp (Object theMessage, long theTimeStamp) {
		message = theMessage;
		timeStamp = theTimeStamp;
		Tracer.info(this, "New  Time Stamp:" + theTimeStamp);
	}
	
	public Object getMessage() {
		return message;
	}
	
	public long geTimeStamp() {
		return timeStamp;
	}

	
	

}
//END OF FILE
//START OF FILE: src/im/timestamp/atimestampingimcomposerandlauncher.java
package im.timestamp;

import im.AnIMComposerAndLauncher;
import util.session.ReceivedMessageFilterSelector;
import util.session.SentMessageFilterSelector;
import util.session.Communicator;
import util.session.MessageFilterCreator;
import util.session.ReceivedMessage;
import util.session.SentMessage;

public class ATimeStampingIMComposerAndLauncher extends
		AnIMComposerAndLauncher {

	public Communicator createCommunicator(String args[], String applicationName) {
		// set factories used to create communicator
		MessageFilterCreator<ReceivedMessage> receivedMessageQueuerCreator = new ADeTimeStampingReceivedMessageFilterCreator();
		MessageFilterCreator<SentMessage> sentMessageQueuerCreator = new ATimeStampingSentMessageFilterCreator();
		ReceivedMessageFilterSelector
				.setMessageFilterFactory(receivedMessageQueuerCreator);
		SentMessageFilterSelector
				.setMessageFilterCreator(sentMessageQueuerCreator);
		// create communicator
		return super.createCommunicator(args);
	}
}
//END OF FILE
//START OF FILE: src/im/timestamp/atimestampingsentmessagefilter.java
package im.timestamp;

import util.session.MessageFilter;
import util.session.MessageProcessor;
import util.session.SentMessage;
//converts  simplex sending  multicaster abstraction to duplex causal manager
// is this really a queuer? It is a filter! Rename util at some point
public class ATimeStampingSentMessageFilter implements MessageFilter<SentMessage> {
	MessageProcessor<SentMessage> sentMessageProcessor;
	@Override
	// downstream node in the send pipline
	public void setMessageProcessor(MessageProcessor<SentMessage> theMesssageProcessor) {
		sentMessageProcessor = theMesssageProcessor;
	}
	@Override
	// called by communicator when a new message is submitted by client
	// time stamp message and send it to the next stage outwards
	public void filterMessage(SentMessage aSentMessage) {
		Object userMessage = aSentMessage.getUserMessage();
		aSentMessage.setUserMessage(
				new AMessageWithTimeStamp(
						userMessage, System.currentTimeMillis()));
		sentMessageProcessor.processMessage(aSentMessage);			
	}


}
//END OF FILE
//START OF FILE: src/im/timestamp/atimestampingsentmessagefiltercreator.java
package im.timestamp;

import util.session.MessageFilter;
import util.session.MessageFilterCreator;
import util.session.SentMessage;

public class ATimeStampingSentMessageFilterCreator  implements MessageFilterCreator<SentMessage>{
	MessageFilter<SentMessage> sentMessageQueuer;
	public ATimeStampingSentMessageFilterCreator() {
		sentMessageQueuer =  new ATimeStampingSentMessageFilter();
	}
	@Override
	public MessageFilter<SentMessage> getMessageFilter() {
		return sentMessageQueuer;
	}

}
//END OF FILE
//START OF FILE: src/im/timestamp/analicetimestampedim.java
package im.timestamp;

import sasa.echoerAndIM.AnIMComposerAndLauncher;

public class AnAliceTimeStampedIM {
	public static final String SESSION_NAME = "FrostySession";
	public static final String USER_NAME = "Alice";
	public static final String SESSION_SERVER_HOST = "localhost";
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, AnIMComposerAndLauncher.DIRECT};
		(new ATimeStampingIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/timestamp/bobtimestampedim.java
package im.timestamp;

import im.BobIM;
import sasa.echoerAndIM.AnIMComposerAndLauncher;

public class BobTimeStampedIM extends BobIM {
//	public static final String SESSION_NAME = "FrostySession";
//	public static final String USER_NAME = "Bob";
//	public static final String SESSION_SERVER_HOST = "localhost";
	public static void main (String[] args) {
//		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, AnIMComposerAndLauncher.DIRECT};
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME,  USER_NAME, APPLICATION_NAME};

		(new ATimeStampingIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/im/timestamp/messagewithtimestamp.java
package im.timestamp;

import java.io.Serializable;

public interface MessageWithTimeStamp extends Serializable {

	public abstract Object getMessage();

	public abstract long geTimeStamp();

}
//END OF FILE
//START OF FILE: src/old/echoerandim/acontroldispatcher.java
package old.echoerAndIM;
import java.util.ArrayList;
import java.util.List;

import util.session.Communicator;

public class AControlDispatcher extends AnOutCoupledEchoer implements ControlDispatcher {	
	List<Vetoer> vetoers = new ArrayList();
	public AControlDispatcher(Communicator theCommunicator) {
		super(theCommunicator);		
	}
	void processInput(String theNextInput) {
		if (vetoed(theNextInput))
			return;
		 super.processInput(theNextInput);
	}	
	public void addVetoer(Vetoer theVetoer) {
		vetoers.add(theVetoer);		
	}
	public void removeVetoer(Vetoer theVetoer) {
		vetoers.remove(theVetoer);		
	}
	boolean vetoed(String theValue) {
		for (Vetoer vetoer:vetoers) {
			if (vetoer.veto(theValue)) return true;
		}
		return false;
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/acontrolledinputcommunicator.java
package old.echoerAndIM;
import java.util.ArrayList;
import java.util.List;

import util.session.Communicator;

public class AControlledInputCommunicator extends AnInputCommunicator implements ControlledInputCommunicator {	
	List<Vetoer> vetoers = new ArrayList();
	public AControlledInputCommunicator(Communicator theCommunicator) {
		super(theCommunicator);		
	}
	void processInput(String theNextInput) {
		if (vetoed(theNextInput))
			return;
		 super.processInput(theNextInput);
	}	
	public void addVetoer(Vetoer theVetoer) {
		vetoers.add(theVetoer);		
	}
	public void removeVetoer(Vetoer theVetoer) {
		vetoers.remove(theVetoer);		
	}
	boolean vetoed(String theValue) {
		for (Vetoer vetoer:vetoers) {
			if (vetoer.veto(theValue)) return true;
		}
		return false;
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/afloorcontrolledinputcommunicatorlancher.java
package old.echoerAndIM;
import util.session.Communicator;
import util.session.ReceivedMessageListener;
import bus.uigen.ObjectEditor;
public class AFloorControlledInputCommunicatorLancher extends AnIMComposerAndLauncher {	
	static String APPLICATION_NAME = "Controlled Input Communicator";
	
	public static void main (String[] args) {
//		if (args.length < 3) {
//			Message.fatalError("Please supply server host name and user name as main argument");			
//		}
//		//MessageSender multicastClient = new AMulticastClient(args);
//		MessageSenderFactory messageSenderFactory = AMessageSenderFactorySelector.getMessageSenderFactory();
//		MessageSender multicastClient = messageSenderFactory.getMessageSender(args[0],args[1],args[2], APPLICATION_NAME);
//		ControlledInputCommunicator inputBroadcaster =  new AControlledInputBroadcaster(multicastClient);
//		FloorController floorController = new AFloorController(multicastClient);
//		ReceivedMessageListener inputReceiver = new AnInputAndFloorControlMessageReceiver(multicastClient, floorController);
//		multicastClient.addReceivedMessageListener(inputReceiver);
//		inputBroadcaster.addVetoer(floorController);
//		ObjectEditor.edit(floorController);
//		inputBroadcaster.doInput();		
		Communicator messageSender = createCommunicator(args, APPLICATION_NAME);		
		ControlledInputCommunicator inputCommunicator =  new AControlledInputCommunicator(messageSender);
		FloorController floorController = new AFloorController(messageSender);
		AccessController accessController = new AnAccessController(messageSender);
		ReceivedMessageListener inputReceiver = new AnInputAndFloorControlMessageReceiver(messageSender, accessController, floorController);
		messageSender.addReceivedMessageListener(inputReceiver);
		messageSender.join();
		inputCommunicator.addVetoer(accessController);
		inputCommunicator.addVetoer(floorController);
		ObjectEditor.edit(floorController);
		ObjectEditor.edit(accessController);
		inputCommunicator.doInput();		
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/afloorcontroller.java
package old.echoerAndIM;

import javax.swing.JOptionPane;

import util.session.Communicator;

public class AFloorController implements FloorController {	
	Communicator messageSender;
	public AFloorController(Communicator theMessageSender) {
		messageSender = theMessageSender;
	}
	String floorHolder;	
	public boolean veto(Object theInput) {		
		boolean retVal = !messageSender.getClientName().equals(floorHolder);
		if (retVal) {
			JOptionPane.showMessageDialog(null, "Must have floor to input.");
		}
		return retVal;
	}	
	public void newFloorHolder(String newVal) {
		floorHolder = newVal;
		if (newVal != null)
			JOptionPane.showMessageDialog(null, floorHolder + " has the floor");
	}	
	public boolean hasFloor() {
		return  messageSender.getClientName().equals(floorHolder);
	}	
	public void getFloor() {
		if (hasFloor()) return;
		messageSender.toAll(new AGetFloorMessage(messageSender.getClientName()));		
	}	
//	public void releaseFloor() {
//		if (hasFloor())
//			messageSender.toAll(new AReleaseFloorMessage(messageSender.getClientName()));		
//	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/agetfloormessage.java
package old.echoerAndIM;
public class AGetFloorMessage extends AMessage<String> {
	public AGetFloorMessage (String theClientName) {
		//super(MessageType.GET_FLOOR, theClientName);
		super(theClientName);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/amessage.java
package old.echoerAndIM;

import java.io.Serializable;

public class AMessage<DataType> implements Serializable, Message<DataType>{
	DataType messageData;
	public AMessage(DataType theData) {
		messageData = theData;
	}
	public DataType getData() {
		return messageData;
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/areleasefloormessage.java
package old.echoerAndIM;
public class AReleaseFloorMessage extends AMessage<String> {
	public AReleaseFloorMessage (String theClientName) {
		super(theClientName);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aremoteinput.java
package old.echoerAndIM;
public class ARemoteInput extends AMessage<String> {
	public ARemoteInput (String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/asessionawarenessprovider.java
package old.echoerAndIM;
import java.util.Collection;

import javax.swing.JOptionPane;

import util.session.SessionMessageListener;
public class ASessionAwarenessProvider implements SessionMessageListener{	
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		String newOrOldSession = newSession?" new ":"";
		String newOrOldApplication = newApplication?" new ":"";
		String message = "User: " + userName + 
				" joined " + newOrOldApplication + " application: " + theApplicationName +
				" in " + newOrOldSession + " session: " + theSessionName +
				getOtherUserNames(allUsers, userName);
		JOptionPane.showMessageDialog(null, message);
	}
	String getOtherUserNames(Collection<String> allUsers, String myName) {		
		if (allUsers.size() == 1)
			return "";
		String retVal = " with other users:";	
		for (String userName:allUsers) {
			if (userName.equals(myName)) continue;
			retVal += " " + userName;			
		}
		return retVal;
	}	
	public void clientLeft(String userName, String theApplicationName) {
		String message = "User left session:" + userName;
		JOptionPane.showMessageDialog(null, message);
	}
//	public void objectReceived(Object message, String userName) {					
//	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/accesscontroller.java
package old.echoerAndIM;


public interface AccessController  extends Vetoer{	
	boolean canInput(String theUser) ;
	boolean canAdminister(String theUser);
	void addAdministrator(String newAdminsitrator) ;
	void addInputter(String newInputter) ;
	void addAdministratorLocal(String newAdminsitrator) ;
	void addInputterLocal(String newInputter) ;
	void setOwner(String theOwner);		
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anaccesscontrolledimcomposerandlauncher.java
package old.echoerAndIM;

import util.session.Communicator;
import util.session.ReceivedMessageListener;
import bus.uigen.ObjectEditor;

public class AnAccessControlledIMComposerAndLauncher extends AnIMComposerAndLauncher {	
	static String APPLICATION_NAME = "Access Controlled IM";	
	public static void main (String[] args) {
		Communicator communicator = createCommunicator(args, APPLICATION_NAME);		
		ControlDispatcher controlDispatcher =  new AControlDispatcher(communicator);
		addAwarenessAndInCoupler(communicator, controlDispatcher);
		AccessController accessController = new AnAccessController(communicator);		
		ReceivedMessageListener accessReceiver = new AnAccessReceiver(communicator, accessController);
		communicator.addReceivedMessageListener(accessReceiver);
		controlDispatcher.addVetoer(accessController);
		communicator.join();
		ObjectEditor.edit(accessController);
		controlDispatcher.doInput();		
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anaccesscontroller.java
package old.echoerAndIM;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JOptionPane;

import util.session.Communicator;
public class AnAccessController implements AccessController {	
	Communicator communicator;
	List<String> inputers = new ArrayList();
	List<String> administrators = new ArrayList();	
	String owner;
	public AnAccessController(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	public boolean hasOwnership(String theUser) {
		return theUser.equals(owner);
	}
	public void setOwner(String theOwner) {
		JOptionPane.showMessageDialog(null, theOwner + " is the owner");
		owner = theOwner;
	}
	public boolean canInput(String theUser) {
		return  inputers.contains(theUser);
	}
	public void addInputterLocal(String newInputer) {
		inputers.add(newInputer);	
		JOptionPane.showMessageDialog(null, newInputer + " can input");
	}
	public void addInputter(String newInputer) {
		if (!canAdminister(communicator.getClientName())) {			
				JOptionPane.showMessageDialog(null, communicator.getClientName() +
						" does not have authorization to administer");	
		return;
			
		}
		communicator.toAll(new AnInputAuthorization(newInputer));
	}
	public boolean canAdminister(String theUser) {
		return  administrators.contains(theUser);
	}
	public void addAdministratorLocal(String newAdminsitrator) {
		administrators.add(newAdminsitrator);
		JOptionPane.showMessageDialog(null, newAdminsitrator + " can administer");
	}	
	public void addAdministrator(String newAdminsitrator) {	
		if (!hasOwnership(communicator.getClientName())) {			
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" is not owner");	
	        return;		
	    }
		communicator.toAll(new AnAdministratorAuthorization(newAdminsitrator));
	}	
	public boolean veto(Object theInput) {		
		boolean retVal = !canInput (communicator.getClientName());
		if (retVal) {
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" does not have authorization to input");
		}
		return retVal;
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anaccessreceiver.java
package old.echoerAndIM;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnAccessReceiver implements ReceivedMessageListener{
	Communicator communicator;
	AccessController accessController;
	public AnAccessReceiver(Communicator theCommunicator, 
			AccessController theAccessController) {
		communicator = theCommunicator;
		accessController = theAccessController;
	}
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		if (newApplication) {
			accessController.setOwner(userName);
			accessController.addAdministratorLocal(userName);
			accessController.addInputterLocal(userName);
		}		
	}
	public void objectReceived(Object message, String sourceName) {
		if (message instanceof AnInputAuthorization )
			processInputAuthorization((Message<String>) message);
		else if (message instanceof AnAdministratorAuthorization) 
			processAdminAuthorization((Message<String>) message);				
	}	
	void processInputAuthorization(Message<String> message) {
		accessController.addInputterLocal(message.getData());
	}
	void processAdminAuthorization(Message<String> message) {
		accessController.addAdministratorLocal(message.getData());
	}
	
	public void clientLeft(String userName, String theApplicationName) {
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anadministratorauthorization.java
package old.echoerAndIM;
public class AnAdministratorAuthorization extends AMessage<String> {
	public AnAdministratorAuthorization (String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anechoer.java
package old.echoerAndIM;

import java.util.ArrayList;
import java.util.List;

import util.misc.Console;

public class AnEchoer implements Echoer {
	static String QUIT = "quit";
	static String HISTORY = "history";
	List<String> history = new ArrayList();	
	public void doInput() {
		for (;;) {
			System.out.println("Please enter an input line or " +
				     QUIT + " or " + HISTORY);
			String nextInput = Console.readString();
			if (nextInput.equals(QUIT)) { 
				break;
			} else if (nextInput.equals(HISTORY))
				printHistory();
			else
			    processInput(nextInput);			
		}
	}
	void processInput(String theNextInput) {
		System.out.println("Input:" + theNextInput);
		addToHistory(theNextInput);
	}
	public synchronized void addToHistory(String input) {
		history.add(input);
	}
	public synchronized void printHistory() {
		for (String input:history) {
			System.out.print(input + ":");			
		}
		System.out.println();		
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anechoerlauncher.java
package old.echoerAndIM;

public class AnEchoerLauncher {	
	public static void main (String[] args) {
		Echoer echoer = new AnEchoer();
		echoer.doInput();
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/animcomposerandlauncher.java
package old.echoerAndIM;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.PeerMessageListener;
import util.session.SessionMessageListener;
public class AnIMComposerAndLauncher {
	public static final String APPLICATION_NAME = "IM";
	static Communicator communicator;
	public static void main (String[] args) {		
		Communicator communicator = createCommunicator(args, APPLICATION_NAME);
		Echoer outCouplerAndEchoer =  new AnOutCoupledEchoer(communicator);
		addAwarenessAndInCoupler(communicator, outCouplerAndEchoer);
		communicator.join();
		outCouplerAndEchoer.doInput();		
	}
	public static void checkArgs(String[] args) {
		if (args.length < 3) {
			System.out.println("Please supply server host name and user name as main argument");	
			System.exit(-1);
		}		
	}
	public static Communicator createCommunicator(String args[], String applicationName) {
		checkArgs(args);
		CommunicatorCreator communicatorFactory = CommunicatorSelector.getCommunicatorFactory();
		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
	}	
	public static void addAwarenessAndInCoupler(Communicator communicator, Echoer echoerAndLogger) {		
		PeerMessageListener remoteInputEchoer = new AnInCoupler(echoerAndLogger);
		SessionMessageListener sessionAwarenesManager = new ASessionAwarenessProvider();	
		communicator.addPeerMessageListener(remoteInputEchoer);
		communicator.addSessionMessageListener(sessionAwarenesManager);
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anincoupler.java
package old.echoerAndIM;
import util.session.PeerMessageListener;
public class AnInCoupler implements PeerMessageListener{
	Echoer echoer;
	public AnInCoupler(Echoer theEchoer) {
		echoer = theEchoer;		
	}
	public void objectReceived(Object message, String userName) {
		if (message instanceof ARemoteInput)
			processRemoteInput((ARemoteInput) message, userName);				
	}
	void processRemoteInput (ARemoteInput remoteInput, String userName) {
		System.out.println("Remote Input:" + remoteInput.getData() + " from:" + userName);
		echoer.addToHistory(remoteInput.getData());
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputandaccesscontrolmessagereceiver.java
package old.echoerAndIM;
import java.util.Collection;

import util.session.Communicator;
public class AnInputAndAccessControlMessageReceiver extends AnInputReceiver {
	AccessController accessController;
	public AnInputAndAccessControlMessageReceiver(Communicator theMessageSender, 
			AccessController theAccessController) {
		super(theMessageSender);
		accessController = theAccessController;
	}
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		super.clientJoined(userName, theApplicationName, theSessionName, newSession, newApplication, allUsers);
		if (newApplication) {
			accessController.setOwner(userName);
			accessController.addAdministratorLocal(userName);
			accessController.addInputterLocal(userName);
		}
		
	}
	public void objectReceived(Object message, String sourceName) {
		if (message instanceof AnInputAuthorization ) {
			processInputAuthorization((Message<String>) message);
		} else if (message instanceof AnAdministratorAuthorization) {
			processAdminAuthorization((Message<String>) message);
		} else
			super.objectReceived(message, sourceName);
	}
	
	void processInputAuthorization(Message<String> message) {
		accessController.addInputterLocal(message.getData());
	}
	void processAdminAuthorization(Message<String> message) {
		accessController.addAdministratorLocal(message.getData());
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputandfloorcontrolmessagereceiver.java
package old.echoerAndIM;

import java.util.Collection;

import util.session.Communicator;

public class AnInputAndFloorControlMessageReceiver extends AnInputAndAccessControlMessageReceiver {
	FloorController floorController;
	public AnInputAndFloorControlMessageReceiver(Communicator theMessageSender, 
			AccessController theAccessController,
			FloorController theFloorController) {
		super(theMessageSender, theAccessController);
		floorController = theFloorController;
	}
	public void objectReceived(Object message, String sourceName) {
		if (message instanceof AGetFloorMessage ) {
			processGetFloor((Message<String>) message);
		} else if (message instanceof AReleaseFloorMessage) {
			processReleaseFloor((Message<String>) message);
		} else
			super.objectReceived(message, sourceName);
	}
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		//System.out.println("User Joined in Floor receiver");
		super.clientJoined(userName, theApplicationName, theSessionName, newSession, newApplication, allUsers);
		if (newApplication) {
			floorController.getFloor();
		}		
	}
	
	void processGetFloor(Message<String> message) {
		floorController.newFloorHolder(message.getData());
	}
	void processReleaseFloor(Message<String> message) {
		floorController.newFloorHolder(null);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputauthorization.java
package old.echoerAndIM;
public class AnInputAuthorization extends AMessage<String> {
	public AnInputAuthorization (String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputcommunicator.java
package old.echoerAndIM;
import util.session.Communicator;
public class AnInputCommunicator extends AnInputEchoer implements InputCommunicator {
	Communicator messageSender;
	public AnInputCommunicator(Communicator theMessageSender) {
		messageSender = theMessageSender;
	}	
	void processInput(String theNextInput) {
		super.processInput(theNextInput);	
		messageSender.toOthers(new ARemoteInput(theNextInput));
	}	
	public void doInput() {
		super.doInput();
		messageSender.leave();
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputechoer.java
package old.echoerAndIM;
import util.misc.Console;
public class AnInputEchoer implements InputEchoer {
	static String QUIT_COMMAND = "quit";	
	void prompt() {
		System.out.println("Please enter an input line, or " + QUIT_COMMAND + " for leaving the session");
	}
	boolean isQuit(String input) {
		return input.equals(QUIT_COMMAND);
	}
	void processInput(String theNextInput) {
		System.out.println("Input:" + theNextInput);
	}
	public void doInput() {
		for (;;) {
			prompt();
			String nextInput = Console.readString();
			if (isQuit(nextInput)) { 
				break;
			}
			processInput(nextInput);			
		}
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputmessage.java
package old.echoerAndIM;
public class AnInputMessage extends AMessage<String> {
	public AnInputMessage (String theInput) {
		super(theInput);
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/aninputreceiver.java
package old.echoerAndIM;
import java.util.Collection;

import javax.swing.JOptionPane;

import util.session.Communicator;
import util.session.ReceivedMessageListener;
public class AnInputReceiver implements ReceivedMessageListener{
	Communicator communicator;
	public AnInputReceiver(Communicator theCommunicator) {
		communicator = theCommunicator;		
	}
	public void objectReceived(Object message, String userName) {
		if (message instanceof ARemoteInput)
			processRemoteInput((ARemoteInput) message, userName);				
	}
	void processRemoteInput (ARemoteInput remoteInput, String userName) {
		System.out.println("Remote Input:" + remoteInput.getData() + " from:" + userName);
	}
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		String newOrOldSession = newSession?" new ":"";
		String newOrOldApplication = newApplication?" new ":"";
		String message = "User: " + userName + 
				" joined " + newOrOldApplication + " application: " + theApplicationName +
				" in " + newOrOldSession + " session: " + communicator.getSessionName() +
				getOtherUserNames();
		JOptionPane.showMessageDialog(null, message);
	}
	public void clientLeft(String userName, String theApplicationName) {
		String message = "User left session:" + userName;
		JOptionPane.showMessageDialog(null, message);
	}
	String getOtherUserNames() {
		String[] userNames = communicator.getUserNames();
		if (userNames.length == 0)
			return "";
		String retVal = " with other users:";		
		for (int i = 0; i < userNames.length; i++) {
				retVal += " " +  userNames[i];			
		}
		return retVal;	
	}
	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/anoutcoupledechoer.java
package old.echoerAndIM;
import util.session.Communicator;
public class AnOutCoupledEchoer extends AnEchoer  {
	Communicator communicator;
	public AnOutCoupledEchoer(Communicator theCommunicator) {
		communicator = theCommunicator;
	}	
	void processInput(String theNextInput) {
		super.processInput(theNextInput);	
		communicator.toOthers(new ARemoteInput(theNextInput));
	}	
	public void doInput() {
		super.doInput();
		communicator.leave();
	}	
}
//END OF FILE
//START OF FILE: src/old/echoerandim/controldispatcher.java
package old.echoerAndIM;

public interface ControlDispatcher extends Echoer {
	public void addVetoer(Vetoer theVetoer);
	public void removeVetoer(Vetoer theVetoer);
}
//END OF FILE
//START OF FILE: src/old/echoerandim/controlledinputcommunicator.java
package old.echoerAndIM;

public interface ControlledInputCommunicator extends InputCommunicator {
	public void addVetoer(Vetoer theVetoer);
	public void removeVetoer(Vetoer theVetoer);

}
//END OF FILE
//START OF FILE: src/old/echoerandim/controlledinputcommunicatorandlogger.java
package old.echoerAndIM;

public interface ControlledInputCommunicatorAndLogger extends InputCommunicatorAndLogger {
	public void addVetoer(Vetoer theVetoer);
	public void removeVetoer(Vetoer theVetoer);

}
//END OF FILE
//START OF FILE: src/old/echoerandim/echoer.java
package old.echoerAndIM;
public interface Echoer {
	public void doInput();
	public void addToHistory(String input);
	public void printHistory();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/floorcontrolmessage.java
package old.echoerAndIM;
public interface FloorControlMessage {
	public String getClientName();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/floorcontroller.java
package old.echoerAndIM;

public interface FloorController extends Vetoer{
	public void newFloorHolder(String newVal);
	public boolean hasFloor();
	public void getFloor();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/inputcommunicator.java
package old.echoerAndIM;
//import util.multicast.Multicaster;
public interface InputCommunicator extends InputEchoer {
	//public MulticastClient getMulticastClient();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/inputcommunicatorandlogger.java
package old.echoerAndIM;
//import util.multicast.Multicaster;
public interface InputCommunicatorAndLogger extends Echoer {
	//public MulticastClient getMulticastClient();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/inputechoer.java
package old.echoerAndIM;
public interface InputEchoer {
	public void doInput();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/message.java
package old.echoerAndIM;
public interface Message<DataType> {
	public DataType getData();
}
//END OF FILE
//START OF FILE: src/old/echoerandim/messagetype.java
package old.echoerAndIM;

public enum MessageType {
	INPUT,
	GET_FLOOR,
	RELEASE_FLOOR,
	ACCESS_CONTROL
}
//END OF FILE
//START OF FILE: src/old/echoerandim/otsessionmanagerserverstarter.java
package old.echoerAndIM;
import util.session.ASessionManager;
public class OTSessionManagerServerStarter {
	static ASessionManager server;
	public static void main (String[] args) {
		server = new ASessionManager();	
		server.register();
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/sessionmanagerserverstarter.java
package old.echoerAndIM;
import util.session.ASessionManager;
public class SessionManagerServerStarter {
	static ASessionManager server;
	public static void main (String[] args) {
		server = new ASessionManager();	
		server.register();
	}
}
//END OF FILE
//START OF FILE: src/old/echoerandim/vetoer.java
package old.echoerAndIM;

public interface Vetoer<ValueType> {
	boolean veto(ValueType theInput);
}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/alocalmousemotionlistener.java
package old.replicatedWindow;

import util.awt.ADelegateFrame;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;

public class ALocalMouseMotionListener implements EventQueueHandler{
	String telePointerString;
	ATelePointerManager telePointerManager;
	public ALocalMouseMotionListener(String theTelePointerString, 
			ATelePointerManager theTelePointerManager) {
		telePointerString = theTelePointerString;
		telePointerManager = theTelePointerManager;		
	}
	@Override
	public void newEvent(SerializableEvent e) {
		if (e.isMouseMovedEvent()) {
			int frameId = e.getSource();
			ADelegateFrame frame =  ADelegateFrame.getFrame(frameId);
			telePointerManager.put(telePointerString, 
					new ATelePointer(frame, e.getX(), e.getY()));	
		}
		
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/areceivedeventforwarder.java
package old.replicatedWindow;

import java.util.Collection;

import util.awt.ADelegateFrame;
import util.awt.ASerializableEvent;
import util.session.ReceivedMessageListener;

public class AReceivedEventForwarder implements ReceivedMessageListener {
//	MulticastClient multicastClient;
//	public AReceivedEventForwarder(MulticastClient theClient) {
//		multicastClient = theClient;
//		multicastClient.addReceivedMessageListener(this);
//	}
	@Override
	public void objectReceived(Object message, String sourceName) {
		ASerializableEvent event = (ASerializableEvent) message;
		//ADelegateFrame delegateFrame = (ADelegateFrame) event.getSource();
		int frameId = event.getSource();
		ADelegateFrame delegateFrame =  ADelegateFrame.getFrame(frameId);
		delegateFrame.processEvent(event);	
	}

	@Override
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void clientLeft(String userName, String theApplicationName) {
		// TODO Auto-generated method stub
		
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/areceivedtelepointerprocessor.java
package old.replicatedWindow;

import java.util.Collection;

import util.awt.ADelegateFrame;
import util.awt.ASerializableEvent;
import util.session.ReceivedMessageListener;

public class AReceivedTelePointerProcessor implements ReceivedMessageListener {

	ATelePointerManager telePointerManager;
	public AReceivedTelePointerProcessor(ATelePointerManager theTelePointerManager) {
		telePointerManager = theTelePointerManager;
		
	}
	@Override
	public void objectReceived(Object message, String sourceName) {
		if (!(message instanceof ASerializableEvent ))
			return;
		ASerializableEvent event = (ASerializableEvent) message;
		if (!event.isMouseMovedEvent()) return;
		int frameId = event.getSource();
		ADelegateFrame frame =  ADelegateFrame.getFrame(frameId);
		telePointerManager.put(sourceName, new ATelePointer(frame,
				event.getX(), event.getY()));
		
			
	}
	@Override
	public void clientJoined(String userName, String theApplicationName, String theSessionName, boolean newSession, boolean newApplication, Collection<String> allUsers) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void clientLeft(String userName, String theApplicationName) {
		// TODO Auto-generated method stub
		
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/aserializableeventbroadcaster.java
package old.replicatedWindow;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;
import util.session.Communicator;
public class ASerializableEventBroadcaster implements EventQueueHandler {
	Communicator multicastClient;
	public ASerializableEventBroadcaster(Communicator theMulticastClient) {		
		multicastClient = theMulticastClient;		
	}
	public void newEvent(SerializableEvent event) {
		if (event.isKeyEvent()  || event.isMouseEvent() || event.isResizeEvent() ) {			
			multicastClient.toOthers(event);
			return;
		}		
	}
}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/atelepointer.java
package old.replicatedWindow;

import util.awt.ADelegateFrame;

public class ATelePointer implements TelePointer {
	int x, y;
	ADelegateFrame delegateFrame;
	public ATelePointer (ADelegateFrame theDelegateFrame, int theX, int theY) {
		delegateFrame = theDelegateFrame;
		x = theX;
		y = theY;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	public ADelegateFrame getDelegateFrame() {
		return delegateFrame;
	}
	public void setDelegateFrame(ADelegateFrame theDelegateFrame) {
		delegateFrame = theDelegateFrame;
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/atelepointermanager.java
package old.replicatedWindow;

import java.awt.Graphics;
import java.util.HashMap;
import java.util.Map;

import util.awt.ADelegateFrame;
import util.awt.DelegateFramePainter;
public class ATelePointerManager implements DelegateFramePainter   {
	Map<String, TelePointer> telePointers = new HashMap();			
	public void paint (ADelegateFrame theDelegateFrame, Graphics g) {
		for (String clientName:telePointers.keySet()) {
			TelePointer telePointer = telePointers.get(clientName);
			if (telePointer.getDelegateFrame() == theDelegateFrame) {
				if (telePointer == null || clientName == null)
					break;
				g.drawString (clientName, telePointer.getX(), telePointer.getY());				
			}
		}
	}	
	public void put (String clientName, TelePointer telePointer) {
		if (clientName == null) {
			return;
		}
		TelePointer prevTelePointer = telePointers.get(clientName);
		telePointers.put(clientName, telePointer);
		telePointer.getDelegateFrame().repaint();
		if (prevTelePointer != null)
			prevTelePointer.getDelegateFrame().repaint();
	}
	public void remove (String clientName) {
		telePointers.remove(clientName);
	}
 
}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/alicereplicatedwindow.java
package old.replicatedWindow;

public class AliceReplicatedWindow {
	public static void main (String[] args) {
		ReplicatedCharacterDrawer.main(new String[] {"localhost", "repwindow", "alice"});
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/bobreplicatedwindow.java
package old.replicatedWindow;

public class BobReplicatedWindow {
	public static void main (String[] args) {
		ReplicatedCharacterDrawer.main(new String[] {"localhost", "repwindow", "bob"});
	}

}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/replicatedcharacterdrawer.java
package old.replicatedWindow;


import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.ReceivedMessageListener;
import windowApp.CharacterDrawerLauncher;

public class ReplicatedCharacterDrawer {
	static String APPLICATION_NAME = "Character Drawer";
	public static void main (String[] args) {
		//MessageSender multicastClient = new AMulticastClient(args);
		CommunicatorCreator messageSenderFactory = CommunicatorSelector.getCommunicatorFactory();
		Communicator multicaster = messageSenderFactory.getCommunicator(args[0],args[1],args[2], APPLICATION_NAME);
		//ReceivedMessageListener remoteEventReceiver = new AReceivedEventForwarder(multicastClient);
		ReceivedMessageListener remoteEventForwarder = new AReceivedEventForwarder();
		multicaster.addReceivedMessageListener(remoteEventForwarder);
		ATelePointerManager telePointerManager = new ATelePointerManager();
		ReceivedMessageListener receivedTelePointerProcessor = new AReceivedTelePointerProcessor(telePointerManager);
		multicaster.addReceivedMessageListener(receivedTelePointerProcessor);
		//ADelegateEventQueue.getDelegateEventQueue().addEventQueueHandler(new ALocalEventForwarder());
		AnInputQueue.getEventQueue().addEventQueueHandler(new ASerializableEventBroadcaster(multicaster));
	
		AnInputQueue.getEventQueue().addEventQueueHandler(new ALocalMouseMotionListener(multicaster.getClientName(), telePointerManager ));
		//AMouseTracker mouseTracker = new AMouseTracker(telePointerManager, multicastClient);
		multicaster.join();
		printUserNames(multicaster);
		CharacterDrawerLauncher.createCharacterDrawer("Frame 1");
		CharacterDrawerLauncher.createCharacterDrawer("Frame 2");
		for (ADelegateFrame frame: ADelegateFrame.getAllFrames()) {
			frame.addPainter(telePointerManager);
		}
//		createCharacterDrawer("Frame 1", telePointerManager);
//		createCharacterDrawer("Frame 2", telePointerManager);
		
		//ObjectEditor.edit(multicaster);
	}
//	public static void createCharacterDrawer (String theTitle, ATelePointerManager telePointerManager) {
//		ADelegateFrame delegateFrame = new ADelegateFrame();
//		delegateFrame.setTitle(theTitle);
//		//delegateFrame.addMouseMotionListener(mouseTracker);
//		delegateFrame.addPainter(telePointerManager);
//		ACharacterDrawer characterDrawer =  new ACharacterDrawer(delegateFrame);
//		delegateFrame.setSize(300, 400);
//		delegateFrame.setVisible(true);			
//	}	
	static void printUserNames(Communicator multicaster) {
		try {
			String[] users = multicaster.getUserNames();
			String userString = "";
			for (int i = 0; i < users.length; i++) {
				userString += users[i];
			}
			System.out.println("Existing users in session:" + userString);
		} catch (Exception e) {
				
		}
	}
}
//END OF FILE
//START OF FILE: src/old/replicatedwindow/telepointer.java
package old.replicatedWindow;

import util.awt.ADelegateFrame;

public interface TelePointer {

	public int getX();

	public void setX(int x);

	public int getY();

	public void setY(int y);

	public ADelegateFrame getDelegateFrame();

	public void setDelegateFrame(ADelegateFrame theDelagateFrame);

}
//END OF FILE
//START OF FILE: src/replicatedwindow/acommunicatedawteventsupport.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.InvocationEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.PaintEvent;
import java.awt.event.WindowEvent;
import java.util.HashSet;
import java.util.Set;

public class ACommunicatedAWTEventSupport implements CommunicatedAWTEventSupport  {
    Object wToolkit;
    InvocationEvent globalCursorEvent; 
    int[] notCommunicatedEventsArray = {
    		AWTMisc.SEQUENCED_EVENT_ID,
    		InvocationEvent.INVOCATION_DEFAULT,
    		InvocationEvent.INVOCATION_FIRST,
    		InvocationEvent.INVOCATION_LAST,

    		AWTMisc.STOP_DISPATCH_EVENT,
    		PaintEvent.PAINT,
    		// ignoring the rest is danegeorus
//    		MouseEvent.MOUSE_MOVED, // needed for combo box
    		// it seems the uncommented events can be ignored but there is some flakiness
    		FocusEvent.FOCUS_FIRST,
    		FocusEvent.FOCUS_LAST,
    		FocusEvent.FOCUS_GAINED,
    		FocusEvent.FOCUS_LOST,		
    		WindowEvent.WINDOW_ACTIVATED,
    		WindowEvent.WINDOW_CLOSED,
    		WindowEvent.WINDOW_CLOSING,
    		WindowEvent.WINDOW_DEACTIVATED,
    		WindowEvent.WINDOW_FIRST,
    		// these three cause problems with text field and check box
//    		WindowEvent.WINDOW_GAINED_FOCUS,
//    		WindowEvent.WINDOW_LAST,
//    		WindowEvent.WINDOW_LOST_FOCUS,
    		WindowEvent.WINDOW_OPENED,
    		WindowEvent.WINDOW_STATE_CHANGED, // we can iconfiy without it
    		WindowEvent.COMPONENT_FIRST,
    		WindowEvent.COMPONENT_HIDDEN,
    		WindowEvent.COMPONENT_LAST,
    		WindowEvent.COMPONENT_MOVED,
////    		WindowEvent.COMPONENT_RESIZED, // needed for frame resizing
    		WindowEvent.COMPONENT_SHOWN, // generated only for window and layout
    		
    		MouseEvent.MOUSE_ENTERED, // generated when you move the window
    		MouseEvent.MOUSE_EXITED, // generated when you move the window
    		
    };
	Set<Integer> notCommunicatedEventIDs = new HashSet();
	Class[] communicatedEventClassesArray = {
			MouseEvent.class,
			KeyEvent.class,
//			InputEvent.class, 
			ComponentEvent.class,
//			WindowEvent.class
			};
	Set<Class> communicatedEventClasses =  new HashSet();
	//do not think we need this
	Class[] notDispatchedRemoteEventClassesArray = {
			ComponentEvent.class
	};
	Set<Class> notDispatchedRemoteEventClasses = new HashSet();
	boolean onlyModifiedMouseEvents = true;
	boolean sendInvocationEvents = false;
	
	void initSets() {
		for (Integer anId:notCommunicatedEventsArray)
			notCommunicatedEventIDs.add(anId);
		for (Class aClass:communicatedEventClassesArray)
			communicatedEventClasses.add(aClass);
		for (Class aClass:notDispatchedRemoteEventClassesArray)
			notDispatchedRemoteEventClasses.add(aClass);
		
	}
	
//	void initNotCommunicatedEvents() {
//		notCommunicatedEvents.add(AWTMisc.SEQUENCED_EVENT_ID);
//		notCommunicatedEvents.add(InvocationEvent.INVOCATION_DEFAULT);
//		notCommunicatedEvents.add(InvocationEvent.INVOCATION_FIRST);
//		notCommunicatedEvents.add(InvocationEvent.INVOCATION_LAST);
//
//		notCommunicatedEvents.add(AWTMisc.STOP_DISPATCH_EVENT);
//		notCommunicatedEvents.add(PaintEvent.PAINT);
//		// ignoring the rest is danegeorus
////		notCommunicatedEvents.add(MouseEvent.MOUSE_MOVED); // needed for combo box
//		// it seems the uncommented events can be ignored but there is some flakiness
//		notCommunicatedEvents.add(FocusEvent.FOCUS_FIRST);
//		notCommunicatedEvents.add(FocusEvent.FOCUS_LAST);
//		notCommunicatedEvents.add(FocusEvent.FOCUS_GAINED);
//		notCommunicatedEvents.add(FocusEvent.FOCUS_LOST);		
//		notCommunicatedEvents.add(WindowEvent.WINDOW_ACTIVATED);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_CLOSED);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_CLOSING);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_DEACTIVATED);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_FIRST);
//		// these three cause problems with text field and check box
////		notCommunicatedEvents.add(WindowEvent.WINDOW_GAINED_FOCUS);
////		notCommunicatedEvents.add(WindowEvent.WINDOW_LAST);
////		notCommunicatedEvents.add(WindowEvent.WINDOW_LOST_FOCUS);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_OPENED);
//		notCommunicatedEvents.add(WindowEvent.WINDOW_STATE_CHANGED); // we can iconfiy without it
//		notCommunicatedEvents.add(WindowEvent.COMPONENT_FIRST);
//		notCommunicatedEvents.add(WindowEvent.COMPONENT_HIDDEN);
//		notCommunicatedEvents.add(WindowEvent.COMPONENT_LAST);
//		notCommunicatedEvents.add(WindowEvent.COMPONENT_MOVED);
//////		notCommunicatedEvents.add(WindowEvent.COMPONENT_RESIZED); // needed for frame resizing
//		notCommunicatedEvents.add(WindowEvent.COMPONENT_SHOWN); // generated only for window and layout
//		
//		notCommunicatedEvents.add(MouseEvent.MOUSE_ENTERED); // generated when you move the window
//		notCommunicatedEvents.add(MouseEvent.MOUSE_EXITED); // generated when you move the window
//
//		
//
//
//
//
////		notCommunicatedEvents.add(WindowEvent.WINDOW_DEICONIFIED);
//	
//
//
////		notCommunicatedEvents.add(COMPONENT_EVENT_ID);
//		
//
////		addEventQueueHandler(new ALocalEventForwarder());
//		
//	}
	public ACommunicatedAWTEventSupport() {
		

		initSets();
	}
	// instance of obe ofthese events
	public static boolean isInstanceOf (Object anObject, Set<Class> aClasses) {
		return aClasses.contains(anObject.getClass());
//		for (Class aClass:aClasses) {
////			if ((aClass.isAssignableFrom(anObject.getClass()))) {
//			if (aClass == anObject.getClass()) {
//				return true;
//			}
//		}
//		return false;
	}
	
	public static boolean isUnModifiedMouseEvent (AWTEvent anAWTEvent) {
		if (anAWTEvent instanceof  MouseEvent) {
			return ((MouseEvent) anAWTEvent).getModifiers() == 0;
		}
		return false;
	}
	
	public AWTEvent toDispatchedEvent(SerializableEvent aReceivedEvent, Component component) {
		AWTEvent aReceivedAWTEvent = aReceivedEvent.getAWTEvent();
		if (aReceivedAWTEvent == null)
			return null;
		AWTEvent retVal = aReceivedAWTEvent;
		
			 if (aReceivedAWTEvent instanceof MouseEvent) {
					MouseEvent aMouseEvent = (MouseEvent) aReceivedAWTEvent;
					retVal = new MouseEvent(
							component,
							aMouseEvent.getID(), 
							aMouseEvent.getWhen(),
							aMouseEvent.getModifiers(), 
							aMouseEvent.getX(), 
							aMouseEvent.getY(),
							aMouseEvent.getClickCount(), 
							aMouseEvent.isPopupTrigger());
					return retVal;


				} else if (aReceivedAWTEvent instanceof KeyEvent) {
					KeyEvent aKeyEvent = (KeyEvent) aReceivedAWTEvent;
					retVal  = new KeyEvent(
							component, 
							aKeyEvent.getID(), 
							aKeyEvent.getWhen(), 
							aKeyEvent.getModifiers(), 
							aKeyEvent.getKeyCode(), 
							aKeyEvent.getKeyChar(), 
							aKeyEvent.getKeyLocation());
					return retVal;
					
					
				}
		
//		} else {
//			serializableEvent.getAWTEvent().setSource(wToolkit);
//		}
//			System.out.println("Starting dispatching of received event:" + serializableEvent.getAWTEvent());
//			System.out.println("param string:" + serializableEvent.getAWTEvent().paramString());
				else if (AWTMisc.isResizeEvent(aReceivedAWTEvent) && component instanceof Frame) {
				Dimension size = AWTMisc.getSize(aReceivedEvent.paramString());
//				System.out.println("Settint new size of " + component + " to:" + size);
				if (!(component.getSize().equals(size))) {
				component.setSize(size);
				}
				return null;
			} else if (AWTMisc.isWindowIconfiedEvent(aReceivedAWTEvent) && component instanceof Frame) {
				((Frame) component).setExtendedState(Frame.ICONIFIED);
				return null;
			} else if (AWTMisc.isWindowDeIconfiedEvent(aReceivedAWTEvent) && component instanceof Frame) {
				((Frame) component).setExtendedState(Frame.NORMAL);
				return null;
			}
//			try {
//				if (!isInstanceOf(localEvent, notDispatchedRemoteEventClasses)) {
//				System.out.println("Dispatching:" + localEvent);
//			super.dispatchEvent(localEvent);
//				}
//			} catch (Exception e) {
//				e.printStackTrace();
//			}
//			System.out.println("Finished dispatching of received event with source:" + serializableEvent.getAWTEvent().getSource() );
//			if (component instanceof EventProcessor) {
//				System.out.println("Processing on source " + component + " event:" + serializableEvent.getAWTEvent());
//				((EventProcessor) component).processEvent(serializableEvent);
//			}
			 return null;
		}

	
	
	// what is sent and locally dispatched not the same.
	public AWTEvent toSentEvent(AWTEvent anEvent) {

		AWTEvent sentEvent = anEvent; 


		Object source = anEvent.getSource();
		Component aComponent = null;
		if (!(source instanceof Component)) {
			wToolkit = source; // we do not really need this
			if (!sendInvocationEvents) {
//				System.out.println("Dispathcing without sending invocation event:" + anEvent);

				return null;
			
			}

		}
		
		if (AWTMisc.isSequenceEvent(anEvent)) {
			sentEvent = AWTMisc.nested(anEvent);
		}
		if (AWTMisc.isGlobalCursorEvent(anEvent)) {
			System.out.println("Dispathcing as null:" + anEvent);

			sentEvent = null;
//			anId = ComponentRegistry.GLOBAL_CURSOR_EVENT_ID;
			globalCursorEvent = (InvocationEvent) anEvent;
		} else if (sentEvent == null ||
				notCommunicatedEventIDs.contains(sentEvent.getID()) ||
				!(isInstanceOf(sentEvent, communicatedEventClasses)) ||
				onlyModifiedMouseEvents && isUnModifiedMouseEvent(sentEvent)
				) {
//			System.out.println("Dispathcing without sending:" + anEvent);
			sentEvent = null;
		}

//		if (anEvent instanceof PaintEvent) {
//			System.out.println("Broadcasting paint event:" + anEvent + " with param string" + anEvent.paramString());
//		}
		return sentEvent;

	}
//	public static Object deepCopy(Object orig) {
//		Object obj = orig;
//		try {
//			// Write the object out to a byte array
//			FastByteArrayOutputStream fbos = new FastByteArrayOutputStream();
//			ObjectOutputStream out = new ObjectOutputStream(fbos);
//			out.writeObject(orig);
//			out.flush();
//			out.close();
//
//			// Retrieve an input stream from the byte array and read
//			// a copy of the object back in.
//			ObjectInputStream in = new ObjectInputStream(fbos.getInputStream());
//			obj = in.readObject();
//		} catch (InvalidClassException ice) {
//			
//		} catch (NotSerializableException  nse) {
//
//		} catch (IOException e) {
//			e.printStackTrace();
//		} catch (ClassNotFoundException cnfe) {
//			cnfe.printStackTrace();
//		}
//		return obj;
//	}

	public Set<Integer> getNotCommunicatedEventIDs() {
		return notCommunicatedEventIDs;
	}

	public void setNotCommunicatedEventIDs(Set<Integer> notCommunicatedEventIDs) {
		this.notCommunicatedEventIDs = notCommunicatedEventIDs;
	}

	public Set<Class> getCommunicatedEventClasses() {
		return communicatedEventClasses;
	}

	public void setCommunicatedEventClasses(Set<Class> communicatedEventClasses) {
		this.communicatedEventClasses = communicatedEventClasses;
	}

	public Set<Class> getNotDispatchedRemoteEventClasses() {
		return notDispatchedRemoteEventClasses;
	}

	public void setNotDispatchedRemoteEventClasses(
			Set<Class> notDispatchedRemoteEventClasses) {
		this.notDispatchedRemoteEventClasses = notDispatchedRemoteEventClasses;
	}
	
}
//END OF FILE
//START OF FILE: src/replicatedwindow/acomponentregistry.java
package replicatedWindow;

import java.awt.Component;
import java.awt.Container;
import java.util.ArrayList;
import java.util.List;

public class AComponentRegistry implements ComponentRegistry {
	 List<Component> components = new ArrayList();
	public  final int WTOOLKIT_ID = -2;
	public  final int GLOBAL_CURSOR_EVENT_ID = -3;

	public  void register(Component aComponent) {
		if (components.contains(aComponent))
			return;
		components.add(aComponent);
	}

	public  Component getComponent(int id) {
		if (id < 0 ||  id >= components.size() ) 
			return null;
		return components.get(id);
			
	}

	public  int getComponentId(Component aComponent) {
		return components.indexOf(aComponent);
	}
    public  void registerComponentTree(Component aComponent ) {
    	register(aComponent);
    	if (aComponent instanceof Container) {
    		Container container = (Container) aComponent;
    		Component[] components = container.getComponents();
    		for (Component aChild:components) {
    			registerComponentTree(aChild);    			
    		}
    	}
		
	}
}
//END OF FILE
//START OF FILE: src/replicatedwindow/adelegatingtelepointerglasspane.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.AWTEventListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import bus.uigen.widgets.Painter;
import util.awt.AGlassPaneRedispatcher;
import util.awt.GraphicsPainter;

public class ADelegatingTelePointerGlassPane extends JPanel implements DelegatingTelepointerGlassPane{
	public static final int DIAMETER = 10;
	int x = 50;
	int y = 50;
	int clickX, clickY;
	boolean pointerSelected;
	JFrame frame;
	protected int pointerWidth = DIAMETER, pointerHeight = DIAMETER;
	protected List<GraphicsPainter> painters = new ArrayList();
	
	
	public ADelegatingTelePointerGlassPane(JFrame aFrame) {
		frame = aFrame;
		this.setFocusable(false);
		this.addMouseListener(this);
		this.addMouseMotionListener(this);
//		this.addKeyListener(this);
////		this.addKeyListener(this);
//		long eventMask = AWTEvent.MOUSE_MOTION_EVENT_MASK
//			    + AWTEvent.MOUSE_EVENT_MASK
//			    + AWTEvent.KEY_EVENT_MASK;
//		Toolkit.getDefaultToolkit().addAWTEventListener( this, eventMask);
		this.setOpaque(false);
		AGlassPaneRedispatcher redispatcher = new AGlassPaneRedispatcher(this, aFrame);
		aFrame.setGlassPane(this);
		this.setVisible(true);
	}

	public void paint(Graphics g) {
		super.paint(g);
//		g.setColor(Color.RED);
//		g.fillOval(x, y, DIAMETER, DIAMETER);
		notifyPainters(g);
	}
	@Override
	public int getPointerX() {
		return x;
	}
	@Override
	public void setPointerX(int newVal) {
		x = newVal;
	}
	@Override
	public int getPointerY() {
		return y;
	}
	@Override

	public void setPointerY(int newVal) {
		y = newVal;
	}
	@Override
	public int getPointerWidth() {
		return pointerWidth;
	}
	@Override
	public void setPointerWidth(int aWidth) {
		pointerWidth = aWidth;
	}
	@Override
	public int getPointerHeight() {
		return pointerHeight;
	}
	@Override
	public void setPointerHeight(int aHeight) {
		pointerHeight = aHeight;
	}
	 
	boolean inTelePointer (MouseEvent event) {
		return event.getX() >= x && event.getX() <= (event.getX() + getPointerWidth()) &&
				event.getY() >= y && event.getY() <= (event.getY() + getPointerHeight());
	}
	@Override
	 public void eventDispatched(AWTEvent event) { 
		System.out.println("foo");
		  if (event instanceof MouseEvent) { 
	            MouseEvent me = (MouseEvent) event; 
	            if (!SwingUtilities.isDescendingFrom(me.getComponent(), frame)) { 
	                return; 
	            } 
	           
	            if (me.getID() == MouseEvent.MOUSE_EXITED && me.getComponent() == frame) { 
	                x = -1; 
	                y = -1;
	            } else { 
	                MouseEvent converted = SwingUtilities.convertMouseEvent(me.getComponent(), me, frame.getGlassPane()); 
	                Point point = converted.getPoint(); 
	                x = point.x;
	                y = point.y;
	            } 
	            repaint(); 
	        } 
	    } 
	
	@Override
	protected void processEvent (AWTEvent anEvent) {
		super.processEvent(anEvent);
	}
	
	
	@Override
	public void mouseClicked(MouseEvent arg0) {
		
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		
		
	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		if (inTelePointer (arg0)) {
			pointerSelected = true;
			clickX = arg0.getX();
			clickY = arg0.getY();
		}
		
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		pointerSelected = false;
		
	}
	@Override
	public void mouseDragged(MouseEvent event) {
		if (!pointerSelected) return;
		int incX = event.getX() - clickX;
		int incY = event.getY() - clickY;
		clickX = event.getX();
		clickY = event.getY();
		x += incX;
		y += incY;
		repaint();
	}
	@Override
	public void mouseMoved(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}
//	@Override
//	public void keyPressed(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void keyReleased(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void keyTyped(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		System.out.println("Key pressed in relepointer");
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void addPainter(GraphicsPainter aPainter) {
		painters.add(aPainter);
		
	}

	@Override
	public void removePainter(GraphicsPainter aPainter) {
		painters.remove(aPainter);
		
	}
	
	protected void notifyPainters(Graphics g) {
		for (GraphicsPainter aPainter:painters) {
			aPainter.paint(g);
			
		}
	}
	    

}
//END OF FILE
//START OF FILE: src/replicatedwindow/areplicatedwindowscomposerandlauncher.java
package replicatedWindow;

import bus.uigen.ObjectEditor;
import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.PeerMessageListener;
import util.trace.Tracer;
import util.trace.session.SessionTracerSetter;
import echo.modular.AnEchoComposerAndLauncher;
import echo.modular.EchoerInteractor;
import echo.modular.History;
public class AReplicatedWindowsComposerAndLauncher implements CommunicatorBasedComposerAndLauncher  {
	public static final String DEFAULT_APPLICATION_NAME = "Shared Window System";

	protected Communicator communicator;	
	protected PeerMessageListener eventReceiver;
	protected ComponentRegistry componentRegistry;
	protected EventQueueHandler eventQueueHandler;
	

	
	
	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#getApplicationName()
	 */
	@Override
	public String getApplicationName() {
		return DEFAULT_APPLICATION_NAME;
	}
	
	protected void addCollaborationFunctions() {
		addEventReceiver();
	}	
	protected void addApplications() {
		WidgetTesterLauncher.createFrameWithWidgets(getApplicationName() + " Widgets");
	}
	
	protected void createComponentRegistry() {
		componentRegistry = new AComponentRegistry();
	}
	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#compose(java.lang.String[])
	 */
	@Override
	public void compose(String[] args) {
		createComponentRegistry();
		communicator = createCommunicator(args);
		addCollaborationFunctions();
		AnInputQueue.useAsEventQueue();
		addApplications();
		communicator.join();
		// we do not want to broadcast setup events
		// or early events
		addEventBroadcaster();

	}	
	
	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#composeAndLaunch(java.lang.String[])
	 */
	@Override
	public void composeAndLaunch(String[] args) {
		compose(args);
	}

	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#checkArgs(java.lang.String[])
	 */
	@Override
	public void checkArgs(String[] args) {
		if (args.length < 5) {
			System.out.println("Please supply server host name, session name,  user name and application name as main arguments");
			System.exit(-1);
		}
	}
	// parameters to factory
	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#createCommunicator(java.lang.String[])
	 */
	@Override
	public  Communicator createCommunicator(String args[]) {
		checkArgs(args);
		if (args.length == 5) {
			if (args[4].equalsIgnoreCase(Communicator.DIRECT))
				CommunicatorSelector.selectDirectCommunicator();
			else if (args[4].equalsIgnoreCase(Communicator.RELAYED))
				CommunicatorSelector.selectRelayerCommunicator();				
		}
		return CommunicatorSelector.getCommunicator(args[0],args[1],args[2], args[3]);
//		CommunicatorCreator communicatorFactory = ACommunicatorSelector.getCommunicatorFactory();
//		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
	}
	protected  void addEventReceiver() {
		eventReceiver = new AnEventQueueReceiver(componentRegistry);
		communicator.addPeerMessageListener(eventReceiver);
	}
	protected void addEventBroadcaster() {
		eventQueueHandler = new AnEventQueueBroadcaster(communicator, componentRegistry);
	}
	/* (non-Javadoc)
	 * @see replicatedWindow.ReplicatedWindowsComposerAndLauncher#getCommunicator()
	 */
	@Override
	public Communicator getCommunicator() {
		return communicator;
	}
	
	public static void main (String[] args) {
		Tracer.showInfo(true);
		SessionTracerSetter.setSessionPrintStatus();
		(new AReplicatedWindowsComposerAndLauncher()).composeAndLaunch(args);
	}
}
//END OF FILE
//START OF FILE: src/replicatedwindow/aserializableevent.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

public class ASerializableEvent implements SerializableEvent {
	AWTEvent event;
	String componentId;
	String paramString;

	// transient boolean isLocal = false;
	public ASerializableEvent(AWTEvent theEvent, String theComponentId) {
		event = theEvent;
		componentId = theComponentId;
		if (theEvent != null)
		paramString = theEvent.paramString();
	}
	public AWTEvent getAWTEvent() {
		return event;
	}
	public String paramString() {
		return paramString;
	}
	public void setParamString(String aParamString) {
		paramString = aParamString;
	}
	public String getSource() {
		return componentId;
	}
	public void setSource(String aComponentId) {
		componentId = aComponentId;
	}
	public void setAWTEvent(AWTEvent anEvent) {
		event = anEvent;
	}

}
//END OF FILE
//START OF FILE: src/replicatedwindow/atelepointerglasspane.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.AWTEventListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import util.awt.AGlassPaneRedispatcher;

public class ATelePointerGlassPane extends JPanel implements MouseListener, MouseMotionListener, AWTEventListener, KeyListener{
	public static int DIAMETER = 10;
	int x = 50;
	int y = 50;
	int clickX, clickY;
	boolean pointerSelected;
	JFrame frame;
	
	public ATelePointerGlassPane(JFrame aFrame) {
		frame = aFrame;
		this.setFocusable(false);
		this.addMouseListener(this);
		this.addMouseMotionListener(this);
//		this.addKeyListener(this);
////		this.addKeyListener(this);
//		long eventMask = AWTEvent.MOUSE_MOTION_EVENT_MASK
//			    + AWTEvent.MOUSE_EVENT_MASK
//			    + AWTEvent.KEY_EVENT_MASK;
//		Toolkit.getDefaultToolkit().addAWTEventListener( this, eventMask);
		this.setOpaque(false);
		AGlassPaneRedispatcher redispatcher = new AGlassPaneRedispatcher(this, aFrame);
		aFrame.setGlassPane(this);
		this.setVisible(true);
	}

	public void paint(Graphics g) {
		super.paint(g);
		g.setColor(Color.RED);
		g.fillOval(x, y, DIAMETER, DIAMETER);
	}
	 
	boolean inTelePointer (MouseEvent event) {
		return event.getX() >= x && event.getX() <= (event.getX() + DIAMETER) &&
				event.getY() >= y && event.getY() <= (event.getY() + DIAMETER);
	}
	@Override
	 public void eventDispatched(AWTEvent event) { 
		System.out.println("foo");
		  if (event instanceof MouseEvent) { 
	            MouseEvent me = (MouseEvent) event; 
	            if (!SwingUtilities.isDescendingFrom(me.getComponent(), frame)) { 
	                return; 
	            } 
	           
	            if (me.getID() == MouseEvent.MOUSE_EXITED && me.getComponent() == frame) { 
	                x = -1; 
	                y = -1;
	            } else { 
	                MouseEvent converted = SwingUtilities.convertMouseEvent(me.getComponent(), me, frame.getGlassPane()); 
	                Point point = converted.getPoint(); 
	                x = point.x;
	                y = point.y;
	            } 
	            repaint(); 
	        } 
	    } 
	
	@Override
	protected void processEvent (AWTEvent anEvent) {
		super.processEvent(anEvent);
	}
	
	
	@Override
	public void mouseClicked(MouseEvent arg0) {
		
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		
		
	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		if (inTelePointer (arg0)) {
			pointerSelected = true;
			clickX = arg0.getX();
			clickY = arg0.getY();
		}
		
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		pointerSelected = false;
		
	}
	@Override
	public void mouseDragged(MouseEvent event) {
		if (!pointerSelected) return;
		int incX = event.getX() - clickX;
		int incY = event.getY() - clickY;
		clickX = event.getX();
		clickY = event.getY();
		x += incX;
		y += incY;
		repaint();
	}
	@Override
	public void mouseMoved(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}
//	@Override
//	public void keyPressed(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void keyReleased(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void keyTyped(KeyEvent arg0) {
//		// TODO Auto-generated method stub
//		
//	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		System.out.println("Key pressed in relepointer");
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub
		
	}
	    

}
//END OF FILE
//START OF FILE: src/replicatedwindow/awtmisc.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.ComponentEvent;
import java.awt.event.InvocationEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.PaintEvent;
import java.awt.event.WindowEvent;
import java.lang.reflect.Field;

public class AWTMisc {

	public static final int SEQUENCED_EVENT_ID = 1006;
	public static final int COMPONENT_EVENT_ID = 101;
//	public static final int INVOCATION_EVENT_ID = InvocationEvent.INVOCATION_DEFAULT;
	public static final int STOP_DISPATCH_EVENT = 0;
//	public static final int PAINT_EVENT = PaintEvent.PAINT;
//	public static final int MOUSE_MOVED_EVENT = 503;

	static Field isSystemGeneratedField;
	static Field disposedField;
	static Field nestedField;
	static Field runnableField;

	
	
	
	// not useful
	public static boolean disposed(AWTEvent event) {
		try {
			return (Boolean) disposedField(event).get(event);
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}
	// used to serialize component of sequencedevent
	public static AWTEvent nested(AWTEvent event) {
		try {
			return (AWTEvent) nestedField(event).get(event);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		
	}
	// not a useful method
	public static boolean isSystemGenerated(AWTEvent event) {
		try {
			return (Boolean) isSystemGeneratedField().get(event);
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}
	
	public static boolean isGlobalCursorEvent(AWTEvent anEvent) {
		return isInvocationEvent(anEvent) && 
				runnable(anEvent).toString().indexOf("GlobalCursorManager") >= 0;
	}
	
	public static Field isSystemGeneratedField() {
		if (isSystemGeneratedField == null) {
			try {
				isSystemGeneratedField = AWTEvent.class.getDeclaredField("isSystemGenerated");
				isSystemGeneratedField.setAccessible(true);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return isSystemGeneratedField;
	}
	public static Field runnableField() {
		if (runnableField == null) {
			try {
				runnableField = InvocationEvent.class.getDeclaredField("runnable");
				runnableField.setAccessible(true);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return runnableField;
	}
	public static Runnable runnable(AWTEvent event) {
		try {
			return (Runnable) runnableField().get(event);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		
	}
	public static Field disposedField(AWTEvent event) {
		if (disposedField == null) {
			try {
				disposedField = event.getClass().getDeclaredField("disposed");
				disposedField.setAccessible(true);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return disposedField;
	}
	public static Field nestedField(AWTEvent event) {
		if (nestedField == null) {
			try {
				nestedField = event.getClass().getDeclaredField("nested");
				nestedField.setAccessible(true);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return nestedField;
	}
	
	public static boolean isInvocationEvent(AWTEvent event) {
		return event instanceof InvocationEvent;
	}
	
	public static boolean isPaintEvent(AWTEvent event) {
		return event instanceof PaintEvent;
	}
	
	public static boolean isWindowEvent(AWTEvent event) {
		return event instanceof WindowEvent;
	}
	
	public static boolean isWindowIconfiedEvent(AWTEvent event) {
		return event.getID() == WindowEvent.WINDOW_ICONIFIED; 
	}
	public static boolean isWindowDeIconfiedEvent(AWTEvent event) {
		return event.getID() == WindowEvent.WINDOW_DEICONIFIED; 
	}
	
	public static boolean isComponentShown(AWTEvent anEvent) {
		return anEvent.getID() == WindowEvent.COMPONENT_SHOWN;
	}
	

	public static boolean isResizeEvent(AWTEvent event) {
		if (!(event instanceof ComponentEvent))
			return false;
		ComponentEvent componentEvent = (ComponentEvent) event;
		return componentEvent.getID() == ComponentEvent.COMPONENT_RESIZED;
	}
	
	public static boolean isSequenceEvent(AWTEvent event) {
		return event.getID() == SEQUENCED_EVENT_ID;
	}
	
	public static boolean isMouseEvent(AWTEvent event) {
		return event instanceof MouseEvent;
	}

	public static boolean isKeyEvent(AWTEvent event) {
		return event instanceof KeyEvent;
	}
	
	

	public static boolean isMouseMovedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_MOVED;
	}
	
	public static boolean isMouseDraggedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_DRAGGED;
	}

	public static boolean isMousePressedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_PRESSED;
	}

	public static boolean isMouseClickedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_CLICKED;
	}

	public static boolean isMouseReleasedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_RELEASED;
	}

	public static boolean isMouseEnteredEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_ENTERED;
	}

	public static boolean isMouseExitedEvent(AWTEvent event) {
		if (!(event instanceof MouseEvent))
			return false;
		MouseEvent mousevent = (MouseEvent) event;
		return mousevent.getID() == MouseEvent.MOUSE_EXITED;
	}

	public static Point getLocation(AWTEvent event) {
		
			if (!(event instanceof MouseEvent))
				throw new RuntimeException("Event  with ID: " + event.getID()
						+ " is not a mouse event");
			return getLocation(event.paramString());
		
	}

	public static int getX(AWTEvent event) {
		return getLocation(event).x;
	}

	public static int getY(AWTEvent event) {
		return getLocation(event).y;
	}

	

	public static Dimension getSize(String paramString) {
		int secondSpace = paramString.lastIndexOf(' ');
		int firstX = paramString.indexOf('x');
		int firstClosedParen = paramString.indexOf(')');
		try {
			String stringWidth = paramString.substring(secondSpace + 1, firstX);
			int width = Integer.parseInt(stringWidth);
			String stringHeight = paramString.substring(firstX + 1,
					firstClosedParen);
			int height = Integer.parseInt(stringHeight);
			return new Dimension(width, height);
		} catch (Exception e) {
			return new Dimension(0, 0);
		}
	}
	
	public static Dimension getSize(AWTEvent event) {
		return getSize(event.paramString());
	}

	public static Point getLocation(String paramString) {
		int leftPara = paramString.indexOf('(');
		int comma = paramString.indexOf(',', leftPara);
		int rightPara = paramString.indexOf(')');
		try {
			String stringX = paramString.substring(leftPara + 1, comma);
			int x = Integer.parseInt(stringX);
			String stringY = paramString.substring(comma + 1, rightPara);
			int y = Integer.parseInt(stringY);
			return new Point(x, y);
		} catch (Exception e) {
			e.printStackTrace();
			return new Point(0, 0);
		}
	}

}
//END OF FILE
//START OF FILE: src/replicatedwindow/alicereplicatedwindows.java
package replicatedWindow;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;

@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_1})
public class AliceReplicatedWindows implements ExampleSharedWindowsSession{
	public static final String USER_NAME = DistributedTags.CLIENT_1;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
//		IMTracerSetter.traceIM();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);
//		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new AReplicatedWindowsComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/replicatedwindow/aneventqueuebroadcaster.java
package replicatedWindow;

import java.awt.AWTEvent;

import util.session.Communicator;

public class AnEventQueueBroadcaster implements EventQueueHandler{
	ComponentRegistry componentRegistry;
	Communicator communicator;
	public AnEventQueueBroadcaster(Communicator theCommunicator) {
		communicator = theCommunicator;
		AnInputQueue.getEventQueue().addEventQueueHandler(this);

	}
	public AnEventQueueBroadcaster(Communicator aCommunicator, ComponentRegistry aComponentRegistry) {
		componentRegistry = aComponentRegistry;
		communicator = aCommunicator;
		AnInputQueue.getEventQueue().addEventQueueHandler(this);

	}

	@Override
	public void newEvent(AWTEvent event) {
//		if (event != null && event.getAWTEvent().getSource() instanceof Component && ! (event.getAWTEvent().getSource() instanceof Frame)) {
//			System.out.println(event.getAWTEvent().getSource());
//		}
//		System.out.println("Started broadcasting of event:" + event.getAWTEvent() );
//		if (event.isKeyEvent()) {
//			System.out.println("Key Event Source:" + event.getAWTEvent().getSource() +
//					" source id: " + event.getSource());
//		}
		SerializableEvent serializedEvent = new ASerializableEvent(event, AnInputQueue.toID(event));
//		groupSessionPort.sendAll(serializedEvent);
		communicator.toOthers(serializedEvent);

//		System.out.println("Finished broadcasting");

	}

	@Override
	public void newEvent(SerializableEvent event) {
		// TODO Auto-generated method stub
//		groupSessionPort.sendAll(event);

		
	}

}
//END OF FILE
//START OF FILE: src/replicatedwindow/aneventqueuereceiver.java
package replicatedWindow;

import java.awt.AWTEvent;

import util.session.PeerMessageListener;


public class AnEventQueueReceiver implements PeerMessageListener{
	
	ComponentRegistry componentRegistry;
	
	public AnEventQueueReceiver(ComponentRegistry aComponentRegistry) {
		componentRegistry = aComponentRegistry;		
	}
	
	




	@Override
	public void objectReceived(Object aMessage, String aSourceName) {
		if (aMessage instanceof SerializableEvent ) {
			SerializableEvent serializableEvent = (SerializableEvent) aMessage;
			AWTEvent aDispatchedEvent = AnInputQueue.getEventQueue().getCommunicatedEventSupport().toDispatchedEvent(
					serializableEvent, AnInputQueue.toSource(serializableEvent));
//			AnInputQueue.getEventQueue().dispatchEvent(serializableEvent);
			AnInputQueue.getEventQueue().dispatchReceivedEvent(aDispatchedEvent);

		}
		
	}
	

}
//END OF FILE
//START OF FILE: src/replicatedwindow/aninputqueue.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.Toolkit;
import java.awt.event.ComponentEvent;
import java.awt.event.InvocationEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class AnInputQueue extends EventQueue implements DelegateEventQueue {
	static AnInputQueue eventQueue; // serevres as a factory class
	CommunicatedAWTEventSupport communicatedEventSupport = new ACommunicatedAWTEventSupport();
	Object wToolkit;
	InvocationEvent globalCursorEvent;
	List<EventQueueHandler> eventQueueListeners = new ArrayList();
	Set<Integer> notCommunicatedEvents = new HashSet();
	Class[] communicatedEventClasses = { MouseEvent.class, KeyEvent.class,
			// InputEvent.class,
			ComponentEvent.class,
	// WindowEvent.class
	};
	Class[] notDispatchedRemoteEventClasses = { ComponentEvent.class };
	boolean onlyModifiedMouseEvents = true;
	boolean sendInvocationEvents = true;

	public AnInputQueue() {
		if (eventQueue != null)
			throw new RuntimeException(
					"Call ADelegateEventQueue.getDelegateEventQueue() for an instance of this singleton");
		eventQueue = this;
		EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();
		queue.push(this);
		// do we need this?
		// addEventQueueHandler(new ALocalEventForwarder());

		// notCommunicatedEvents.add(AWTMisc.SEQUENCED_EVENT_ID);
		// notCommunicatedEvents.add(InvocationEvent.INVOCATION_DEFAULT);
		// notCommunicatedEvents.add(InvocationEvent.INVOCATION_FIRST);
		// notCommunicatedEvents.add(InvocationEvent.INVOCATION_LAST);
		//
		// notCommunicatedEvents.add(AWTMisc.STOP_DISPATCH_EVENT);
		// notCommunicatedEvents.add(PaintEvent.PAINT);
		// // ignoring the rest is danegeorus
		// // notCommunicatedEvents.add(MouseEvent.MOUSE_MOVED); // needed for
		// combo box
		// // it seems the uncommented events can be ignored but there is some
		// flakiness
		// notCommunicatedEvents.add(FocusEvent.FOCUS_FIRST);
		// notCommunicatedEvents.add(FocusEvent.FOCUS_LAST);
		// notCommunicatedEvents.add(FocusEvent.FOCUS_GAINED);
		// notCommunicatedEvents.add(FocusEvent.FOCUS_LOST);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_ACTIVATED);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_CLOSED);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_CLOSING);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_DEACTIVATED);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_FIRST);
		// // these three cause problems with text field and check box
		// // notCommunicatedEvents.add(WindowEvent.WINDOW_GAINED_FOCUS);
		// // notCommunicatedEvents.add(WindowEvent.WINDOW_LAST);
		// // notCommunicatedEvents.add(WindowEvent.WINDOW_LOST_FOCUS);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_OPENED);
		// notCommunicatedEvents.add(WindowEvent.WINDOW_STATE_CHANGED); // we
		// can iconfiy without it
		// notCommunicatedEvents.add(WindowEvent.COMPONENT_FIRST);
		// notCommunicatedEvents.add(WindowEvent.COMPONENT_HIDDEN);
		// notCommunicatedEvents.add(WindowEvent.COMPONENT_LAST);
		// notCommunicatedEvents.add(WindowEvent.COMPONENT_MOVED);
		// //// notCommunicatedEvents.add(WindowEvent.COMPONENT_RESIZED); //
		// needed for frame resizing
		// notCommunicatedEvents.add(WindowEvent.COMPONENT_SHOWN); // generated
		// only for window and layout
		//
		// notCommunicatedEvents.add(MouseEvent.MOUSE_ENTERED); // generated
		// when you move the window
		// notCommunicatedEvents.add(MouseEvent.MOUSE_EXITED); // generated when
		// you move the window
		//
		//
		//
		//
		//
		//
		// // notCommunicatedEvents.add(WindowEvent.WINDOW_DEICONIFIED);
		//
		//
		//
		// // notCommunicatedEvents.add(COMPONENT_EVENT_ID);
		//
		//
		// // addEventQueueHandler(new ALocalEventForwarder());
	}

	// // instance of obe ofthese events
	// public static boolean isInstanceOf (Object anObject, Class[] aClasses) {
	// for (Class aClass:aClasses) {
	// // if ((aClass.isAssignableFrom(anObject.getClass()))) {
	// if (aClass == anObject.getClass()) {
	// return true;
	// }
	// }
	// return false;
	// }
	//
	// public static boolean isUnModifiedMouseEvent (AWTEvent anAWTEvent) {
	// if (anAWTEvent instanceof MouseEvent) {
	// return ((MouseEvent) anAWTEvent).getModifiers() == 0;
	// }
	// return false;
	// }

	@Override
	public void addEventQueueHandler(EventQueueHandler listener) {
		if (eventQueueListeners.contains(listener))
			return;
		eventQueueListeners.add(listener);
	}

	public static void addHandler(EventQueueHandler handler) {
		eventQueue.addEventQueueHandler(handler);
	}

	public void removeHandler(EventQueueHandler handler) {
		eventQueue.removeHandler(handler);
	}

	public void clearHandlers(EventQueueHandler handler) {
		eventQueue.clearEventQueuehandlers();
	}

	public void removeEventQueueHandler(EventQueueHandler listener) {
		eventQueueListeners.remove(listener);
	}

	public static Component toSource(SerializableEvent serializableEvent) {
		int sourceId = Integer.parseInt(serializableEvent.getSource());
		return StaticComponentRegistry.getComponent(sourceId);
	}

	public void dispatchEvent(SerializableEvent serializableEvent) {
		AWTEvent aDispatchedEvent = communicatedEventSupport.toDispatchedEvent(
				serializableEvent, toSource(serializableEvent));
		if (aDispatchedEvent != null)
			super.dispatchEvent(aDispatchedEvent);

	}
	
	public void dispatchReceivedEvent(AWTEvent anEvent) {
	
		if (anEvent != null)
			super.dispatchEvent(anEvent);

	}

	Set sources = new HashSet();

	// @Override
	// public Object getWToolkit() {
	// return wToolkit;
	// }

	public static String toID(AWTEvent anEvent) {
		int anId = 0;
		if (!(anEvent.getSource() instanceof Component)) { // event is either
			// a component
			// or instanceof
			// WToolkit, a
			// non public
			// class you
			// cannot seem
			// to name
			return "" + -1;
		}

	
			Component aComponent = (Component) anEvent.getSource();
			if (AWTMisc.isResizeEvent(anEvent)) {
				StaticComponentRegistry.registerComponentTree(aComponent);
			}
			anId = StaticComponentRegistry.getComponentId(aComponent); // should
																		// this
																		// not
																		// be
																		// above
																		// the
																		// first
																		// if
			if (anId < 0) { // this is the case when a resize evcent was not
							// received
				StaticComponentRegistry.registerComponentTree(aComponent);
				anId = StaticComponentRegistry.getComponentId(aComponent);
				System.out.println(anId);
			}
		return "" + anId;
	
	}

	public void dispatchEvent(AWTEvent anEvent) {

		AWTEvent sentEvent = communicatedEventSupport.toSentEvent(anEvent);

		// System.out.println("Dispatching:" + anEvent);
		// System.out.println("Sent event:" + sentEvent);

		if (sentEvent != null) {
//			int anId = 0;

			if (anEvent.getSource() instanceof Component) { // event is either
															// a component
															// or instanceof
															// WToolkit, a
															// non public
															// class you
															// cannot seem
															// to name
//				Component aComponent = (Component) anEvent.getSource();
//				if (AWTMisc.isResizeEvent(anEvent)) {
//					StaticComponentRegistry.registerComponentTree(aComponent);
//				}
//				anId = StaticComponentRegistry.getComponentId(aComponent); // should
//																			// this
//																			// not
//																			// be
//																			// above
//																			// the
//																			// first
//																			// if
//				if (anId < 0) { // this is the case when a resize evcent was not
//								// received
//					StaticComponentRegistry.registerComponentTree(aComponent);
//					anId = StaticComponentRegistry.getComponentId(aComponent);
//					System.out.println(anId);
//				}
				
				String id = toID(anEvent);

//				SerializableEvent serializedEvent = new ASerializableEvent(
//						sentEvent, "" + anId);
				SerializableEvent serializedEvent = new ASerializableEvent(
						sentEvent, id);

				for (EventQueueHandler listener : eventQueueListeners) {
					System.out.println(" sending:" + sentEvent);

					listener.newEvent(serializedEvent);
					listener.newEvent(sentEvent);
				}
			}
		}

		super.dispatchEvent(anEvent);

	}

	// public static Object deepCopy(Object orig) {
	// Object obj = orig;
	// try {
	// // Write the object out to a byte array
	// FastByteArrayOutputStream fbos = new FastByteArrayOutputStream();
	// ObjectOutputStream out = new ObjectOutputStream(fbos);
	// out.writeObject(orig);
	// out.flush();
	// out.close();
	//
	// // Retrieve an input stream from the byte array and read
	// // a copy of the object back in.
	// ObjectInputStream in = new ObjectInputStream(fbos.getInputStream());
	// obj = in.readObject();
	// } catch (InvalidClassException ice) {
	//
	// } catch (NotSerializableException nse) {
	//
	// } catch (IOException e) {
	// e.printStackTrace();
	// } catch (ClassNotFoundException cnfe) {
	// cnfe.printStackTrace();
	// }
	// return obj;
	// }
	public static AnInputQueue getEventQueue() {
		if (eventQueue == null)
			eventQueue = new AnInputQueue();
		return eventQueue;
	}

	public static void useAsEventQueue() {
		getEventQueue();
	}

	@Override
	public void clearEventQueuehandlers() {
		eventQueueListeners.clear();

	}

	public CommunicatedAWTEventSupport getCommunicatedEventSupport() {
		return communicatedEventSupport;
	}

	public void setCommunicatedEventSupport(
			CommunicatedAWTEventSupport communicatedEventSupport) {
		this.communicatedEventSupport = communicatedEventSupport;
	}

	static {
		eventQueue = new AnInputQueue();
	}
}
//END OF FILE
//START OF FILE: src/replicatedwindow/anovalgraphicspainter.java
package replicatedWindow;

import java.awt.Color;
import java.awt.Graphics;

import util.awt.GraphicsPainter;

public class AnOvalGraphicsPainter implements GraphicsPainter {
	DelegatingTelepointerGlassPane glassPane;
	public AnOvalGraphicsPainter(DelegatingTelepointerGlassPane aGlassPane) {
		glassPane = aGlassPane;		
	}

	@Override
	public void paint(Graphics g) {
		g.setColor(Color.RED);
		g.fillOval(glassPane.getPointerX(), 
				glassPane.getPointerY(), 
				glassPane.getPointerWidth(), glassPane.getPointerHeight());
	}

}
//END OF FILE
//START OF FILE: src/replicatedwindow/bobreplicatedwindows.java
package replicatedWindow;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;

@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_2})
public class BobReplicatedWindows implements ExampleSharedWindowsSession{
	public static final String USER_NAME = DistributedTags.CLIENT_2;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
//		IMTracerSetter.traceIM();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);
//		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new AReplicatedWindowsComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/replicatedwindow/cathyreplicatedwindows.java
package replicatedWindow;

import trace.im.IMTracerSetter;
import util.annotations.Tags;
import util.session.Communicator;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.session.ClientJoinFinished;
import util.trace.session.ServerClientJoined;
import util.trace.session.SessionTracerSetter;

@Tags({DistributedTags.CLIENT, DistributedTags.CLIENT_3})
public class CathyReplicatedWindows implements ExampleSharedWindowsSession{
	public static final String USER_NAME = DistributedTags.CLIENT_3;
	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
//		IMTracerSetter.traceIM();
//		Tracer.setKeywordPrintStatus(ClientJoinFinished.class, true);
//		SessionTracerSetter.setSessionPrintStatus();

//		SessionTracerSetter.traceSession();
//		Tracer.setKeywordPrintStatus(ClientJoined.class, true);
		(new AReplicatedWindowsComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}
	
}
//END OF FILE
//START OF FILE: src/replicatedwindow/communicatedawteventsupport.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Component;
import java.util.Set;

public interface CommunicatedAWTEventSupport {
	public Set<Integer> getNotCommunicatedEventIDs();

	public void setNotCommunicatedEventIDs(Set<Integer> notCommunicatedEventIDs) ;
	public Set<Class> getCommunicatedEventClasses() ;

	public void setCommunicatedEventClasses(Set<Class> communicatedEventClasses) ;

	public Set<Class> getNotDispatchedRemoteEventClasses();

	public void setNotDispatchedRemoteEventClasses(
			Set<Class> notDispatchedRemoteEventClasses) ;
	public AWTEvent toSentEvent(AWTEvent anEvent);
	public AWTEvent toDispatchedEvent(SerializableEvent aReceivedEvent, Component component);

}
//END OF FILE
//START OF FILE: src/replicatedwindow/communicatorbasedcomposerandlauncher.java
package replicatedWindow;

import util.session.Communicator;

public interface CommunicatorBasedComposerAndLauncher {

	public abstract String getApplicationName();

	public abstract void compose(String[] args);

	public abstract void composeAndLaunch(String[] args);

	public abstract void checkArgs(String[] args);

	// parameters to factory
	public abstract Communicator createCommunicator(String args[]);

	public abstract Communicator getCommunicator();

}
//END OF FILE
//START OF FILE: src/replicatedwindow/componentregistry.java
package replicatedWindow;

import java.awt.Component;
import java.awt.Container;

public interface ComponentRegistry {
	public  void register(Component aComponent);

	public  Component getComponent(int id) ;

	public  int getComponentId(Component aComponent) ;
    public  void registerComponentTree(Component aComponent ) ;

}
//END OF FILE
//START OF FILE: src/replicatedwindow/delegateeventqueue.java
package replicatedWindow;

import java.awt.AWTEvent;

public interface DelegateEventQueue {

	public void addEventQueueHandler(EventQueueHandler listener);

	public void removeEventQueueHandler(EventQueueHandler listener);

	public void clearEventQueuehandlers();

	public void dispatchEvent(SerializableEvent event);
	public void dispatchEvent(AWTEvent event);
//	public Object getWToolkit();



}
//END OF FILE
//START OF FILE: src/replicatedwindow/delegatingtelepointerglasspane.java
package replicatedWindow;

import java.awt.event.AWTEventListener;
import java.awt.event.KeyListener;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;

import util.awt.GraphicsPainter;
import bus.uigen.widgets.Painter;

public interface DelegatingTelepointerGlassPane 
        extends MouseListener, MouseMotionListener, AWTEventListener, KeyListener {

	int getPointerWidth();

	void setPointerWidth(int aWidth);

	int getPointerHeight();

	void setPointerHeight(int aHeight);
	void addPainter(GraphicsPainter aPainter);
	void removePainter(GraphicsPainter aPainter);

	int getPointerX();

	void setPointerX(int newVal);

	int getPointerY();

	void setPointerY(int newVal);

}
//END OF FILE
//START OF FILE: src/replicatedwindow/demoerofreplicatedwindows.java
package replicatedWindow;

import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfReplicatedWindows {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceReplicatedWindows.class,
				BobReplicatedWindows.class,
				CathyReplicatedWindows.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/replicatedwindow/eventqueuehandler.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Dimension;

public interface EventQueueHandler {
	public void newEvent(SerializableEvent event);
	public void newEvent(AWTEvent anEvent);
}
//END OF FILE
//START OF FILE: src/replicatedwindow/examplesharedwindowssession.java
package replicatedWindow;

public interface ExampleSharedWindowsSession {
	public static final String SESSION_NAME = "Shared Windows Session";
	public static final String APPLICATION_NAME = "Random Widgets";
	public static final String SESSION_SERVER_HOST = "localhost";

}
//END OF FILE
//START OF FILE: src/replicatedwindow/serializableevent.java
package replicatedWindow;

import java.awt.AWTEvent;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.io.Serializable;

public interface SerializableEvent extends Serializable {
//	public boolean isLocal();

	public AWTEvent getAWTEvent();

	// source translated to the window of receiving window system
	public String getSource();
	
	public void setSource(String aComponentId);
	public void setAWTEvent(AWTEvent anEvent) ;
	public String paramString() ;
	public void setParamString(String aParamString);

//	public boolean isMouseEvent();
//
//	public boolean isKeyEvent();
//
//	public boolean isResizeEvent();
//
//	public boolean isMouseMovedEvent();
//
//	public boolean isMouseEnteredEvent();
//
//	public boolean isMouseExitedEvent();
//
//	public Dimension getSize();
//
//	public Point getLocation();
//
//	public int getX();
//
//	public int getY();
//
//	public long getGenerationTime();
//
//	public boolean isMousePressedEvent();
//
//	public boolean isMouseClickedEvent();
//
//	public boolean isMouseReleasedEvent();
}
//END OF FILE
//START OF FILE: src/replicatedwindow/staticcomponentregistry.java
// deprecated, around for compatibility
package replicatedWindow;

import java.awt.Component;
import java.awt.Container;
import java.util.ArrayList;
import java.util.List;

public class StaticComponentRegistry {
	static List<Component> components = new ArrayList();
	public static final int WTOOLKIT_ID = -2;
	public static final int GLOBAL_CURSOR_EVENT_ID = -3;

	public static void register(Component aComponent) {
		if (components.contains(aComponent))
			return;
		components.add(aComponent);
	}

	public static Component getComponent(int id) {
		if (id < 0 ||  id >= components.size() ) 
			return null;
		return components.get(id);
			
	}

	public static int getComponentId(Component aComponent) {
		return components.indexOf(aComponent);
	}
    public static void registerComponentTree(Component aComponent ) {
    	register(aComponent);
    	if (aComponent instanceof Container) {
    		Container container = (Container) aComponent;
    		Component[] components = container.getComponents();
    		for (Component aChild:components) {
    			registerComponentTree(aChild);    			
    		}
    	}
		
	}
}
//END OF FILE
//START OF FILE: src/replicatedwindow/widgettesterlauncher.java
package replicatedWindow;


import java.awt.Button;
import java.awt.Checkbox;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.TextArea;
import java.awt.TextField;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import util.awt.AGlassPaneRedispatcher;

public class WidgetTesterLauncher {
	public static void main(String[] args) {
		AnInputQueue.useAsEventQueue();

		createFrameWithWidgets("frame 1");
		createFrameWithWidgets("frame 2");
	}
	public static void createFrameWithWidgets(String theTitle) {
//		Frame frame = new Frame(theTitle);
//		Frame frame = new ATelePointerFrame(theTitle);
		JFrame frame = new JFrame(theTitle);

//		Frame frame = new ADelegateFrame(theTitle);
		
//		frame.setContentPane(glassPane);
		frame.setLayout(new GridLayout(5, 2));

		JTextField jTextField = new JTextField("JTextField: Edit me");
		JSlider slider = new JSlider();
		TextField textField = new TextField("Text Field: Edit me");
		Checkbox checkBox = new Checkbox(); // auto scrolled by OS with no events sent
		JCheckBox jCheckBox = new JCheckBox();
		Button button = new Button("Button: Press me");
		JButton jButton = new JButton("JButton: Press me");
		JTextArea jTextArea = new JTextArea ("JTextArea");
		TextArea textArea = new TextArea ("TextArea");
		String[] choices = {"Red", "Green", "Blue"};
		JComboBox jComboBox = new JComboBox(choices);
		JScrollPane jTextAreaScrollPane = new JScrollPane();
		jTextAreaScrollPane.setViewportView(jTextArea);


//		TextField textField = new ProcessingEventTextField("Edit me");

		frame.add(jTextField);
		frame.add(textField);
//		frame.add(jTextArea);
		frame.add(jTextAreaScrollPane);
		frame.add(textArea);
		frame.add(jButton);
		frame.add(button);
		frame.add(checkBox);
		frame.add(jCheckBox);
		frame.add(slider);
		frame.add(jComboBox);
//		frame.add(textField4);
//		new ACharacterDrawer(frame);
		frame.setSize(300, 300);
		frame.setVisible(true);
		// to be commented in later
//		
//		JComponent glassPane = new ATelePointerGlassPane(frame);
//
//		AGlassPaneRedispatcher redispatcher = new AGlassPaneRedispatcher(glassPane, frame);
//		frame.setGlassPane(glassPane);
//		glassPane.setVisible(true);
		putGlassPane(frame);

//		return frame;
	}
	protected static void putGlassPane(JFrame aFrame) {
		DelegatingTelepointerGlassPane aGlassPane = new ADelegatingTelePointerGlassPane(aFrame);
		aGlassPane.addPainter(new AnOvalGraphicsPainter(aGlassPane));
//		AGlassPaneRedispatcher redispatcher = new AGlassPaneRedispatcher(glassPane, aFrame);
//		aFrame.setGlassPane(glassPane);
//		glassPane.setVisible(true);
		
	}
}
//END OF FILE
//START OF FILE: src/replicatedwindow/jitter/alicejitteryreplicatedwindows.java
package replicatedWindow.jitter;

import replicatedWindow.AReplicatedWindowsComposerAndLauncher;
import replicatedWindow.AliceReplicatedWindows;
import replicatedWindow.CommunicatorBasedComposerAndLauncher;
import im.IMComposerAndLauncher;
import im.delay.p2p.CathyP2PIM;
import trace.im.IMTracerSetter;
import util.session.Communicator;
import util.trace.Tracer;

public class AliceJitteryReplicatedWindows extends AliceReplicatedWindows{
	public static final int DELAY_TO_CATHY = 1000;
	public static final int DELAY_VARIATION = 2000;


	public static void main (String[] args) {
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME,  APPLICATION_NAME,  Communicator.DIRECT};
//		Tracer.showInfo(true);
//		IMTracerSetter.traceIM();
		CommunicatorBasedComposerAndLauncher aCommunicatorBasedComposerAndLauncher = 
				new AReplicatedWindowsComposerAndLauncher();
		aCommunicatorBasedComposerAndLauncher.composeAndLaunch(launcherArgs);
		delayToCathy(aCommunicatorBasedComposerAndLauncher.getCommunicator());
	}
	public static void delayToCathy(Communicator aCommunicator) {
		aCommunicator.setMinimumDelayToPeer(CathyP2PIM.USER_NAME,  DELAY_TO_CATHY);
		aCommunicator.setDelayVariation(DELAY_VARIATION);		
	}

}
//END OF FILE
//START OF FILE: src/replicatedwindow/jitter/demoerofjitteryreplicatedwindows.java
package replicatedWindow.jitter;

import replicatedWindow.BobReplicatedWindows;
import replicatedWindow.CathyReplicatedWindows;
import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class DemoerOfJitteryReplicatedWindows {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {	
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceJitteryReplicatedWindows.class,
				BobReplicatedWindows.class,
				CathyReplicatedWindows.class				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/acontroldispatcher.java
package sasa.echoerAndIM;

import java.util.ArrayList;
import java.util.List;

import util.session.Communicator;

public class AControlDispatcher extends AnOutCoupledEchoer implements ControlDispatcher {	
	List<Vetoer> vetoers = new ArrayList();
	public AControlDispatcher(Communicator theCommunicator) {
		super(theCommunicator);		
	}
	void processInput(String theNextInput) {
		if (vetoed(theNextInput))
			return;
		 super.processInput(theNextInput);
	}	
	public void addVetoer(Vetoer theVetoer) {
		vetoers.add(theVetoer);		
	}
	public void removeVetoer(Vetoer theVetoer) {
		vetoers.remove(theVetoer);		
	}
	boolean vetoed(String theValue) {
		for (Vetoer vetoer:vetoers) {
			if (vetoer.veto(theValue)) return true;
		}
		return false;
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/amessage.java
package sasa.echoerAndIM;

import java.io.Serializable;

public class AMessage<DataType> implements Serializable, Message<DataType> {
	DataType messageData;
	public AMessage(DataType theData) {
		messageData = theData;
	}
	public DataType getData() {
		return messageData;
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/aremoteinput.java
package sasa.echoerAndIM;


public class ARemoteInput<DataType> extends AMessage<DataType> {
	public ARemoteInput (DataType theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/accesscontroller.java
package sasa.echoerAndIM;

public interface AccessController extends Vetoer {
	boolean canInput(String theUser);
	boolean canAdminister(String theUser);
	void addAdministrator(String newAdminsitrator);
	void addInputter(String newInputter);
	void addAdministratorLocal(String newAdminsitrator);
	void addInputterLocal(String newInputter);
	void setOwner(String theOwner);
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/aliceaccesscontrolledim.java
package sasa.echoerAndIM;

import im.AliceIM;
import sasa.echoerAndIM.AnAccessControlledIMComposerAndLauncher;
import sasa.echoerAndIM.AnIMComposerAndLauncher;
import trace.im.aware.AwareIMTracerSetter;
import util.trace.TraceableInfo;
import util.trace.Tracer;

public class AliceAccessControlledIM extends AliceIM{	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		TraceableInfo.setPrintSource(true);
		AwareIMTracerSetter.traceAwareIM();
		String[] launcherArgs = {SESSION_SERVER_HOST, SESSION_NAME, USER_NAME, AnIMComposerAndLauncher.DIRECT};
		(new AnAccessControlledIMComposerAndLauncher()).composeAndLaunch(launcherArgs);
	}	
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anaccesscontrolledimcomposerandlauncher.java
package sasa.echoerAndIM;

import old.echoerAndIM.AControlDispatcher;
import old.echoerAndIM.AccessController;
import old.echoerAndIM.AnAccessController;
import old.echoerAndIM.AnAccessReceiver;
import old.echoerAndIM.ControlDispatcher;
import util.session.Communicator;
import util.session.ReceivedMessageListener;
import bus.uigen.ObjectEditor;

public class AnAccessControlledIMComposerAndLauncher extends AnAwareIMComposerAndLauncher {	
	static String APPLICATION_NAME = "Access Controlled IM";	
//	public static void main (String[] args) {
//		Communicator communicator = createCommunicator(args, APPLICATION_NAME);		
//		ControlDispatcher controlDispatcher =  new AControlDispatcher(communicator);
//		addAwarenessAndInCoupler(communicator, controlDispatcher);
//		AccessController accessController = new AnAccessController(communicator);		
//		ReceivedMessageListener accessReceiver = new AnAccessReceiver(communicator, accessController);
//		communicator.addReceivedMessageListener(accessReceiver);
//		controlDispatcher.addVetoer(accessController);
//		communicator.join();
//		ObjectEditor.edit(accessController);
//		controlDispatcher.doInput();		
//	}
	protected Echoer compose() {
		Echoer outCouplerAndEchoer =  super.compose();
		ControlDispatcher controlDispatcher =  new AControlDispatcher(communicator);

		return outCouplerAndEchoer;
	}
	public void composeAndLaunch(String[] args) {
		Communicator communicator = createCommunicator(args, APPLICATION_NAME);		
		ControlDispatcher controlDispatcher =  new AControlDispatcher(communicator);
		addAwareness(communicator);
		AccessController accessController = new AnAccessController(communicator);		
		ReceivedMessageListener accessReceiver = new AnAccessReceiver(communicator, accessController);
		communicator.addReceivedMessageListener(accessReceiver);
		controlDispatcher.addVetoer(accessController);
		communicator.join();
		ObjectEditor.edit(accessController);
		controlDispatcher.doInput();		
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anaccesscontroller.java
package sasa.echoerAndIM;

import java.util.ArrayList;
import java.util.List;

import javax.swing.JOptionPane;

import util.session.Communicator;

public class AnAccessController implements AccessController {
	Communicator communicator;
	List<String> inputers = new ArrayList();
	List<String> administrators = new ArrayList();
	String owner;
	public AnAccessController(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	public boolean hasOwnership(String theUser) {
		return theUser.equals(owner);
	}
	public void setOwner(String theOwner) {
		JOptionPane.showMessageDialog(null, theOwner + " is the owner");
		owner = theOwner;
	}
	public boolean canInput(String theUser) {
		return  inputers.contains(theUser);
	}
	public void addInputterLocal(String newInputer) {
		inputers.add(newInputer);
		JOptionPane.showMessageDialog(null, newInputer + " can input");
	}
	public void addInputter(String newInputer) {
		if (!canAdminister(communicator.getClientName())) {
				JOptionPane.showMessageDialog(null, communicator.getClientName() +
						" does not have authorization to administer");
			return;
		}
		communicator.toAll(new AnInputAuthorization(newInputer));
	}
	public boolean canAdminister(String theUser) {
		return administrators.contains(theUser);
	}
	public void addAdministratorLocal(String newAdminsitrator) {
		administrators.add(newAdminsitrator);
		JOptionPane.showMessageDialog(null, newAdminsitrator + " can administer");
	}
	public void addAdministrator(String newAdminsitrator) {
		if (!hasOwnership(communicator.getClientName())) {
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" is not owner");
	        return;
	    }
		communicator.toAll(new AnAdministratorAuthorization(newAdminsitrator));
	}
	public boolean veto(Object theInput) {
		boolean retVal = !canInput (communicator.getClientName());
		if (retVal) {
			JOptionPane.showMessageDialog(null, communicator.getClientName() +
					" does not have authorization to input");
		}
		return retVal;
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anaccessreceiver.java
package sasa.echoerAndIM;

import java.util.Collection;

import util.session.Communicator;
import util.session.ReceivedMessageListener;

public class AnAccessReceiver implements ReceivedMessageListener {
	Communicator communicator;
	AccessController accessController;
	public AnAccessReceiver(Communicator theCommunicator,
			AccessController theAccessController) {
		communicator = theCommunicator;
		accessController = theAccessController;
	}
	public void clientJoined(
			String userName, String theApplicationName, 
			String theSessionName, boolean newSession, 
			boolean newApplication, Collection<String> allUsers) {
		if (newApplication) {
			accessController.setOwner(userName);
			accessController.addAdministratorLocal(userName);
			accessController.addInputterLocal(userName);
		}
	}
	public void objectReceived(Object message, String sourceName) {
		if (message instanceof AnInputAuthorization)
			processInputAuthorization((Message<String>) message);
		else if (message instanceof AnAdministratorAuthorization)
			processAdminAuthorization((Message<String>) message);
	}
	void processInputAuthorization(Message<String> message) {
		accessController.addInputterLocal(message.getData());
	}
	void processAdminAuthorization(Message<String> message) {
		accessController.addAdministratorLocal(message.getData());
	}
	public void clientLeft(String userName, String theApplicationName) {}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anadministratorauthorization.java
package sasa.echoerAndIM;

public class AnAdministratorAuthorization extends AMessage<String> {
	public AnAdministratorAuthorization(String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anawareimcomposerandlauncher.java
package sasa.echoerAndIM;

import im.aware.ASessionAwarenessProvider;
import util.session.Communicator;
import util.session.SessionMessageListener;

public class AnAwareIMComposerAndLauncher extends AnIMComposerAndLauncher{
	
	public static void main (String[] args) {
//		Communicator communicator = createCommunicator(args, APPLICATION_NAME);
//		Echoer outCouplerAndEchoer =  new AnOutCoupledEchoer(communicator);
//		addAwarenessAndInCoupler(communicator, outCouplerAndEchoer);
//		communicator.join();
//		outCouplerAndEchoer.doInput();
		(new AnAwareIMComposerAndLauncher()).composeAndLaunch(args);
	}
	
	
	
	protected Echoer compose() {
		Echoer echoer =  super.compose();
		addAwareness(communicator);
		return echoer;
	}
	
//	public void composeAndLaunch(String[] args) {
//		communicator = createCommunicator(args, getApplicationName());
//		Echoer outCouplerAndEchoer = compose(); 
//				
////				new AnOutCoupledEchoer(communicator);
////		addAwarenessAndInCoupler(communicator, outCouplerAndEchoer);
////		addCollaborationFunctionality();
//		communicator.join();
//		outCouplerAndEchoer.doInput();	
//	}
//	
//	public  void checkArgs(String[] args) {
//		if (args.length < 3) {
//			System.out.println("Please supply server host name, session name, and user name as main arguments");
//			System.exit(-1);
//		}
//	}
//	public  Communicator createCommunicator(String args[], String applicationName) {
//		checkArgs(args);
//		if (args.length == 4) {
//			if (args[3].equalsIgnoreCase(DIRECT))
//				ACommunicatorSelector.selectDirectCommunicator();
//			else if (args[3].equalsIgnoreCase(RELAYED))
//				ACommunicatorSelector.selectRelayerCommunicator();				
//		}
////		ACommunicatorSelector.selectDirectCommunicator();
//		CommunicatorCreator communicatorFactory = ACommunicatorSelector.getCommunicatorFactory();
//		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
//	}
	public  void addAwareness(Communicator communicator) {
//		PeerMessageListener remoteInputEchoer = new AnInCoupler(echoerAndLogger);
		SessionMessageListener sessionAwarenesManager = new ASessionAwarenessProvider();
//		communicator.addPeerMessageListener(remoteInputEchoer);
		communicator.addSessionMessageListener(sessionAwarenesManager);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anechoer.java
package sasa.echoerAndIM;

import java.util.ArrayList;
import java.util.List;

import util.misc.Console;

public class AnEchoer implements Echoer {
	static String QUIT = "quit";
	static String HISTORY = "history";
	List<String> history = new ArrayList();
	public void doInput() {
		for (;;) {
			System.out.println("Please enter an input line or " +
				     QUIT + " or " + HISTORY);
			String nextInput = Console.readString();
			if (nextInput.equals(QUIT))
				break;
			else if (nextInput.equals(HISTORY))
				printHistory();
			else
			    processInput(nextInput);
		}
	}
	void processInput(String theNextInput) {
		System.out.println("Input:" + theNextInput);
		addToHistory(theNextInput);
	}
	public synchronized void addToHistory(String input) {
		history.add(input);
	}
	public synchronized void printHistory() {
		for (String input:history) {
			System.out.print(input + ":");
		}
		System.out.println();
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anechoerlauncher.java
package sasa.echoerAndIM;

public class AnEchoerLauncher {
	public static void main (String[] args) {
		Echoer echoer = new AnEchoer();
		echoer.doInput();
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/animcomposerandlauncher.java
package sasa.echoerAndIM;

import util.session.CommunicatorSelector;
import util.session.Communicator;
import util.session.CommunicatorCreator;
import util.session.PeerMessageListener;

public class AnIMComposerAndLauncher {
	public static final String APPLICATION_NAME = "IM";
	public static final String DIRECT = "P2P";
	public static final String RELAYED = "Relayed";
	Communicator communicator;
	public static void main (String[] args) {
		(new AnIMComposerAndLauncher()).composeAndLaunch(args);
	}	
	protected String getApplicationName() {
		return APPLICATION_NAME;
	}	
	protected Echoer compose() {
		Echoer outCouplerAndEchoer =  new AnOutCoupledEchoer(communicator);
		addInCoupler(communicator, outCouplerAndEchoer);
		return outCouplerAndEchoer;
	}	
	public void composeAndLaunch(String[] args) {
		communicator = createCommunicator(args, getApplicationName());
		Echoer outCouplerAndEchoer = compose(); 
		communicator.join();
		outCouplerAndEchoer.doInput();	
	}
	
	public  void checkArgs(String[] args) {
		if (args.length < 3) {
			System.out.println("Please supply server host name, session name, and user name as main arguments");
			System.exit(-1);
		}
	}
	public  Communicator createCommunicator(String args[], String applicationName) {
		checkArgs(args);
		if (args.length == 4) {
			if (args[3].equalsIgnoreCase(DIRECT))
				CommunicatorSelector.selectDirectCommunicator();
			else if (args[3].equalsIgnoreCase(RELAYED))
				CommunicatorSelector.selectRelayerCommunicator();				
		}
		CommunicatorCreator communicatorFactory = CommunicatorSelector.getCommunicatorFactory();
		return  communicatorFactory.getCommunicator(args[0],args[1],args[2], applicationName);
	}
	public  void addInCoupler(Communicator communicator, Echoer echoerAndLogger) {
		PeerMessageListener remoteInputEchoer = new AnInCoupler(echoerAndLogger);
		communicator.addPeerMessageListener(remoteInputEchoer);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anincoupler.java
package sasa.echoerAndIM;

import util.session.PeerMessageListener;

public class AnInCoupler implements PeerMessageListener {
	Echoer echoer;
	public AnInCoupler(Echoer theEchoer) {
		echoer = theEchoer;
	}
	public void objectReceived(Object message, String userName) {
		if (message instanceof ARemoteInput)
			processRemoteInput((ARemoteInput) message, userName);
	}
	void processRemoteInput (ARemoteInput remoteInput, String userName) {
		System.out.println("Remote Input:" + remoteInput.getData() + " from:" + userName);
		echoer.addToHistory((String) remoteInput.getData());
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/aninputauthorization.java
package sasa.echoerAndIM;

public class AnInputAuthorization extends AMessage<String> {
	public AnInputAuthorization(String theUserName) {
		super(theUserName);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anobservablehistory.java
package sasa.echoerAndIM;

import java.util.ArrayList;
import java.util.List;

import echo.modular.AHistory;

public class AnObservableHistory<ElementType>  extends AHistory <ElementType>implements ObservableHistory<ElementType> {
//	static String QUIT = "quit";
//	static String HISTORY = "history";
//	List<ElementType> history = new ArrayList();
	List<HistoryObserver<ElementType>> observers = new ArrayList();
//	public void doInput() {
//		for (;;) {
//			System.out.println("Please enter an input line or " +
//				     QUIT + " or " + HISTORY);
//			String nextInput = Console.readString();
//			if (nextInput.equals(QUIT))
//				break;
//			else if (nextInput.equals(HISTORY))
//				printHistory();
//			else
//			    processInput(nextInput);
//		}
//	}
//	void processInput(String theNextInput) {
////		System.out.println("Input:" + theNextInput);
//		addToHistory(theNextInput);
//	}
	public synchronized void add(int index, ElementType input) {
		super.add(index, input);
		notifyObservers(input);
	}
//	public synchronized void printHistory() {
//		for (String input:history) {
//			System.out.print(input + ":");
//		}
//		System.out.println();
//	}
	@Override
	public void addObserver(HistoryObserver<ElementType> anObserver) {
		observers.add(anObserver);
	}
	
	public void notifyObservers(ElementType newValue) {
		for (HistoryObserver<ElementType> observer:observers)
			observer.elementAdded(newValue);
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/anoutcoupledechoer.java
package sasa.echoerAndIM;

import util.session.Communicator;

public class AnOutCoupledEchoer extends AnEchoer {
	Communicator communicator;
	public AnOutCoupledEchoer(Communicator theCommunicator) {
		communicator = theCommunicator;
	}
	void processInput(String theNextInput) {
		super.processInput(theNextInput);
		communicator.toOthers(new ARemoteInput(theNextInput));
	}
	public void doInput() {
		super.doInput();
		communicator.leave();
	}
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/controldispatcher.java
package sasa.echoerAndIM;

public interface ControlDispatcher extends Echoer {
	public void addVetoer(Vetoer theVetoer);
	public void removeVetoer(Vetoer theVetoer);
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/echoer.java
package sasa.echoerAndIM;

public interface Echoer {
	public void doInput();
	public void addToHistory(String input);
	public void printHistory();
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/historyobserver.java
package sasa.echoerAndIM;

public interface HistoryObserver<ElementType> {
	void elementAdded(ElementType newValue);

}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/imdemoer.java
package sasa.echoerAndIM;

import im.AliceIM;
import im.BobIM;
import im.SessionManagerServerStarter;
import bus.uigen.models.MainClassLaunchingUtility;

public class IMDemoer {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
		Class[] classes = {
				SessionManagerServerStarter.class,
				AliceIM.class,
				BobIM.class,
				

				
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/message.java
package sasa.echoerAndIM;

public interface Message<DataType> {
	public DataType getData();
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/observablehistory.java
package sasa.echoerAndIM;

import echo.modular.History;

public interface ObservableHistory<ElementType> extends History<ElementType>{
//	 void add(ElementType input) ;
	 void addObserver(HistoryObserver<ElementType> anObserver);
}
//END OF FILE
//START OF FILE: src/sasa/echoerandim/vetoer.java
package sasa.echoerAndIM;

public interface Vetoer<ValueType> {
	boolean veto(ValueType theInput);
}
//END OF FILE
//START OF FILE: src/trace/causal/causallisteditinfo.java
package trace.causal;

import trace.echo.modular.ListEditInfo;
import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class CausalListEditInfo extends ProcessInfo {
	UserOTTimeStampInfo otTimeStamp;
	ListEditInfo listEdit;
//	String processName;
	public CausalListEditInfo(String aMessage, String aProcessName,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
//		processName = aProcessName;
		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}
	
	public CausalListEditInfo(ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp) {
		this("", "", aListEdit, anOTTimeStamp, null);
	}

	public CausalListEditInfo(String aMessage, ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp, ProcessInfo aProcessInfo) {
//		super(aMessage, "", aProcessInfo);
		super(aMessage, aProcessInfo);

		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}

	public CausalListEditInfo(String aMessage, CausalListEditInfo anOTListEdit) {
		this (aMessage, anOTListEdit.getListEdit(), anOTListEdit.getUserOTTimeStamp(), anOTListEdit);
		
	}
	public static String toLocalInfoToString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return aListEdit.toLocalInfoToString() + " "
				+ anOTTimeStamp.alternativeToString() ;
		
	}
	public static String toString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return toString(aProcessName) + " " + toLocalInfoToString(aProcessName, aListEdit, anOTTimeStamp);
//				"OTEdit(" + 
//				aListEdit.toLocalInfoToString() + " "
//				+ anOTTimeStamp.alternativeToString() ;
				
//				+ ")";

	}
	
	public static CausalListEditInfo toTraceable(String aMessage) {
//		ProcessInfo aProcessInfo;
//		try {
		ProcessInfo aProcessInfo = ProcessInfo.toTraceable(aMessage);
//		} catch (Exception e) {
//			System.out.println(e);
//			aProcessInfo = null;
//		}
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new CausalListEditInfo(aMessage, aListEditInfo, aTimeStampInfo, aProcessInfo);
		
	}
	

	public String alternativeToString() {
		return toString(processName, listEdit, otTimeStamp);
	}
	public String toLocalInfoToString() {
		return toLocalInfoToString(processName, listEdit, otTimeStamp);
	}


	public UserOTTimeStampInfo getUserOTTimeStamp() {
		return otTimeStamp;
	}

	public ListEditInfo getListEdit() {
		return listEdit;
	}
	
	public String getProcessName() {
		return processName;
	}

}
//END OF FILE
//START OF FILE: src/trace/causal/initialvectortimestampcreated.java
package trace.causal;

import java.util.Map;

public class InitialVectorTimeStampCreated extends VectorTimeStampInfo{

	public InitialVectorTimeStampCreated(String aMessage, 
			String aUserName, 
			Map<String, Integer> aUserToCount,
			Object aFinder) {
		super(aMessage, aUserName, aLocalCount, aRemoteCount, isServer, aFinder);
	}
	public static InitialVectorTimeStampCreated newCase(String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			boolean anIsServer,
			Object aFinder) {
		String aMessage = "OT Time Stamp Created:" + toString(aUserName, aLocalCount, aRemoteCount, anIsServer);
		InitialVectorTimeStampCreated retVal = new InitialVectorTimeStampCreated(aMessage, aUserName, aLocalCount, aRemoteCount, anIsServer, aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/causal/otlisteditbuffered.java
package trace.causal;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditBuffered extends CausalListEditInfo{

	public OTListEditBuffered(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public OTListEditBuffered(String aMessage, 
			CausalListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditBuffered toTraceable(String aMessage) {
		CausalListEditInfo aSuperClassInfo = CausalListEditInfo.toTraceable(aMessage);
		return new OTListEditBuffered(aMessage, 
				aSuperClassInfo);		
	}
	public static OTListEditBuffered newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditBuffered retVal = new OTListEditBuffered(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditBuffered newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditBuffered newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/causal/otlisteditinfo.java
package trace.causal;

import trace.echo.modular.ListEditInfo;
import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class OTListEditInfo extends ProcessInfo {
	UserOTTimeStampInfo otTimeStamp;
	ListEditInfo listEdit;
//	String processName;
	public OTListEditInfo(String aMessage, String aProcessName,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
//		processName = aProcessName;
		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}
	
	public OTListEditInfo(ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp) {
		this("", "", aListEdit, anOTTimeStamp, null);
	}

	public OTListEditInfo(String aMessage, ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp, ProcessInfo aProcessInfo) {
//		super(aMessage, "", aProcessInfo);
		super(aMessage, aProcessInfo);

		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}

	public OTListEditInfo(String aMessage, OTListEditInfo anOTListEdit) {
		this (aMessage, anOTListEdit.getListEdit(), anOTListEdit.getUserOTTimeStamp(), anOTListEdit);
		
	}
	public static String toLocalInfoToString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return aListEdit.toLocalInfoToString() + " "
				+ anOTTimeStamp.alternativeToString() ;
		
	}
	public static String toString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return toString(aProcessName) + " " + toLocalInfoToString(aProcessName, aListEdit, anOTTimeStamp);
//				"OTEdit(" + 
//				aListEdit.toLocalInfoToString() + " "
//				+ anOTTimeStamp.alternativeToString() ;
				
//				+ ")";

	}
	
	public static OTListEditInfo toTraceable(String aMessage) {
//		ProcessInfo aProcessInfo;
//		try {
		ProcessInfo aProcessInfo = ProcessInfo.toTraceable(aMessage);
//		} catch (Exception e) {
//			System.out.println(e);
//			aProcessInfo = null;
//		}
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new OTListEditInfo(aMessage, aListEditInfo, aTimeStampInfo, aProcessInfo);
		
	}
	

	public String alternativeToString() {
		return toString(processName, listEdit, otTimeStamp);
	}
	public String toLocalInfoToString() {
		return toLocalInfoToString(processName, listEdit, otTimeStamp);
	}


	public UserOTTimeStampInfo getUserOTTimeStamp() {
		return otTimeStamp;
	}

	public ListEditInfo getListEdit() {
		return listEdit;
	}
	
	public String getProcessName() {
		return processName;
	}

}
//END OF FILE
//START OF FILE: src/trace/causal/vectortimestampinfo.java
package trace.causal;

import java.util.HashMap;
import java.util.Map;

import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class VectorTimeStampInfo extends ProcessInfo {
	
	Map<String, Integer> userToCount = new HashMap();


	public VectorTimeStampInfo
			(String aMessage, 
			String aProcessName,
			Map<String, Integer> aUserToCount,
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
		userToCount = aUserToCount;
	}
	
	public Map<String, Integer> getUserToCount() {
		return userToCount;
	}
	
	public static String to

//	public boolean isServer() {
//		return isServer;
//	}
	public static String toString(
			String aUserName, 
			int aLocalCount,
			int aRemoteCount, 
			boolean anIsServer
			) {
		return aUserName  + 
				 "[local: " + aLocalCount + ", remote: " + aRemoteCount + "]" ;
//				+ "(" +	(anIsServer?"Server": "Client") + ")";
		
	}

	public String alternativeToString() {
		getArgOfCompositeDescriptor(aTraceLine, aDescriptor)
		return toString(userName, localCount, remoteCount, isServer);
	}

}
//END OF FILE
//START OF FILE: src/trace/echo/echotracechecker.java
package trace.echo;

import im.AnIMDemoerAndTester;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import echo.monolithic.MonolithicEchoer;
import bus.uigen.query.AnObjectQuery;
import bus.uigen.query.ObjectQuery;
import bus.uigen.trace.TraceUtility;
import bus.uigen.trace.query.QueryTargetFound;
import bus.uigen.trace.query.QueryTargetMissing;
import util.trace.Traceable;
import util.trace.TraceableLog;
import util.trace.Tracer;
import util.trace.console.ConsoleInput;
import util.trace.console.ConsoleOutput;
import util.trace.query.ClassInstanceFound;
import util.trace.query.ClassInstanceMissing;
import static bus.uigen.trace.TraceUtility.*;
import static bus.uigen.query.QueryUtility.*;


public class EchoTraceChecker {
	static Class[] expectedClasses = {
			ConsoleOutput.class,
	};
	
	public static Class[] expectedClasses() {
		return expectedClasses;
	}
	
	public static boolean checkEchoer(List<Traceable> aTraceableList) {
		Tracer.setKeywordPrintStatus(ClassInstanceMissing.class, true);
		Tracer.setKeywordPrintStatus(ClassInstanceFound.class, true);
		Tracer.setKeywordPrintStatus(QueryTargetFound.class, true);
		Tracer.setKeywordPrintStatus(QueryTargetMissing.class, true);
		
//		Class[] anExpectedClasses = {
//				ConsoleInput.class,				
//				ConsoleOutput.class,
//		};
		// the old way
//		List<Integer> anIndexList = indicesOf(aTraceableList, anExpectedClasses, false);
//		List<Integer> anOutOfOrderList = indicesOfOutOfOrderIndices(/*anExpectedClasses,*/ anIndexList);
//		if (anOutOfOrderList.size() != 0) {
//			System.out.println("Out of order indices:" + anOutOfOrderList);
//			return false;
//		}
//
//		List<Integer> anInvalidIndices = indicesOfInvalidIndices(anIndexList);
//		if (anInvalidIndices.size() != 0) {
//			System.out.println("Missing events:" + missingClasses(anExpectedClasses, anInvalidIndices));
//			return false;
//		}
		// the new way
		List<Integer> anIndexList = indicesOf(aTraceableList, expectedClasses, true);
		if (!valid(anIndexList))
			return false;
//		List<Integer> anOutOfOrderList = indicesOfOutOfOrderIndices(/*anExpectedClasses,*/ anIndexList);
//		if (anOutOfOrderList.size() != 0) {
//			System.out.println("Out of order indices:" + anOutOfOrderList);
//			return false;
//		}
//
//		List<Integer> anInvalidIndices = indicesOfInvalidIndices(anIndexList);
//		if (anInvalidIndices.size() != 0) {
//			System.out.println("Missing events:" + missingClasses(anExpectedClasses, anInvalidIndices));
//			return false;
//		}
		ConsoleInput anInput = (ConsoleInput) aTraceableList.get(anIndexList.get(0));
		ConsoleOutput anOutput = (ConsoleOutput) aTraceableList.get(anIndexList.get(1));
		return anOutput.getOutput().toLowerCase().contains(anInput.getInput().toLowerCase());		
		
	}
	public static boolean compareInputOutSequences(
			List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
//		Class[] anExpectedClasses = {ConsoleOutput.class};
//		List<Traceable> aFilteredTest = TraceUtility.filterTraceList(aTestTraceableList, anExpectedClasses);		
//		List<Traceable> aFilteredCorrect = TraceUtility.filterTraceList(aCorrectTraceableList, anExpectedClasses);
//		
		TraceableLog traceableLog = TraceUtility.startNewTrace();
//		String[] aProperties = {"Output"};
		
//		ObjectQuery[] objectQueries = traceablesToQueries(aCorrectTraceableList);
//		boolean retVal = inOrder(aFilteredTest, objectQueries, anExpe);
		boolean retVal = inOrder(aTestTraceableList, aCorrectTraceableList, expectedClasses, true);
		TraceUtility.stopExistingTrace(traceableLog);
		return retVal;		
	}

	public static boolean matchInputOutSequences(List<Traceable> aTraceableList) {
		Integer aStartIndex = 0;
		boolean retVal = true;
		while (true) {
			Integer anInputIndex = indexOf(aTraceableList, ConsoleInput.class, aStartIndex, new ArrayList());
			aStartIndex = anInputIndex + 2; // at one input and output occured after this

			if (anInputIndex < 0) 
//				return true; 
				return retVal; 
			ConsoleInput aConsoleInput = (ConsoleInput) aTraceableList.get(anInputIndex);
			// ignore history and quit commands
			if (!MonolithicEchoer.isInput(aConsoleInput.getInput())) {
				continue;
			}
			// start getting trace of comparison result traces
			TraceableLog traceableLog = TraceUtility.startNewTrace();
			boolean checkInputEcho = checkInputEcho(aTraceableList, aConsoleInput, anInputIndex);
			TraceUtility.stopExistingTrace(traceableLog);
			// stop getting trace of comparisons
			// does not seem we do anyting with traceable log
			if (!checkInputEcho ) {
				Tracer.info("Did not find  echo for input:" + aConsoleInput.getInput());
				 retVal = false;
//				return false;
			}
//			Tracer.info("Fouund echo for input:" + aConsoleInput.getInput());

//			aStartIndex = anInputIndex + 2; // at one input and output occured after this
		}
			
		
	}

	
	public static boolean checkInputEcho(List<Traceable> aTraceableList, ConsoleInput anInput, int anInputIndex ) {
//		Class[] anExpectedClasses = {
//				ConsoleOutput.class,
//		};
		Map<String, Object> propertyToValue = new HashMap();
		propertyToValue.put(ConsoleOutput.OUTPUT, AnIMDemoerAndTester.echoOf(anInput.getInput()));
		
		return inOrder(aTraceableList, expectedClasses, propertyToValue, anInputIndex + 1, true);
		
	}

	
	
	

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/echotracersetter.java
package trace.echo.modular;

import util.trace.ImplicitKeywordKind;
import util.trace.MessagePrefixKind;
import util.trace.Traceable;
import util.trace.TraceableInfo;
import util.trace.Tracer;
import util.trace.console.ConsoleError;
import util.trace.console.ConsoleInput;
import util.trace.console.ConsoleOutput;
import util.trace.console.ConsoleTraceSetter;
import util.trace.session.SessionTracerSetter;

public class EchoTracerSetter {
	
	public static void traceEchoer() {
//		Tracer.showInfo(true);
//		TraceableInfo.setPrintSource(true);
//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
		Tracer.showInfo(true);
//		TraceableInfo.setPrintSource(true);
//		Traceable.setPrintTime(false);
//		Traceable.setPrintThread(true);
//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
//		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);

		EchoTracerSetter.setTraceParameters();
		setEchoerPrintStatus();		
	}
	
	public static void setTraceParameters() {
		TraceableInfo.setPrintSource(true);
		Traceable.setPrintTime(false);
		Traceable.setPrintThread(true);
		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
	}
	
	public static void setEchoerPrintStatus() {
//		TraceableInfo.setPrintSource(true);
//		Traceable.setPrintTime(false);
//		Traceable.setPrintThread(true);
//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
//		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
//		SessionTracerSetter.setSessionPrintStatus();
//		ConsoleTraceSetter.traceConsole();	// needed for Echo Tracer
//		ConsoleTraceSetter.setConsolePrintStatus();	// needed for Echo Tracer

//		Tracer.setImplicitPrintKeywordKind(ImplicitKeywordKind.OBJECT_CLASS_NAME);
		Tracer.setKeywordPrintStatus(ListEditInput.class, true);
		Tracer.setKeywordPrintStatus(ListEditNotified.class, true);
		Tracer.setKeywordPrintStatus(ListEditObserved.class, true);
		Tracer.setKeywordPrintStatus(ListEditMade.class, true);
//		Tracer.setKeywordPrintStatus(ConsoleOutput.class, true);
//		Tracer.setKeywordPrintStatus(ConsoleError.class, true);
//		Tracer.setKeywordPrintStatus(ConsoleInput.class, true);



//		Tracer.setKeywordPrintStatus(MessageInSendingQueue.class, true);
//		Tracer.setKeywordPrintStatus(SentMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(MessageSent.class, true);
//		Tracer.setKeywordPrintStatus(SendMessageRequest.class, true);
//		Tracer.setKeywordPrintStatus(MessageReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageRetrievedFromReceivingQueue.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);





	}

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/listeditinfo.java
package trace.echo.modular;
import java.util.Arrays;
import java.util.List;

import im.OperationName;
import util.trace.Traceable;
import util.trace.TraceableInfo;
public class ListEditInfo extends TraceableInfo {
	protected OperationName operationName;	
	protected int index;
	protected Object element;
	public static final String LIST_EDIT = "ListEdit";
	public static String[] listEditEqualPropertiesArray = {"OperationName", "Index", "Element"};
//	public static List<String> listEditEqualPropertiesList = Arrays.asList(listEditEqualPropertiesArray);

	public ListEditInfo(String aMessage, OperationName aName, int anIndex, Object anElement, Object aFinder) {
		super(aMessage,  aFinder);
		this.operationName = aName;
		this.index = anIndex;
		this.element = anElement;
	}
	protected void setEqualPropertiesList() {
		super.setEqualPropertiesList();
//		String[] listEditEqualPropertiesArray = {"OperationName", "Index", "Element"};

//		consoleEqualPropertiesArray = new String[]{"Output"};
		equalPropertiesList.addAll(Arrays.asList(listEditEqualPropertiesArray));
//		equalPropertiesList.addAll(listEditEqualPropertiesList);

		
//		equalPropertiesList = Arrays.asList(equalPropertiesArray);

	}
	
	
	public ListEditInfo(OperationName aName, int anIndex, Object anElement) {
		this("", aName, anIndex, anElement, (Object) null); 
		
	}
	public ListEditInfo(String aMessage, 
			OperationName aName, 
			int anIndex, 
			Object anElement,
			Traceable aTraceable
//			String aProcessName,			
//			Long aTimeStamp,
//			String aThreadName,
//			Object aFinder
			) {
		super(aMessage, aTraceable);
		this.operationName = aName;
		this.index = anIndex;
		this.element = anElement;
	}
	public ListEditInfo(String aMessage, 
			ListEditInfo aListEditInfo
//			String aProcessName,			
//			Long aTimeStamp,
//			String aThreadName,
//			Object aFinder
			) {
		this(aMessage, 
				aListEditInfo.getOperationName(),
				aListEditInfo.getIndex(),
				aListEditInfo.getElement(), 
//				getOperationName(aMessage), 
//				
//				getIndex(
//						getOperationArgs(aMessage, getOperationName(aMessage).toString() )),
//				getElement(
//						getOperationArgs(aMessage, getOperationName(aMessage).toString() )),

				aListEditInfo);
	}
	
	public static ListEditInfo toTraceable (String aMessage) {
		Traceable aTraceable = TraceableInfo.toTraceable(aMessage);
		OperationName anOperationName = getOperationName(aMessage);
		List<String> anOperationArgs = getOperationArgs(aMessage, anOperationName.toString());
		Integer anIndex = getIndex(anOperationArgs);
		String anElement = getElement(anOperationArgs);
		return new ListEditInfo(aMessage, anOperationName, anIndex, anElement, aTraceable);
				
	}
	
	public static String getListEdit(String aMessage) {
		return getArgOfCompositeDescriptor(aMessage, LIST_EDIT);
	}
	
	public static OperationName getOperationName(String aMessage) {
		String aListEdit = getListEdit(aMessage);
		aListEdit = aListEdit.trim();
		int aNameEndIndex = aListEdit.indexOf("(");
		String aName = aListEdit.substring(0, aNameEndIndex);
		return OperationName.fromString(aName);
	}
	
	public static List<String> getOperationArgs(String aMessage, String anOperationName) {
		return getArgs(aMessage, anOperationName);
	}
	
	public static Integer getIndex(List<String> anArgs) {
		return Integer.parseInt(anArgs.get(0));		
	}
	
	public static String getElement(List<String> anArgs) {
		return anArgs.get(1);
	}
	
	public OperationName getOperationName() {
		return operationName;
	}
	public int getIndex() {
		return index;
	}
	public Object getElement() {
		return element;
	}
	public static String toString(OperationName name, int anIndex, Object anElement) {
		return toString(System.currentTimeMillis()) +
				" " + LIST_EDIT + "_" +
				name + ("(") + anIndex + "," + anElement
			+ ")";
				
	}
	public static String toLocalInfoToString(OperationName name, int anIndex, Object anElement) {
		return 
				LIST_EDIT + "_" +
				name + ("(") + anIndex + ", " + anElement
			+ ")";
				
	}
	public String toLocalInfoToString() {
		return toLocalInfoToString(operationName, index, element); 
	}
	public String alternativeToString() {
//		return "ListEdit(" +  toString(operationName, index, element) + ")";
		return 
//				LIST_EDIT + "(" +
//		"ListEdit(" +  
		
		toString(operationName, index, element); 
//		")";
	}
	
	public boolean equalsEdit(ListEditInfo other) {
		return operationName.equals(other.getOperationName()) &&
				index == other.getIndex() &&
				element.equals(other.getElement());
	}
	
}
//END OF FILE
//START OF FILE: src/trace/echo/modular/listeditinput.java
package trace.echo.modular;

import im.OperationName;

public class ListEditInput extends ListEditInfo{

	public ListEditInput(String aMessage, OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {
		super(aMessage, anOperationName, anIndex, anElement, aFinder);
	}
	
	public ListEditInput(String aMessage, ListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditInput toTraceable (String aMessage) {
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		return new ListEditInput(aMessage, aListEditInfo);
	}
	public static ListEditInput newCase(
			OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {			
		String aMessage = toString(anOperationName, anIndex, anElement);
		ListEditInput retVal = new ListEditInput(aMessage, anOperationName, anIndex, anElement,aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/listeditmade.java
package trace.echo.modular;

import im.OperationName;

public class ListEditMade extends ListEditInfo{

	public ListEditMade(String aMessage, OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {
		super(aMessage, anOperationName, anIndex, anElement, aFinder);
	}
	public ListEditMade(String aMessage, ListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditMade toTraceable (String aMessage) {
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		return new ListEditMade(aMessage, aListEditInfo);
	}
	public static ListEditMade newCase(
			OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {			
		String aMessage = toString(anOperationName, anIndex, anElement);
		ListEditMade retVal = new ListEditMade(aMessage, anOperationName, anIndex, anElement,aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/listeditnotified.java
package trace.echo.modular;

import im.OperationName;

public class ListEditNotified extends ListEditInfo{

	public ListEditNotified(String aMessage, OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {
		super(aMessage, anOperationName, anIndex, anElement, aFinder);
	}
	public ListEditNotified(String aMessage, ListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditNotified toTraceable (String aMessage) {
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		return new ListEditNotified(aMessage, aListEditInfo);
	}
	public static ListEditNotified newCase(
			OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {			
		String aMessage = toString(anOperationName, anIndex, anElement);
		ListEditNotified retVal = new ListEditNotified(aMessage, anOperationName, anIndex, anElement,aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/listeditobserved.java
package trace.echo.modular;

import im.OperationName;

public class ListEditObserved extends ListEditInfo{

	public ListEditObserved(String aMessage, OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {
		super(aMessage, anOperationName, anIndex, anElement, aFinder);
	}
	public ListEditObserved(String aMessage, ListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditObserved toTraceable (String aMessage) {
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		return new ListEditObserved(aMessage, aListEditInfo);
	}
	public static ListEditObserved newCase(
			OperationName anOperationName, int anIndex,
			Object anElement, Object aFinder) {			
		String aMessage = toString(anOperationName, anIndex, anElement);
		ListEditObserved retVal = new ListEditObserved(aMessage, anOperationName, anIndex, anElement,aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/echo/modular/modularechotracechecker.java
package trace.echo.modular;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import echo.monolithic.MonolithicEchoer;
import bus.uigen.oadapters.ObjectAdapter;
import bus.uigen.query.AnObjectQuery;
import bus.uigen.query.ObjectQuery;
import bus.uigen.trace.TraceUtility;
import trace.echo.EchoTraceChecker;
import util.misc.Common;
import util.trace.Traceable;
import util.trace.TraceableLog;
import util.trace.console.ConsoleInput;
import util.trace.console.ConsoleOutput;
import static bus.uigen.trace.TraceUtility.*;
import static bus.uigen.query.QueryUtility.*;

public class ModularEchoTraceChecker {
	public static boolean modularEchoCheck(String aFileName) {
		List<Traceable> retVal = TraceUtility.toTraceableList(aFileName);
		return checkMVCPattern (retVal);

	}
	static Class[] modularExpectedClasses = {
			ListEditInput.class,
			ListEditMade.class,
			ListEditNotified.class,
			ListEditObserved.class,
	};
	
	public static Class[] append(Class[] aClasses1, Class[] aClasses2) {
		List<Class> aList1 = Arrays.asList(aClasses1);
		List<Class> aList2 = Arrays.asList(aClasses2);
		List<Class> list = new ArrayList(aList1.size() + aList2.size());
		list.addAll(aList1);
		list.addAll(aList2);
		return list.toArray(new Class[list.size()]);
	}
	// keep the tests of super class and this one separate
	public static Class[] expectedClasses() {
//		return append(myExpectedClasses, EchoTraceChecker.expectedClasses());
		return modularExpectedClasses;
	}
	
	public static List<Integer> getNextSequenceOfExpectedModularEvents(List<Traceable> aTraceableList, int aStartIndex) {
		TraceableLog aTraceableLog = TraceUtility.startNewTrace();
		// get the first sequence of four events in modularExpected classes
//		List<Integer> anIndexList = indicesOf(aTraceableList, modularExpectedClasses, true, aStartIndex, false);
//		String[] aProperties = {"Index", "Element"};
		List<String> aPropertiesList = Arrays.asList(ListEditInfo.listEditEqualPropertiesArray);


		List<Integer> anIndexList = indicesOf(aTraceableList,  modularExpectedClasses, aPropertiesList, true, aStartIndex, true);

		TraceUtility.stopExistingTrace(aTraceableLog);
		System.out.println(aTraceableLog);
		if (anIndexList == null || !valid(anIndexList)) // did not find the events at all
			return null;
		return anIndexList;
		
	}
	
	public static boolean isNextSequenceOfModularEventsCompatible(List<Traceable> aTraceableList, List<Integer> anIndexList) {
		List aMatchedTraceables = toObjectList(aTraceableList, anIndexList);
//		String[] aProperties = {"OperationName", "Index", "Element"};
//		boolean equalEdits = matches(aMatchedTraceables,  aProperties);
		List<Object> aSources = ObjectAdapter.getPropertyValues(aMatchedTraceables, "EventSource");
		String anInputSouce = (String) aSources.get(0);
		String anActionSource = (String) aSources.get(1);
		String aNotificationSource = (String) aSources.get(2);
		String anObservedSource = (String) aSources.get(3);
		boolean inputNotAction = ! anInputSouce.equals(anActionSource);
		boolean observedNotNotification = !aNotificationSource.equals(anObservedSource);
//		return equalEdits && inputNotAction && observedNotNotification;
		return inputNotAction && observedNotNotification;


		
	}
	
	public static boolean intraSequenceCheckModularEchoer(List<Traceable> aTraceableList) {


//		TraceableLog aTraceableLog = TraceUtility.startNewTrace();
//		// get the first sequence of four events in modularExpected classes
//		List<Integer> anIndexList = indicesOf(aTraceableList, modularExpectedClasses, true);
//		TraceUtility.stopExistingTrace(aTraceableLog);
//		System.out.println(aTraceableLog);
//		if (!valid(anIndexList)) // did not find the events at all
//			return false;
		int startIndex = 0;
		boolean retVal = true;
		boolean foundASequence = false; //if found no instance of events, return false
		while (true) {
		// get the first sequence of four events in modularExpected classes
		List<Integer> anIndexList = getNextSequenceOfExpectedModularEvents(aTraceableList, startIndex);
		if (anIndexList == null || anIndexList.size() == 0)
			return foundASequence && retVal;
		foundASequence = true;
		// found events, now test their equality
//		List aMatchedTraceables = toObjectList(aTraceableList, anIndexList);
//		String[] aProperties = {"OperationName", "Index", "Element"};
//		boolean equalEdits = matches(aMatchedTraceables,  aProperties);
//		List<Object> aSources = ObjectAdapter.getPropertyValues(aMatchedTraceables, "EventSource");
//		String anInputSouce = (String) aSources.get(0);
//		String anActionSource = (String) aSources.get(1);
//		String aNotificationSource = (String) aSources.get(2);
//		String anObservedSource = (String) aSources.get(3);
//		boolean inputNotAction = ! anInputSouce.equals(anActionSource);
//		boolean observedNotNotification = !aNotificationSource.equals(anObservedSource);
//		
//
//		return equalEdits && inputNotAction && observedNotNotification;
		retVal = retVal & isNextSequenceOfModularEventsCompatible(aTraceableList, anIndexList);
		// move past the last matched index
		startIndex = anIndexList.get(anIndexList.size() -1) + 1;
		}
		
	}

	public static boolean compareMVCSequences(
			List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		TraceableLog traceableLog = TraceUtility.startNewTrace();
		System.out.println("Comparing MVC Sequences");
//		String[] aProperties = {"Output"};
		
//		ObjectQuery[] objectQueries = traceablesToQueries(aCorrectTraceableList);
//		boolean retVal = inOrder(aFilteredTest, objectQueries, anExpe);
		boolean retVal = inOrder(aTestTraceableList, aCorrectTraceableList, expectedClasses(), true);
		TraceUtility.stopExistingTrace(traceableLog);
		if (!retVal)
			System.out.println("MVC Test failed");
		return retVal;		
	
		
		
	}
	

	public static boolean checkMVCPattern(List<Traceable> aTraceableList) {
		int inputIndex = indexOf(aTraceableList, ListEditInput.class, 0);
		if (inputIndex < 0)
			return false;
		ListEditInput anInput = (ListEditInput) aTraceableList.get(inputIndex);
		int actionIndex = indexOf(aTraceableList, ListEditMade.class, inputIndex + 1);
		if (actionIndex < 0)
			return false;
		ListEditMade anAction = (ListEditMade) aTraceableList.get(actionIndex);
		int notificationIndex = indexOf(aTraceableList, ListEditNotified.class, actionIndex + 1);	
		if (notificationIndex < 0)
			return false;
		ListEditNotified aNotification = (ListEditNotified) aTraceableList.get(notificationIndex);

		int observationIndex = indexOf(aTraceableList, ListEditObserved.class, notificationIndex + 1);
		if (observationIndex < 0) {
			return false;
		}
		ListEditObserved anObservation = (ListEditObserved) aTraceableList.get(observationIndex);

		boolean equalEdits = anInput.equalsEdit(anAction) &&
				anAction.equalsEdit(aNotification) &&
				aNotification.equalsEdit(anObservation);
		boolean differentClasses = 
				!(anInput.getEventSource().equals(anAction.getEventSource())) &&
				!(anObservation.getEventSource().equals(anAction.getEventSource()));
		return equalEdits && differentClasses;
	
	}
	

	public static void main (String[] args) {
		System.out.println(modularEchoCheck("traceLogEcho.txt"));
	}
	
	

}
//END OF FILE
//START OF FILE: src/trace/im/communicatedlisteditinfo.java
package trace.im;
import im.OperationName;
import trace.echo.modular.ListEditInfo;
import trace.echo.modular.ListEditInput;
import util.trace.session.AddressedMessageInfo;
import util.trace.session.ProcessInfo;
//public class CommunicatedListEditInfo extends ListEditInfo {
public class CommunicatedListEditInfo extends ListEditInfo {

	String destinationOrSource;
	String processName;
	
	public CommunicatedListEditInfo(String aMessage,
			String aProcessName,
			OperationName aName, 
			int anIndex, 
			Object anElement, 
			String aDestinationOrSource, 
			Object aFinder) {
		super(aMessage, aName, anIndex, anElement, aFinder);
//		this.operationName = aName;
//		this.index = anIndex;
//		this.element = anElement;
		processName = aProcessName;
		destinationOrSource = aDestinationOrSource;
	}
	public CommunicatedListEditInfo(String aProcessName, OperationName aName, int anIndex, Object anElement, String aDestinationOrSource) {
		this("",  aProcessName, aName, anIndex, anElement, aDestinationOrSource, null);		
	}
	public CommunicatedListEditInfo(String aMessage, String aProcessName, String aDestinationOrSource, ListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
		processName = aProcessName;
		destinationOrSource = aDestinationOrSource;
	}
	public CommunicatedListEditInfo(String aMessage, CommunicatedListEditInfo aCommunicatedListEditInfo) {
		this(aMessage, aCommunicatedListEditInfo.getProcessName(), aCommunicatedListEditInfo.getDestinationOrSource(), aCommunicatedListEditInfo);
	}

	public static CommunicatedListEditInfo toTraceable (String aMessage) {
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		String aProcessName = ProcessInfo.getProcessName(aMessage);
		String anAddress = AddressedMessageInfo.getAddress(aMessage);		
		return new CommunicatedListEditInfo(aMessage, aProcessName, anAddress, aListEditInfo);
	}
	
	
	public String getDestinationOrSource() {
		return destinationOrSource;
	}
	
	public static String toString(String aProcessName, OperationName name, int anIndex, Object anElement, String aDestinationOrSource) {
		return ProcessInfo.toString(aProcessName)  + ListEditInfo.toLocalInfoToString(name, anIndex, anElement) + 
//				" Address(" + 
				" " + AddressedMessageInfo.ADDRESS + "(" +
				aDestinationOrSource + ")";
	}
	public String alternativeToString() {
		return toString(processName, operationName, index, element, destinationOrSource);
	}
	public String getProcessName() {
		return processName;
	}
	public void setProcessName(String processName) {
		this.processName = processName;
	}
	public void setDestinationOrSource(String destinationOrSource) {
		this.destinationOrSource = destinationOrSource;
	}
	
}
//END OF FILE
//START OF FILE: src/trace/im/imtracechecker.java
package trace.im;

import java.util.ArrayList;
import java.util.List;

import bus.uigen.oadapters.ObjectAdapter;
import bus.uigen.query.AnObjectQuery;
import bus.uigen.query.ObjectQuery;
import bus.uigen.trace.TraceUtility;
import trace.echo.modular.ModularEchoTraceChecker;
import util.trace.Traceable;
import util.trace.TraceableLog;
import util.trace.console.ConsoleInput;
import util.trace.console.ConsoleOutput;
import util.trace.session.MessageReceived;
import util.trace.session.MessageSent;
import util.trace.session.SendDataRequest;
import static bus.uigen.trace.TraceUtility.*;
import static bus.uigen.query.QueryUtility.*;

public class IMTraceChecker extends ModularEchoTraceChecker{
	
	static Class[] imExpectedClasses = {
//			MessageSent.class, // a message may be sent multiple times, so we will not use it
			SendDataRequest.class,
			MessageReceived.class,
			ListEditReceived.class,
			ListEditSent.class,
	};
	static Class[] sendClasses = {
		ListEditSent.class,	 // must be before Message Sent
//		MessageSent.class, 		// a message may be sent multiple times, so we will not use it
		SendDataRequest.class

	};
	static Class[] receiveClasses = {
		MessageReceived.class, // must be before ListEditReceived
		ListEditReceived.class,		

	};
	public static Class[] expectedClasses() {
//		return append(myExpectedClasses, EchoTraceChecker.expectedClasses());
		return imExpectedClasses;
	}
	public static List<Integer> getNextSequenceOfExpectedReceiveEvents(List<Traceable> aTraceableList, int aStartIndex) {
		TraceableLog aTraceableLog = TraceUtility.startNewTrace();
		// get the first sequence of four events in modularExpected classes
		List<Integer> anIndexList = indicesOf(aTraceableList, receiveClasses, true, aStartIndex, true);
		TraceUtility.stopExistingTrace(aTraceableLog);
		System.out.println(aTraceableLog);
		if (!valid(anIndexList)) // did not find the events at all
			return null;
		return anIndexList;
		
	}
	
	public static List<Integer> getNextSequenceOfExpectedSendEvents(List<Traceable> aTraceableList, int aStartIndex) {
		TraceableLog aTraceableLog = TraceUtility.startNewTrace();
		// get the first sequence of four events in modularExpected classes
		List<Integer> anIndexList = indicesOf(aTraceableList, sendClasses, true, aStartIndex, true);
		TraceUtility.stopExistingTrace(aTraceableLog);
		System.out.println(aTraceableLog);
		if (!valid(anIndexList)) // did not find the events at all
			return null;
		return anIndexList;
		
	}
	
	public static boolean isNextSequenceOfReceiveEventsCompatible(List<Traceable> aTraceableList, List<Integer> anIndexList) {
		// list edit is "sent" before the message is sent
		MessageReceived aMessageReceived = (MessageReceived) aTraceableList.get(anIndexList.get(0));

		ListEditReceived aListEditReceived = (ListEditReceived) aTraceableList.get(anIndexList.get(1));
		String aMessage= aMessageReceived.getMessage();
//		return aDataText.contains("" + aListEditSent.getIndex() ) &&
//				aDataText.contains(aListEditSent.getElement().toString());
		
		// OT might change the index
		return //aMessage.contains("" + aListEditReceived.getIndex() ) &&
				aMessage.contains(aListEditReceived.getElement().toString());
		
	}
	
	public static boolean isNextSequenceOfSendEventsCompatible(List<Traceable> aTraceableList, List<Integer> anIndexList) {
		// list edit is "sent" before the message is sent
		ListEditSent aListEditSent = (ListEditSent) aTraceableList.get(anIndexList.get(0));
//		MessageSent aMessageSent = (MessageSent) aTraceableList.get(anIndexList.get(1));
		SendDataRequest aMessageSent = (SendDataRequest) aTraceableList.get(anIndexList.get(1));

//		String aDataText = aMessageSent.getData().toString();
		String aMessage= aMessageSent.getMessage();
//		return aDataText.contains("" + aListEditSent.getIndex() ) &&
//				aDataText.contains(aListEditSent.getElement().toString());
		
		// OT will not change the index sent
		return aMessage.contains("" + aListEditSent.getIndex() ) &&
				aMessage.contains(aListEditSent.getElement().toString());
		
	}
	public static boolean intraSequenceSendCheckIM(List<Traceable> aTraceableList) {
		int startIndex = 0;
		boolean retVal = true;
		boolean foundASequence = false; //if found no instance of events, return false
		System.out.println("Intra Sequence Send Test");
		while (true) {
		// get the first sequence of four events in modularExpected classes
		List<Integer> anIndexList = getNextSequenceOfExpectedSendEvents(aTraceableList, startIndex);
		if (anIndexList == null || anIndexList.size() == 0)
			return foundASequence && retVal;
		foundASequence = true;
		// found events, now test their equality
		boolean thisCheck = isNextSequenceOfSendEventsCompatible(aTraceableList, anIndexList);
		if (!thisCheck) {
			System.out.println("Send check failed:" + anIndexList);
		}
		retVal = retVal & thisCheck;
		// move past the last matched index
		startIndex = anIndexList.get(anIndexList.size() -1) + 1;
		}
		
	}
	
	public static boolean intraSequenceReceiveCheckIM(List<Traceable> aTraceableList) {
		int startIndex = 0;
		boolean retVal = true;
		boolean foundASequence = false; //if found no instance of events, return false
		System.out.println("Intra Sequence Receive Test");
		while (true) {
		// get the first sequence of four events in modularExpected classes
		List<Integer> anIndexList = getNextSequenceOfExpectedReceiveEvents(aTraceableList, startIndex);
		if (anIndexList == null || anIndexList.size() == 0)
			return foundASequence && retVal;
		foundASequence = true;
		// found events, now test their equality
		boolean thisCheck = isNextSequenceOfReceiveEventsCompatible(aTraceableList, anIndexList);
		retVal = retVal && thisCheck;
		if (!thisCheck) {
			System.out.println("Not compatible:" + anIndexList);
		}
		// move past the last matched index
		startIndex = anIndexList.get(anIndexList.size() -1) + 1;
		}
		
	}
	
	public static boolean intraSequenceCheckIM(List<Traceable> aTraceableList) {
		boolean  aReceiveCheck = intraSequenceReceiveCheckIM(aTraceableList);
		boolean aSendCheck = intraSequenceSendCheckIM(aTraceableList);
		return aReceiveCheck & aSendCheck;
	}


	public static boolean compareIMSequences(
			List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		System.out.println("Comparing IM Sequences");
		TraceableLog traceableLog = TraceUtility.startNewTrace();
//		String[] aProperties = {"Output"};
		
//		ObjectQuery[] objectQueries = traceablesToQueries(aCorrectTraceableList);
//		boolean retVal = inOrder(aFilteredTest, objectQueries, anExpe);
		boolean retVal = inOrder(aTestTraceableList, aCorrectTraceableList, expectedClasses(), true);
		
		TraceUtility.stopExistingTrace(traceableLog);
		if (!retVal)
			System.out.println("IM Sequence Test Failed");
		return retVal;		
	
		
		
	}
	
	

}
//END OF FILE
//START OF FILE: src/trace/im/imtracersetter.java
package trace.im;

import trace.echo.modular.EchoTracerSetter;
import util.trace.MessagePrefixKind;
import util.trace.Traceable;
import util.trace.TraceableInfo;
import util.trace.Tracer;
import util.trace.session.MessageReceived;
import util.trace.session.MessageSent;
import util.trace.session.SendDataRequest;
import util.trace.session.SessionTracerSetter;

public class IMTracerSetter extends EchoTracerSetter{
	
	public static void traceIM() {
		Tracer.showInfo(true);
//		TraceableInfo.setPrintSource(true);
//		Traceable.setPrintTime(false);
//		Traceable.setPrintThread(true);
//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
		

//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
		EchoTracerSetter.setTraceParameters();
		setIMPrintStatus();		
	}
	
	public static void setIMPrintStatus() {
		

//		TraceableInfo.setPrintSource(true);
//		Traceable.setPrintTime(false);
//		Traceable.setPrintThread(true);
//		Tracer.setMessagePrefixKind(MessagePrefixKind.FULL_CLASS_NAME);
		EchoTracerSetter.setEchoerPrintStatus();
		Tracer.setKeywordPrintStatus(SendDataRequest.class, true);
		Tracer.setKeywordPrintStatus(MessageReceived.class, true);

//		SessionTracerSetter.setSessionPrintStatus();
		Tracer.setKeywordPrintStatus(ListEditSent.class, true);
		Tracer.setKeywordPrintStatus(ListEditReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageInSendingQueue.class, true);
//		Tracer.setKeywordPrintStatus(SentMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(MessageSent.class, true);
//		Tracer.setKeywordPrintStatus(SendMessageRequest.class, true);
//		Tracer.setKeywordPrintStatus(MessageReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageRetrievedFromReceivingQueue.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);





	}

}
//END OF FILE
//START OF FILE: src/trace/im/listeditreceived.java
package trace.im;

import trace.echo.modular.ListEditInfo;
import trace.echo.modular.ListEditInput;
import im.OperationName;

public class ListEditReceived extends CommunicatedListEditInfo{

	public ListEditReceived(String aMessage, String aProcessName, OperationName anOperationName, int anIndex,
			Object anElement,  String aDestinationOrSource, Object aFinder) {
		super(aMessage, aProcessName, anOperationName, anIndex, anElement, aDestinationOrSource, aFinder);
	}
	public ListEditReceived(String aMessage, CommunicatedListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditReceived toTraceable (String aMessage) {
		CommunicatedListEditInfo aListEditInfo = CommunicatedListEditInfo.toTraceable(aMessage);
		return new ListEditReceived(aMessage, aListEditInfo);
	}
	public static ListEditReceived newCase(
			String aProcessName,
			OperationName anOperationName, int anIndex,
			Object anElement, String aSourceOrDestination, Object aFinder) {
			
		String aMessage = toString(aProcessName, anOperationName, anIndex, anElement, aSourceOrDestination);
		ListEditReceived retVal = new ListEditReceived(aMessage, aProcessName, anOperationName, anIndex, anElement, aSourceOrDestination, aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/im/listeditsent.java
package trace.im;

import im.OperationName;

public class ListEditSent extends CommunicatedListEditInfo{

	public ListEditSent(String aMessage, String aProcessName, OperationName anOperationName, int anIndex,
			Object anElement,  String aDestinationOrSource, Object aFinder) {
		super(aMessage, aProcessName, anOperationName, anIndex, anElement, aDestinationOrSource, aFinder);
	}
	public ListEditSent(String aMessage, CommunicatedListEditInfo aListEditInfo) {
		super(aMessage, aListEditInfo);
	}

	public static ListEditSent toTraceable (String aMessage) {
		CommunicatedListEditInfo aListEditInfo = CommunicatedListEditInfo.toTraceable(aMessage);
		return new ListEditSent(aMessage, aListEditInfo);
	}
	public static ListEditSent newCase(
			String aProcessName,
			OperationName anOperationName, int anIndex,
			Object anElement, String aSourceOrDestination, Object aFinder) {
			
		String aMessage = toString(aProcessName, anOperationName, anIndex, anElement, aSourceOrDestination);
		ListEditSent retVal = new ListEditSent(aMessage, aProcessName, anOperationName, anIndex, anElement, aSourceOrDestination, aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/im/aware/awareimtracersetter.java
package trace.im.aware;

import trace.im.IMTracerSetter;
import util.trace.Tracer;
import util.trace.session.ClientJoinNotificationReceived;
import util.trace.session.ClientLeaveNotificationReceived;
import util.trace.session.SessionTracerSetter;

public class AwareIMTracerSetter {
	
	public static void traceAwareIM() {
		Tracer.showInfo(true);
		setAwareIMPrintStatus();		
	}
	
	public static void setAwareIMPrintStatus() {
//		SessionTracerSetter.setSessionPrintStatus();
		IMTracerSetter.setIMPrintStatus();
		Tracer.setKeywordPrintStatus(ClientJoinNotificationReceived.class, true);
		Tracer.setKeywordPrintStatus(ClientLeaveNotificationReceived.class, true);

//		Tracer.setKeywordPrintStatus(ListEditSent.class, true);
//		Tracer.setKeywordPrintStatus(ListEditReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageInSendingQueue.class, true);
//		Tracer.setKeywordPrintStatus(SentMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(MessageSent.class, true);
//		Tracer.setKeywordPrintStatus(SendMessageRequest.class, true);
//		Tracer.setKeywordPrintStatus(MessageReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageRetrievedFromReceivingQueue.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);





	}

}
//END OF FILE
//START OF FILE: src/trace/ot/concurrentedits.java
package trace.ot;

import trace.echo.modular.ListEditInfo;

public class ConcurrentEdits extends OTListEditPairInfo{

	public ConcurrentEdits(String aMessage, String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
		super(aMessage, aProcessName, aFirst, aSecond, aFinder);
	}
	public ConcurrentEdits(String aMessage, String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
			boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
			boolean aSecondIsServer,
			Object aFinder) {
		super(aMessage, aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, aFirstIsServer, aSecondEdit, aSecondTimeStamp, aSecondUser, aSecondIsServer, aFinder);
	}
	public ConcurrentEdits(String aMessage, OTListEditPairInfo aPairInfo) {
		super(aMessage, aPairInfo);
	}
	
	public static ConcurrentEdits toTraceable (String aMessage) {
		OTListEditPairInfo aPairInfo = OTListEditPairInfo.toTraceable(aMessage);
		return new ConcurrentEdits (aMessage, aPairInfo);
		}
	public static ConcurrentEdits newCase(String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
			String aMessage = toString(aProcessName, aFirst, aSecond);
			ConcurrentEdits retVal = new ConcurrentEdits(aMessage, aProcessName, aFirst, aSecond, aFinder);
			retVal.announce();
			return retVal;
		
	}
	public static ConcurrentEdits newCase(String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
//			boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
//			boolean aSecondIsServer,
			Object aFinder) {
		
		return newCase(aProcessName, 
				new OTListEditInfo(
						aFirstEdit, 
						new UserOTTimeStampInfo(aFirstUser, aFistTimeStamp, null,/*aFirstIsServer,*/ aFinder)),
						
				new OTListEditInfo(
						aSecondEdit, 
						new UserOTTimeStampInfo(aSecondUser, aSecondTimeStamp, null, /*aSecondIsServer,*/ aFinder)),	
				aFinder);
		
//		return newCase (aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, aFirstIsServer, aSecondEdit, aSecondTimeStamp, aSecondUser, aSecondIsServer, aFinder);
	}
	
		

}
//END OF FILE
//START OF FILE: src/trace/ot/initialottimestampcreated.java
package trace.ot;


public class InitialOTTimeStampCreated extends UserOTTimeStampInfo{
	
	public InitialOTTimeStampCreated(String aMessage, String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			boolean isServer,
			Object aFinder) {
		super(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, isServer, aFinder);
	}
	public InitialOTTimeStampCreated(String aMessage, 
			UserOTTimeStampInfo aTimeStampInfo) {
		super(aMessage, aTimeStampInfo);
	}
	public static InitialOTTimeStampCreated toTraceable(String aMessage) {
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new InitialOTTimeStampCreated(aMessage, 
				aTimeStampInfo);		
	}
	
	public static InitialOTTimeStampCreated newCase(
			String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			boolean anIsServer,
			Object aFinder) {
		String aMessage = toString(aProcessName, aUserName, aLocalCount, aRemoteCount, anIsServer);
		InitialOTTimeStampCreated retVal = new InitialOTTimeStampCreated(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, anIsServer, aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/localeditcountincremented.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class LocalEditCountIncremented extends OTListEditInfo{

	public LocalEditCountIncremented(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public LocalEditCountIncremented(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static LocalEditCountIncremented toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new LocalEditCountIncremented(aMessage, 
				aSuperClassInfo);		
	}
	public static LocalEditCountIncremented newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		LocalEditCountIncremented retVal = new LocalEditCountIncremented(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static LocalEditCountIncremented newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null/*, anInServer*/);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static LocalEditCountIncremented newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/localsitecountincremented.java
package trace.ot;


public class LocalSiteCountIncremented extends UserOTTimeStampInfo{
	
	public LocalSiteCountIncremented(String aMessage, String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			Boolean isServer,
			Object aFinder) {
		super(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, isServer, aFinder);
	}
	public LocalSiteCountIncremented(String aMessage, 
			UserOTTimeStampInfo aTimeStampInfo) {
		super(aMessage, aTimeStampInfo);
	}
	public static LocalSiteCountIncremented toTraceable(String aMessage) {
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new LocalSiteCountIncremented(aMessage, 
				aTimeStampInfo);		
	}
	public static LocalSiteCountIncremented newCase(
			String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			/*boolean anInServer,*/
			Object aFinder) {
		String aMessage = toString(aProcessName, aUserName, aLocalCount, aRemoteCount, null);
		LocalSiteCountIncremented retVal = new LocalSiteCountIncremented(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, null,/*anInServer,*/ aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/locatableuserottimestampedlisteditinfo.java
package trace.ot;

import trace.im.CommunicatedListEditInfo;

public class LocatableUserOTTimeStampedListEditInfo extends OTListEditInfo{
	String location;
	public LocatableUserOTTimeStampedListEditInfo(String aMessage, String aLocation,
			CommunicatedListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aLocation, aMessage, aListEdit, anOTTimeStamp, aFinder);
//		location = aLocation;
	}
//	public String getLocation() {
//		return location;
//	}
//	public static String toString(ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination) {
//		return aSourceOrDestination + "-->" + toString(aListEdit, anOTTimeStamp);
//	}
//	
}
//END OF FILE
//START OF FILE: src/trace/ot/nonconcurrentedits.java
package trace.ot;

import trace.echo.modular.ListEditInfo;

public class NonConcurrentEdits extends OTListEditPairInfo{

	public NonConcurrentEdits(String aMessage, String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
		super(aMessage, aProcessName, aFirst, aSecond, aFinder);
	}
	public NonConcurrentEdits(String aMessage, String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
			boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
			boolean aSecondIsServer,
			Object aFinder) {
		super(aMessage, aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, aFirstIsServer, aSecondEdit, aSecondTimeStamp, aSecondUser, aSecondIsServer, aFinder);
	}
	public NonConcurrentEdits(String aMessage, OTListEditPairInfo aPairInfo) {
		super(aMessage, aPairInfo);
	}
	
	public static NonConcurrentEdits toTraceable (String aMessage) {
		OTListEditPairInfo aPairInfo = OTListEditPairInfo.toTraceable(aMessage);
		return new NonConcurrentEdits (aMessage, aPairInfo);
		}
	public static NonConcurrentEdits newCase(String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
			String aMessage = toString(aProcessName, aFirst, aSecond);
			NonConcurrentEdits retVal = new NonConcurrentEdits(aMessage, aProcessName, aFirst, aSecond, aFinder);
			retVal.announce();
			return retVal;
		
	}
	public static NonConcurrentEdits newCase(String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
//			boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
//			boolean aSecondIsServer,
			Object aFinder) {
		
		return newCase(aProcessName, 
				new OTListEditInfo(
						aFirstEdit, 
						new UserOTTimeStampInfo(aFirstUser, aFistTimeStamp, null,/*aFirstIsServer,*/ aFinder)),
						
				new OTListEditInfo(
						aSecondEdit, 
						new UserOTTimeStampInfo(aSecondUser, aSecondTimeStamp, null, /*aSecondIsServer,*/ aFinder)),	
				aFinder);
		
//		return newCase (aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, aFirstIsServer, aSecondEdit, aSecondTimeStamp, aSecondUser, aSecondIsServer, aFinder);
	}
	
		

}
//END OF FILE
//START OF FILE: src/trace/ot/otimtracersetter.java
package trace.ot;

import trace.echo.modular.EchoTracerSetter;
import trace.im.IMTracerSetter;
import util.trace.Tracer;

public class OTIMTracerSetter extends IMTracerSetter {
	
	public static void traceOTIM() {
		Tracer.showInfo(true);
		EchoTracerSetter.setTraceParameters();
		setOTPrintStatus();		
	}
	
	public static void setOTPrintStatus() {
//		SessionTracerSetter.setSessionPrintStatus();
		IMTracerSetter.setIMPrintStatus();
		Tracer.setKeywordPrintStatus(ConcurrentEdits.class, true);
		Tracer.setKeywordPrintStatus(InitialOTTimeStampCreated.class, true);
		Tracer.setKeywordPrintStatus(LocalSiteCountIncremented.class, true);
		Tracer.setKeywordPrintStatus(OTListEditBuffered.class, true);
		Tracer.setKeywordPrintStatus(OTListEditCopied.class, true);
		Tracer.setKeywordPrintStatus(OTListEditFlipped.class, true);
		Tracer.setKeywordPrintStatus(OTListEditReceived.class, true);
		Tracer.setKeywordPrintStatus(OTListEditRemoteCountIncremented.class, true);
		Tracer.setKeywordPrintStatus(OTListEditSent.class, true);
		Tracer.setKeywordPrintStatus(TransformationOperands.class, true);
		Tracer.setKeywordPrintStatus(TransformationResult.class, true);


		






//		Tracer.setKeywordPrintStatus(ListEditSent.class, true);
//		Tracer.setKeywordPrintStatus(ListEditReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageInSendingQueue.class, true);
//		Tracer.setKeywordPrintStatus(SentMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(MessageSent.class, true);
//		Tracer.setKeywordPrintStatus(SendMessageRequest.class, true);
//		Tracer.setKeywordPrintStatus(MessageReceived.class, true);
//		Tracer.setKeywordPrintStatus(MessageRetrievedFromReceivingQueue.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDelayed.class, true);
//		Tracer.setKeywordPrintStatus(ReceivedMessageDistributedToListeners.class, true);





	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditbuffered.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditBuffered extends OTListEditInfo{

	public OTListEditBuffered(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public OTListEditBuffered(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditBuffered toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditBuffered(aMessage, 
				aSuperClassInfo);		
	}
	public static OTListEditBuffered newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditBuffered retVal = new OTListEditBuffered(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditBuffered newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditBuffered newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditcopied.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditCopied extends OTListEditInfo{

	public OTListEditCopied(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public OTListEditCopied(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditCopied toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditCopied(aMessage, 
				aSuperClassInfo);		
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static OTListEditCopied newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditCopied retVal = new OTListEditCopied(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditCopied newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditCopied newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditflipped.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditFlipped extends OTListEditInfo{

	public OTListEditFlipped(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public OTListEditFlipped(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditFlipped toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditFlipped(aMessage, 
				aSuperClassInfo);		
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static OTListEditFlipped newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditFlipped retVal = new OTListEditFlipped(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditFlipped newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditFlipped newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditinfo.java
package trace.ot;

import trace.echo.modular.ListEditInfo;
import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class OTListEditInfo extends ProcessInfo {
	UserOTTimeStampInfo otTimeStamp;
	ListEditInfo listEdit;
//	String processName;
	public OTListEditInfo(String aMessage, String aProcessName,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
//		processName = aProcessName;
		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}
	
	public OTListEditInfo(ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp) {
		this("", "", aListEdit, anOTTimeStamp, null);
	}

	public OTListEditInfo(String aMessage, ListEditInfo aListEdit, 
			UserOTTimeStampInfo anOTTimeStamp, ProcessInfo aProcessInfo) {
//		super(aMessage, "", aProcessInfo);
		super(aMessage, aProcessInfo);

		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;
	}

	public OTListEditInfo(String aMessage, OTListEditInfo anOTListEdit) {
		this (aMessage, anOTListEdit.getListEdit(), anOTListEdit.getUserOTTimeStamp(), anOTListEdit);
		
	}
	public static String toLocalInfoToString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return aListEdit.toLocalInfoToString() + " "
				+ anOTTimeStamp.alternativeToString() ;
		
	}
	public static String toString(String aProcessName, ListEditInfo aListEdit,
			UserOTTimeStampInfo anOTTimeStamp) {
		return toString(aProcessName) + " " + toLocalInfoToString(aProcessName, aListEdit, anOTTimeStamp);
//				"OTEdit(" + 
//				aListEdit.toLocalInfoToString() + " "
//				+ anOTTimeStamp.alternativeToString() ;
				
//				+ ")";

	}
	
	public static OTListEditInfo toTraceable(String aMessage) {
//		ProcessInfo aProcessInfo;
//		try {
		ProcessInfo aProcessInfo = ProcessInfo.toTraceable(aMessage);
//		} catch (Exception e) {
//			System.out.println(e);
//			aProcessInfo = null;
//		}
		ListEditInfo aListEditInfo = ListEditInfo.toTraceable(aMessage);
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new OTListEditInfo(aMessage, aListEditInfo, aTimeStampInfo, aProcessInfo);
		
	}
	

	public String alternativeToString() {
		return toString(processName, listEdit, otTimeStamp);
	}
	public String toLocalInfoToString() {
		return toLocalInfoToString(processName, listEdit, otTimeStamp);
	}


	public UserOTTimeStampInfo getUserOTTimeStamp() {
		return otTimeStamp;
	}

	public ListEditInfo getListEdit() {
		return listEdit;
	}
	
	public String getProcessName() {
		return processName;
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditpairinfo.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;
import util.trace.Traceable;
import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class OTListEditPairInfo extends ProcessInfo {
	OTListEditInfo firstEdit, secondEdit;
	public OTListEditPairInfo(String aMessage, String aProcessName,
			OTListEditInfo aFirstEdit,
			OTListEditInfo aSecondEdit,
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
		firstEdit = aFirstEdit;
		secondEdit = aSecondEdit;
	}
	
	public OTListEditPairInfo(String aMessage, 
			OTListEditInfo aFirstEdit,
			OTListEditInfo aSecondEdit,
			ProcessInfo aProcessInfo) {
		super(aMessage, aProcessInfo);
		firstEdit = aFirstEdit;
		secondEdit = aSecondEdit;
	}	
	
	public OTListEditPairInfo(String aMessage, 
			OTListEditPairInfo aPairInfo) {
		this(aMessage, aPairInfo.getFirstEdit(), aPairInfo.getSecondEdit(), aPairInfo);
	
	}
	
	public OTListEditPairInfo(String aMessage, String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
			Boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
			Boolean aSecondIsServer,
			Object aFinder) {
		this (
				aMessage,
				aProcessName,
				new OTListEditInfo(
						aFirstEdit, 
						new UserOTTimeStampInfo(aFirstUser, aFistTimeStamp, aFirstIsServer, aFinder)),
						
				new OTListEditInfo(
						aSecondEdit, 
						new UserOTTimeStampInfo(aSecondUser, aSecondTimeStamp, aSecondIsServer, aFinder)),	
				aFinder);
	
		
	}
	
	public static String getFirstOTListEdit(String aMessage) {
		return getSuffixOfCompositeDescriptor(aMessage, FIRST);
	}
	
	public static String getSecondOTListEdit(String aMessage) {
		return getSuffixOfCompositeDescriptor(aMessage, SECOND);
	}
	
	
	
	
	public static OTListEditPairInfo toTraceable(String aMessage) {
		ProcessInfo aProcessInfo = ProcessInfo.toTraceable(aMessage);
		String aFirstEditText = getFirstOTListEdit(aMessage);
		String aSecondEditText = getSecondOTListEdit(aMessage);
		OTListEditInfo aFirstEdit = OTListEditInfo.toTraceable(aFirstEditText);
		OTListEditInfo aSecondEdit = OTListEditInfo.toTraceable(aSecondEditText);
		
		return new OTListEditPairInfo(aMessage, aFirstEdit, aSecondEdit, aProcessInfo);
	}
	
	public OTListEditInfo getFirstEdit() {
		return firstEdit;
	}	
	public OTListEditInfo getSecondEdit() {
		return firstEdit;
	}	
	public static final String FIRST = "First";
	public static final String SECOND = "Second";
	public static String toString(String aProcessName, 
			OTListEditInfo aFirstEdit,
			OTListEditInfo aSecondEdit) {
		return toString(aProcessName) + 
				
//				"[" + 
				FIRST + "_" + aFirstEdit.toLocalInfoToString() + " " + 
				SECOND + "_" +	aSecondEdit.toLocalInfoToString();
//		"[" + aFirstEdit. + "," + 
//		aSecondEdit.alternativeToString() + "]";
	}
	public String alternativeToString() {
		return toString(processName, firstEdit, secondEdit);
	}
	
	

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditreceived.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditReceived extends OTListEditInfo{

	public OTListEditReceived(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public OTListEditReceived(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditReceived toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditReceived(aMessage, 
				aSuperClassInfo);		
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static OTListEditReceived newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditReceived retVal = new OTListEditReceived(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditReceived newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditReceived newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditremotecountincremented.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditRemoteCountIncremented extends OTListEditInfo{

	public OTListEditRemoteCountIncremented(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public OTListEditRemoteCountIncremented(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditRemoteCountIncremented toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditRemoteCountIncremented(aMessage, 
				aSuperClassInfo);		
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static OTListEditRemoteCountIncremented newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditRemoteCountIncremented retVal = new OTListEditRemoteCountIncremented(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditRemoteCountIncremented newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditRemoteCountIncremented newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditsent.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class OTListEditSent extends OTListEditInfo{

	public OTListEditSent(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public OTListEditSent(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static OTListEditSent toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new OTListEditSent(aMessage, 
				aSuperClassInfo);		
	}
	
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static OTListEditSent newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		OTListEditSent retVal = new OTListEditSent(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static OTListEditSent newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, null);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static OTListEditSent newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, /*boolean anInServer,*/
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, /*anInServer,*/ aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/otlisteditsentold.java
package trace.ot;

import trace.echo.modular.ListEditInfo;

public class OTListEditSentOld extends OTTimeStampedListEditInfo{

	public OTListEditSentOld(String aMessage, String aProcessName,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aProcessName, aListEdit, anOTTimeStamp, aFinder);
	}
	public static String toString (ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp) {
		return  "-->" + toString(aListEdit, anOTTimeStamp);
	}
	public static OTListEditSentOld newCase(String aProcessName,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp,
			Object aFinder) {			
		String aMessage = toString(aListEdit, anOTTimeStamp);
		OTListEditSentOld retVal = new OTListEditSentOld(aMessage, aProcessName, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
//	public static OTTimeStampedListEditSent newCase(String aLocatable,
//			OTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(aLocatable, otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/ottimestampinfo.java
package trace.ot;

import java.util.List;

import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class OTTimeStampInfo extends ProcessInfo {
//	String userName;
	int localCount, remoteCount;
//	boolean isServer;

	public OTTimeStampInfo
			(String aMessage, 
			String aProcessName,
			int aLocalCount,
			int aRemoteCount, 
//			boolean anIsServer, 
			Object aFinder) {
		super(aMessage, aProcessName,  aFinder);
//		userName = aUserName;
		localCount = aLocalCount;
		remoteCount = aRemoteCount;
//		isServer = anIsServer;
	}
	public OTTimeStampInfo
	( 
	String aMessage,
	Integer aLocalCount,
	Integer aRemoteCount,
	ProcessInfo aProcessInfo
	
//	boolean anIsServer, 
//	Object aFinder
	) {
		super(aMessage, aProcessInfo);
		localCount = aLocalCount;
		remoteCount = aRemoteCount;
		
//userName = aUserName;
//localCount = aLocalCount;
//remoteCount = aRemoteCount;
//isServer = anIsServer;
}
	public OTTimeStampInfo
	( 
	String aMessage,
	OTTimeStampInfo anOTTimeStampInfo
	
	

	) {
		this(aMessage, anOTTimeStampInfo.getLocalCount(), anOTTimeStampInfo.getRemoteCount(), anOTTimeStampInfo);
		
//userName = aUserName;
//localCount = aLocalCount;
//remoteCount = aRemoteCount;
//isServer = anIsServer;
}
	
	public OTTimeStampInfo
	( 
	int aLocalCount,
	int aRemoteCount 
//	boolean anIsServer, 
//	Object aFinder
	) {
		this("", "", aLocalCount, aRemoteCount, null);
		
//userName = aUserName;
//localCount = aLocalCount;
//remoteCount = aRemoteCount;
//isServer = anIsServer;
}

//	public String getUserName() {
//		return userName;
//	}

	public int getLocalCount() {
		return localCount;
	}

	public int getRemoteCount() {
		return remoteCount;
	}

//	public boolean isServer() {
//		return isServer;
//	}
	public static final String COUNTS = "Counts";
	public static Integer getLocalCount(String aMessage){	
		List<String> args = getArgs(aMessage, COUNTS);
		return Integer.parseInt(args.get(0));
		
	}
	public static Integer getRemoteCount(String aMessage){	
		List<String> args = getArgs(aMessage, COUNTS);
		return Integer.parseInt(args.get(1));
		
	}
	public static OTTimeStampInfo toTraceable(String aMessage) {
		List<String> args = getArgs(aMessage, COUNTS);
		int aLocalCount = Integer.parseInt(args.get(0));
		int aRemoteCount = Integer.parseInt(args.get(1));
		ProcessInfo aProcessInfo = ProcessInfo.toTraceable(aMessage);
		return new OTTimeStampInfo(aMessage, aLocalCount, aRemoteCount, aProcessInfo);
	}
	public static String toString(
//			String aUserName, 
			int aLocalCount,
			int aRemoteCount 
//			boolean anIsServer
			) {
//		return "Counts(" + "L(" + aLocalCount + "), " + "R(" + aRemoteCount + "))";
		return 
				COUNTS + "(" +
//				"Counts(" + 
				aLocalCount + ", " + aRemoteCount + ")";

//				+ "(" +	(anIsServer?"Server": "Client") + ")";
		
	}

	public String alternativeToString() {
		return toString(localCount, remoteCount);
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/ottimestampedlisteditinfo.java
package trace.ot;

import trace.echo.modular.ListEditInfo;
import util.trace.TraceableInfo;
import util.trace.session.ProcessInfo;

public class OTTimeStampedListEditInfo extends ProcessInfo {
	OTTimeStampInfo otTimeStamp;
	ListEditInfo listEdit;

	// String userName;
	// int localCount, remoteCount;
	// boolean isServer;

	public OTTimeStampedListEditInfo(String aMessage, String aProcessName, ListEditInfo aListEdit,
			OTTimeStampInfo anOTTimeStamp, Object aFinder) {
		super(aMessage, aProcessName, aFinder);
		otTimeStamp = anOTTimeStamp;
		listEdit = aListEdit;

	}

	// public OTTimeStampedListEditInfo
	// (ListEditInfo aListEdit,
	// String aUser, boolean anIsServer,
	// OTTimeStampInfo anOTTimeStamp,
	// Object aFinder) {
	// this("", aListEdit, new UserOTTimeStampInfo(aUser, anOTTimeStamp,
	// anIsServer), null );
	//
	// }
	public OTTimeStampedListEditInfo(ListEditInfo aListEdit,

	OTTimeStampInfo anOTTimeStamp) {
		this("",  "", aListEdit, anOTTimeStamp, null);

	}

	public static String toString(String aProcessName, ListEditInfo aListEdit,
			OTTimeStampInfo anOTTimeStamp) {
		return toString(aProcessName) + "[" + aListEdit.alternativeToString() + ","
				+ anOTTimeStamp.alternativeToString() + "]";

	}

	public String alternativeToString() {
		return toString(processName, listEdit, otTimeStamp);
	}

	public OTTimeStampInfo getOTTimeStamp() {
		return otTimeStamp;
	}

	public ListEditInfo getListEdit() {
		return listEdit;
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/ottracechecker.java
package trace.ot;

import java.util.ArrayList;
import java.util.List;

import bus.uigen.oadapters.ObjectAdapter;
import bus.uigen.query.AnObjectQuery;
import bus.uigen.query.ObjectQuery;
import bus.uigen.trace.TraceUtility;
import trace.echo.modular.ModularEchoTraceChecker;
import util.trace.Traceable;
import util.trace.TraceableLog;
import util.trace.console.ConsoleInput;
import util.trace.console.ConsoleOutput;
import static bus.uigen.trace.TraceUtility.*;
import static bus.uigen.query.QueryUtility.*;

public class OTTraceChecker extends ModularEchoTraceChecker{
	
	static Class[] otExpectedClasses = {
			OTListEditBuffered.class,
			OTListEditReceived.class,
			OTListEditSent.class,
			OTListEditRemoteCountIncremented.class,
			InitialOTTimeStampCreated.class,
			LocalEditCountIncremented.class,
			LocalSiteCountIncremented.class,
			RemoteSiteCountIncremented.class,
			ConcurrentEdits.class,
			NonConcurrentEdits.class			
			
	};
	

	public static boolean compareOTSequences(
			List<Traceable> aTestTraceableList, 
			List<Traceable> aCorrectTraceableList) {
		System.out.println("Comparing OT Sequences");
		TraceableLog traceableLog = TraceUtility.startNewTrace();
//		String[] aProperties = {"Output"};
		
//		ObjectQuery[] objectQueries = traceablesToQueries(aCorrectTraceableList);
//		boolean retVal = inOrder(aFilteredTest, objectQueries, anExpe);
		boolean retVal = inOrder(aTestTraceableList, aCorrectTraceableList, expectedClasses(), true);
		TraceUtility.stopExistingTrace(traceableLog);
		if (!retVal)
			System.out.println("IM Sequence Test Failed");
		return retVal;		
	
		
		
	}
	
	

}
//END OF FILE
//START OF FILE: src/trace/ot/remotesitecountincremented.java
package trace.ot;


public class RemoteSiteCountIncremented extends UserOTTimeStampInfo{
	
	public RemoteSiteCountIncremented(String aMessage, String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			Boolean isServer,
			Object aFinder) {
		super(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, isServer, aFinder);
	}
	public RemoteSiteCountIncremented(String aMessage, 
			UserOTTimeStampInfo aTimeStampInfo) {
		super(aMessage, aTimeStampInfo);
	}
	public static RemoteSiteCountIncremented toTraceable(String aMessage) {
		UserOTTimeStampInfo aTimeStampInfo = UserOTTimeStampInfo.toTraceable(aMessage);
		return new RemoteSiteCountIncremented(aMessage, 
				aTimeStampInfo);		
	}
	public static RemoteSiteCountIncremented newCase(
			String aProcessName,
			String aUserName, 
			int aLocalCount, 
			int aRemoteCount,
			/*boolean anInServer,*/
			Object aFinder) {
		String aMessage = toString(aProcessName, aUserName, aLocalCount, aRemoteCount, null /*anIsServer*/);
		RemoteSiteCountIncremented retVal = new RemoteSiteCountIncremented(aMessage, aProcessName, aUserName, aLocalCount, aRemoteCount, null, /*anInServer,*/ aFinder);
		retVal.announce();
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/trace/ot/transformationoperands.java
package trace.ot;

import trace.echo.modular.ListEditInfo;

public class TransformationOperands extends OTListEditPairInfo{

	public TransformationOperands(String aMessage, String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
		super(aMessage, aProcessName, aFirst, aSecond, aFinder);
	}
	public TransformationOperands(String aMessage, String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
//			Boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
//			Boolean aSecondIsServer,
			Object aFinder) {
		super(aMessage, aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, null /*aFirstIsServer,*/, aSecondEdit, aSecondTimeStamp, aSecondUser, null/*aSecondIsServer,*/, aFinder);
	}
	public TransformationOperands(String aMessage, OTListEditPairInfo aPairInfo) {
		super(aMessage, aPairInfo);
	}
	
	public static TransformationOperands toTraceable (String aMessage) {
		OTListEditPairInfo aPairInfo = OTListEditPairInfo.toTraceable(aMessage);
		return new TransformationOperands (aMessage, aPairInfo);
		}
	public static TransformationOperands newCase(String aProcessName,
			OTListEditInfo aFirst, OTListEditInfo aSecond, Object aFinder) {
			String aMessage = toString(aProcessName, aFirst, aSecond);
			TransformationOperands retVal = new TransformationOperands(aMessage, aProcessName, aFirst, aSecond, aFinder);
			retVal.announce();
			return retVal;
		
	}
	public static TransformationOperands newCase(String aProcessName,
			ListEditInfo aFirstEdit,
			OTTimeStampInfo aFistTimeStamp,
			String aFirstUser,
//			boolean aFirstIsServer,
			ListEditInfo aSecondEdit,
			OTTimeStampInfo aSecondTimeStamp,
			String aSecondUser,
//			boolean aSecondIsServer,
			Object aFinder) {
		
		return newCase(aProcessName, 
				new OTListEditInfo(
						aFirstEdit, 
						new UserOTTimeStampInfo(aFirstUser, aFistTimeStamp, null /* aFirstIsServer*/, aFinder)),
						
				new OTListEditInfo(
						aSecondEdit, 
						new UserOTTimeStampInfo(aSecondUser, aSecondTimeStamp, null /* aSecondIsServer*/, aFinder)),	
				aFinder);
		
//		return newCase (aProcessName, aFirstEdit, aFistTimeStamp, aFirstUser, aFirstIsServer, aSecondEdit, aSecondTimeStamp, aSecondUser, aSecondIsServer, aFinder);
	}
	
		

}
//END OF FILE
//START OF FILE: src/trace/ot/transformationresult.java
package trace.ot;

import im.OperationName;
import trace.echo.modular.ListEditInfo;

public class TransformationResult extends OTListEditInfo{

	public TransformationResult(String aMessage, String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp,
			Object aFinder) {
		super(aMessage, aLocatable,  aListEdit, anOTTimeStamp, aFinder);
	}
	public TransformationResult(String aMessage, 
			OTListEditInfo aSuperClassInfo) {
		super(aMessage, aSuperClassInfo);
	}
	public static TransformationResult toTraceable(String aMessage) {
		OTListEditInfo aSuperClassInfo = OTListEditInfo.toTraceable(aMessage);
		return new TransformationResult(aMessage, 
				aSuperClassInfo);		
	}
//	public static String toString (String aLocatable, ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp) {
//		return  "@" + aLocatable + UserOTTimeStampedListEditInfo.toString(aListEdit, anOTTimeStamp);
//	}
	public static TransformationResult newCase(String aLocatable,
			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			Object aFinder) {			
		String aMessage = toString(aLocatable, aListEdit, anOTTimeStamp);
		TransformationResult retVal = new TransformationResult(aMessage, aLocatable, aListEdit, anOTTimeStamp, aFinder);
		retVal.announce();
		return retVal;
	}
	public static TransformationResult newCase(String aLocatable,
			ListEditInfo aListEdit, OTTimeStampInfo anOTTimeStamp/*, String aSourceOrDestination*/,
			String aUserName, boolean anIsServer,
			Object aFinder) {
		UserOTTimeStampInfo userOTTimeStampInfo = new UserOTTimeStampInfo(aLocatable, aUserName, anOTTimeStamp, anIsServer);
		return newCase(aLocatable, aListEdit, userOTTimeStampInfo, aFinder);
	}
	
	public static TransformationResult newCase(String aLocatable,
			OperationName aName, int anIndex, Object anElement,
			int aLocalCount, int aRemoteCount, 
			String aUserName, boolean anIsServer,
			Object aFinder) {
		ListEditInfo aListEditInfo = new ListEditInfo(aName, anIndex, anElement);
		OTTimeStampInfo anOTTimeStampInfo = new OTTimeStampInfo(aLocalCount, aRemoteCount);
		return newCase(aLocatable, aListEditInfo, anOTTimeStampInfo,  aUserName, anIsServer, aFinder);
	}
	
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			ListEditInfo aListEdit, UserOTTimeStampInfo anOTTimeStamp, String aSourceOrDestination,
//			Object aFinder) {			
//		String aMessage = toString(aListEdit, anOTTimeStamp);
//		UserOTTimeStampedListEditSent retVal = new UserOTTimeStampedListEditSent(aMessage/*, aLocatable*/, aListEdit, anOTTimeStamp, aFinder);
//		retVal.announce();
//		return retVal;
//	}
//	public static UserOTTimeStampedListEditSent newCase(/*String aLocatable,*/
//			UserOTTimeStampedListEditInfo otTimeStampedListEditInfo, String aSourceOrDestination,
//			Object aFinder) {			
//		return newCase(/*aLocatable,*/ otTimeStampedListEditInfo.getListEdit(), otTimeStampedListEditInfo.getOTTimeStamp(), aSourceOrDestination, aFinder);
//	}

}
//END OF FILE
//START OF FILE: src/trace/ot/userottimestampinfo.java
package trace.ot;

import java.util.List;

import util.trace.session.ProcessInfo;


public class UserOTTimeStampInfo extends OTTimeStampInfo {
	String userName;
	// int localCount, remoteCount;
	Boolean isServer;

	public UserOTTimeStampInfo(String aMessage,  String aProcessName, String aUserName,
			int aLocalCount, int aRemoteCount, Boolean anIsServer,
			Object aFinder) {
		super(aMessage, aProcessName, aLocalCount, aRemoteCount, aFinder);
		userName = aUserName;
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
		isServer = anIsServer;
	}

	public UserOTTimeStampInfo(String aProcessName, String aUserName, int aLocalCount,
			int aRemoteCount, Boolean anIsServer) {
		this("", aProcessName, aUserName, aLocalCount, aRemoteCount, anIsServer, null);
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
	}
	public UserOTTimeStampInfo(String aProcessName, String aUserName,  OTTimeStampInfo anOTTimeStampInfo, Boolean anIsServer) {
		this("", "",  aUserName, anOTTimeStampInfo.getLocalCount(), anOTTimeStampInfo.getRemoteCount(), anIsServer, null);
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
	}
	public UserOTTimeStampInfo(String aUserName, OTTimeStampInfo anOTTimeStamp, Boolean isServer, Object aFinder) {
		this("", "", aUserName, anOTTimeStamp.getLocalCount(), anOTTimeStamp.getRemoteCount(), isServer, aFinder);
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
	}
	public UserOTTimeStampInfo(String aMessage, String aUserName, OTTimeStampInfo anOTTimeStampInfo) {
		super(aMessage, anOTTimeStampInfo);
		userName = aUserName;
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
	}
	
	public UserOTTimeStampInfo(String aMessage, UserOTTimeStampInfo aUserOTTimeStampInfo) {
		this(aMessage, aUserOTTimeStampInfo.getMessage(), aUserOTTimeStampInfo);
		// localCount = aLocalCount;
		// remoteCount = aRemoteCount;
	}

	public String getUserName() {
		return userName;
	}

	// public int getLocalCount() {
	// return localCount;
	// }
	//
	// public int getRemoteCount() {
	// return remoteCount;
	// }

	// public boolean isServer() {
	// return isServer;
	// }
	
	public static String getUserName(String aMessage) {
		return getArgs(aMessage, USER_NAME).get(0);
	}
	public static UserOTTimeStampInfo toTraceable(String aMessage) {
		String aUserName = getUserName(aMessage);
		OTTimeStampInfo anOTTimeStampInfo = OTTimeStampInfo.toTraceable(aMessage);
		return new UserOTTimeStampInfo(aMessage, aUserName, anOTTimeStampInfo);		
	}
	public static final String USER_NAME = "User";
	public static String userNameToString (String aUserName) {
		return (aUserName == null|| !longMessage)?"":
//				+ " User(" + 
			    USER_NAME + "(" +
				aUserName + ")";
	}
	public static String isServerToString(Boolean isServer) {
		return (isServer == null || !longMessage)?"": 
				(", Actor(" + (isServer?"Server":"Client"));
	}
	public static String toString(String aProcessName, String aUserName, int aLocalCount,
			int aRemoteCount, Boolean anIsServer) {
		return toString(aProcessName) + " " + userNameToString(aUserName) + " " + OTTimeStampInfo.toString(aLocalCount, aRemoteCount)
		// "[local: " + aLocalCount + ", remote: " + aRemoteCount + "]" ;
//		 + "(" + (anIsServer?"Server": "Client") + ")";
				+ isServerToString(anIsServer);

	}

	public String alternativeToString() {
		return toString(processName, userName, localCount, remoteCount, isServer);
	}

}
//END OF FILE
//START OF FILE: src/widgets/acharinsertion.java
package widgets;


public class ACharInsertion extends AnEdit implements CharInsertion{
//	String name;
//	
//	int index;
//	char ch;
	public ACharInsertion (String theName, int theIndex, char theCh) {
		super(theName, theIndex, theCh);
	}
//	/* (non-Javadoc)
//	 * @see widgets.CharInsertion#getIndex()
//	 */
//	public int getIndex() {
//		return index;
//	}
//	/* (non-Javadoc)
//	 * @see widgets.CharInsertion#setIndex(int)
//	 */
//	public void setIndex(int index) {
//		this.index = index;
//	}
//	/* (non-Javadoc)
//	 * @see widgets.CharInsertion#getCh()
//	 */
//	public char getChar() {
//		return ch;
//	}
//	/* (non-Javadoc)
//	 * @see widgets.CharInsertion#setCh(int)
//	 */
//	public void setChar( char ch) {
//		this.ch = ch;
//	}
//	public String getName() {
//		return name;
//	}
//	public void setName(String name) {
//		this.name = name;
//	}
	public Edit copy() {
		return new ACharInsertion(name, index, ch);
	}
}
//END OF FILE
//START OF FILE: src/widgets/atextfield.java
package widgets;


import java.awt.Font;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;

public class ATextField extends ATextFieldInputTracker implements  ListenablePainter, TextField {
	final static int CARAT_LENGTH = 10; 
	int charWidth;
	public ATextField(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}			
	public void paint (ADelegateFrame theDelegateFrame, ListenableGraphics g) {
		Font font = g.getFont();
		metrics = g.getFontMetrics(font);
		//System.out.println(metrics.charWidth('a') + " " + metrics.charWidth('g'));
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString(stringBuffer.toString(), X_OFFSET, Y_OFFSET);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();		
	}
	
}
//END OF FILE
//START OF FILE: src/widgets/atextfieldincoupler.java
package widgets;
import util.session.PeerMessageListener;
public class ATextFieldInCoupler implements PeerMessageListener {
	TextField textField;
	String myName;
	public ATextFieldInCoupler(TextField theTextField) {
		textField = theTextField;
		myName = textField.getName();
	}
	public void objectReceived(Object message, String userName) {
		CharInsertion charInsertion = (CharInsertion) message;
		if (charInsertion.getName().equals(myName))
			textField.insert(charInsertion.getIndex(), charInsertion.getChar());
		
	}
	

}
//END OF FILE
//START OF FILE: src/widgets/atextfieldinputtracker.java
package widgets;

import java.awt.FontMetrics;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

import util.awt.ADelegateFrame;
import windowApp.ACursorTrackerOfDelegateFrame;

public class ATextFieldInputTracker extends ACursorTrackerOfDelegateFrame {
	public static int Y_OFFSET = 50;
	public static int X_OFFSET = 10;
	public static int  CHAR_WIDTH = 7;
	public static int ERROR = 3;
	StringBuffer stringBuffer = new StringBuffer();
	int insertionIndex = 0;
	FontMetrics metrics;
	List<TextFieldListener> listeners = new ArrayList();
	public ATextFieldInputTracker(ADelegateFrame theFrame) {
		super(theFrame);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		charY = Y_OFFSET;
		int[] positionAndCoordinate = toPositionAndCoordinate(charX);		
		insertionIndex = positionAndCoordinate[0];
		charX = positionAndCoordinate[1];
	}
	int toCoordinate(int position) {
		int retVal = X_OFFSET;
		for (int i = 0; i < stringBuffer.length(); i++)
			retVal += metrics.charWidth(stringBuffer.charAt(i));
		return retVal;
	}
	int[] toPositionAndCoordinate(int coordinate) {
		int indexFound = 0;
		int totalOffset = X_OFFSET;
		for (int i = 0; i < stringBuffer.length(); i++) {
			int charSize = metrics.charWidth(stringBuffer.charAt(i));			
			if (totalOffset + charSize - ERROR > coordinate)
				break;
			else {
				indexFound++;
				totalOffset += charSize;
			}
		}
		int[] retVal = {indexFound, totalOffset};
		return retVal;			
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		//insert(insertionIndex, lastChar);
		stringBuffer.insert(insertionIndex, lastChar);
		notifyListeners(insertionIndex, lastChar);
		insertionIndex++;
		charX += metrics.charWidth(lastChar);
	}
	
	public void insert(int index, char ch) {
		stringBuffer.insert(index, ch);		
		//charX += metrics.charWidth(lastChar);
		delegateFrame.repaint();
		
	}
	void notifyListeners(int index, char ch) {
		for (TextFieldListener textFieldListener:listeners)
			textFieldListener.elementInserted(index, ch);
	}
	public void addTextFieldListener(TextFieldListener theListener) {
		listeners.add(theListener);
	}
	public String getName() {
		return delegateFrame.getTitle();
	}
	
}
//END OF FILE
//START OF FILE: src/widgets/atextfieldoutcoupler.java
package widgets;

import util.session.Communicator;

public class ATextFieldOutCoupler implements TextFieldListener {
	TextField textField;
	Communicator communicator;
	public ATextFieldOutCoupler(TextField theTextField, Communicator theCommunicator) {
		textField = theTextField;
		communicator = theCommunicator;
		textField.addTextFieldListener(this);
	}
	@Override
	public void elementInserted(int index, char ch) {
		communicator.toOthers(new ACharInsertion(textField.getName(), index, ch));		
	}
}
//END OF FILE
//START OF FILE: src/widgets/ancolabtextfieldcomposerandlauncher.java
package widgets;
import old.echoerAndIM.AnIMComposerAndLauncher;
import util.session.Communicator;
import util.session.PeerMessageListener;
public class AnColabTextFieldComposerAndLauncher {
	public static final String APPLICATION_NAME = "Widgets Editor";
	static Communicator communicator;
	public static void main (String[] args) {		
		Communicator communicator = AnIMComposerAndLauncher.createCommunicator(args, APPLICATION_NAME);
		createCollaborativeTextField("text 1", communicator);
		createCollaborativeTextField("text 2", communicator);
		communicator.join();		
	}
	public static TextField createCollaborativeTextField(String theTitle, Communicator communicator) {
		TextField textField = TextFieldLauncher.createTextField(theTitle);
		new ATextFieldOutCoupler(textField, communicator);
		PeerMessageListener inCoupler = new ATextFieldInCoupler(textField);
		communicator.addPeerMessageListener(inCoupler);	
		return textField;
	}
	
}
//END OF FILE
//START OF FILE: src/widgets/anedit.java
package widgets;


public abstract class AnEdit implements Edit{
	String name;
	
	int index;
	char ch;
	public AnEdit (String theName, int theIndex, char theCh) {
		index = theIndex;
		ch = theCh;
		name = theName;
	}
	/* (non-Javadoc)
	 * @see widgets.CharInsertion#getIndex()
	 */
	public int getIndex() {
		return index;
	}
	/* (non-Javadoc)
	 * @see widgets.CharInsertion#setIndex(int)
	 */
	public void setIndex(int index) {
		this.index = index;
	}
	/* (non-Javadoc)
	 * @see widgets.CharInsertion#getCh()
	 */
	public char getChar() {
		return ch;
	}
	/* (non-Javadoc)
	 * @see widgets.CharInsertion#setCh(int)
	 */
	public void setChar( char ch) {
		this.ch = ch;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String toString() {
		return "index:" + index + " char:" + ch; 
	}
	
}
//END OF FILE
//START OF FILE: src/widgets/charinsertion.java
package widgets;


public interface CharInsertion extends Edit {

	
}
//END OF FILE
//START OF FILE: src/widgets/edit.java
package widgets;

import java.io.Serializable;

public interface Edit extends Serializable {

	public abstract int getIndex();

	public abstract void setIndex(int index);

	public abstract char getChar();

	public abstract void setChar(char ch);
	public String getName();
	public void setName(String name);
	public Edit copy();
}
//END OF FILE
//START OF FILE: src/widgets/textfield.java
package widgets;

public interface TextField {
	public void insert(int index, char ch);
	public void addTextFieldListener(TextFieldListener theListener);
	public String getName();

}
//END OF FILE
//START OF FILE: src/widgets/textfieldlauncher.java
package widgets;

import util.awt.ADelegateFrame;

public class TextFieldLauncher {
	public static void main(String[] args) {
		TextField text1 = createTextField("text 1");
		text1.insert(0, 'a');
		createTextField("text 2");
	}
	public static TextField  createTextField(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		ATextField textField = new ATextField(frame);
		frame.setSize(300, 100);
		frame.setVisible(true);		
		return textField;
	}
}
//END OF FILE
//START OF FILE: src/widgets/textfieldlistener.java
package widgets;

public interface TextFieldListener {
	void elementInserted (int index, char ch);
}
//END OF FILE
//START OF FILE: src/windowapp/acharacterdrawer.java
package windowApp;


import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.DelegateFramePainter;

public class ACharacterDrawer extends ACursorTrackerOfDelegateFrame implements  DelegateFramePainter {
	final static int CARAT_LENGTH = 10; 
	public ACharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}		
	public void paint (ADelegateFrame theDelegateFrame, Graphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mouseClicked(MouseEvent event) {
		super.mouseClicked(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();		
	}	
}
//END OF FILE
//START OF FILE: src/windowapp/acursortracker.java
package windowApp;


import java.awt.Frame;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

public class ACursorTracker implements MouseListener, KeyListener{
	Frame frame;
	int charX, charY;
	char lastChar;		
	public ACursorTracker(Frame theFrame) {
		frame = theFrame;
		frame.addMouseListener(this);
		frame.addKeyListener(this);
	}		
	public void mousePressed(MouseEvent event) {
		charX = event.getX();
		charY = event.getY();
		frame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		lastChar = event.getKeyChar();
		frame.repaint();		
	}	
	public void mouseEntered(MouseEvent event) {	}	
	public void mouseExited(MouseEvent event) {}	
	public void mouseClicked(MouseEvent event) {}	
	public void mouseReleased(MouseEvent event) {}	
	public void keyPressed(KeyEvent event) {}	
	public void keyReleased(KeyEvent event) {} 
	
}
//END OF FILE
//START OF FILE: src/windowapp/acursortrackerofdelegateframe.java
package windowApp;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import util.awt.ADelegateFrame;

public class ACursorTrackerOfDelegateFrame implements MouseListener, KeyListener{
	protected ADelegateFrame delegateFrame;
	protected int charX, charY;
	protected char lastChar;		
	public ACursorTrackerOfDelegateFrame(ADelegateFrame theFrame) {
		delegateFrame = theFrame;
		delegateFrame.addMouseListener(this);
		delegateFrame.addKeyListener(this);
	}		
	public void mousePressed(MouseEvent event) {
		charX = event.getX();
		charY = event.getY();
	}
	public void keyTyped(KeyEvent event) {
		lastChar = event.getKeyChar();		
	}	
	public void mouseEntered(MouseEvent event) {	}	
	public void mouseExited(MouseEvent event) {}	
	public void mouseClicked(MouseEvent event) {}	
	public void mouseReleased(MouseEvent event) {}	
	public void keyPressed(KeyEvent event) {}	
	public void keyReleased(KeyEvent event) {} 	
}
//END OF FILE
//START OF FILE: src/windowapp/aglobalinputtracker.java
package windowApp;

import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;
import util.awt.EventQueueHandler;
import util.awt.DelegateFramePainter;
import util.awt.SerializableEvent;

public class AGlobalInputTracker implements EventQueueHandler, MouseListener, KeyListener, DelegateFramePainter{	
	String lastFrameTitle;	
	ADelegateFrame globalFrame;
	int lastX, lastY;
	char lastChar = ' ';
	public AGlobalInputTracker(ADelegateFrame theGlobalFrame) {
		globalFrame = theGlobalFrame;
		globalFrame.addMouseListener(this);
		globalFrame.addKeyListener(this);
		globalFrame.addPainter(this);
		AnInputQueue.getEventQueue().addEventQueueHandler(this);
	}
	public void newEvent(SerializableEvent event) {
		if (event.getSource() == globalFrame.getID() ||
		    !event.isKeyEvent() && !event.isMousePressedEvent())
			return;
		int frameId = event.getSource();
		ADelegateFrame frame =  ADelegateFrame.getFrame(frameId);
		lastFrameTitle = frame.getTitle();
		globalFrame.processEvent(event);
	}	
	public void paint(ADelegateFrame theFrame, Graphics g) {
		g.drawString(lastFrameTitle+':'+lastChar, lastX, lastY);
	}
	public void mousePressed(MouseEvent event) {
		lastX = event.getX();
		lastY = event.getY();
		globalFrame.repaint();
	}
    public void keyPressed(KeyEvent event) {
		lastChar = event.getKeyChar();
		globalFrame.repaint();
	}		
	public void mouseClicked(MouseEvent arg0) {		
	}	
	public void mouseEntered(MouseEvent arg0) {		
	}
	public void mouseExited(MouseEvent arg0) {		
	}	
	public void mouseReleased(MouseEvent arg0) {
		
	}
	public void keyReleased(KeyEvent arg0) {
		
	}	
	public void keyTyped(KeyEvent arg0) {
		
	}
	
	
}
//END OF FILE
//START OF FILE: src/windowapp/aglobalpainter.java
package windowApp;

import util.awt.ADelegateFrame;
import util.awt.AnOutputQueue;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;
import util.awt.OutputListener;
import util.awt.SerializableFrameRequest;
import util.awt.SerializableGraphicsRequest;

public class AGlobalPainter  implements ListenablePainter, OutputListener {
	SerializableGraphicsRequest lastGraphicsRequest;
	String lastFrameTitle;	
	ADelegateFrame globalFrame;
	public AGlobalPainter(ADelegateFrame theGlobalFrame) {
		globalFrame = theGlobalFrame;
		globalFrame.addPainter(this);
		AnOutputQueue.addOutputListener(this);
	}	
	public void paint(ADelegateFrame theFrame, ListenableGraphics g) {
		if (lastGraphicsRequest == null) return;
		Object[] args = lastGraphicsRequest.getArgs();			
		g.drawString(lastFrameTitle+':'+(String) args[0], (Integer) args[1], (Integer) args[2]);
				
	}	
	public void newGraphicsRequest(SerializableGraphicsRequest graphicsRequest) {
		if (graphicsRequest.getSource() == globalFrame.getID()	||
	       !graphicsRequest.getName().equals(SerializableGraphicsRequest.DRAW_STRING))
			 return;
		lastGraphicsRequest = graphicsRequest;
		lastFrameTitle = ADelegateFrame.getFrame(graphicsRequest.getSource()).getTitle();
		globalFrame.repaint();
	}
    public void newFrameRequest(SerializableFrameRequest frameRequest) {
		
	}	
}
//END OF FILE
//START OF FILE: src/windowapp/alistenablecharacterdrawer.java
package windowApp;


import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import util.awt.ADelegateFrame;
import util.awt.ListenableGraphics;
import util.awt.ListenablePainter;

public class AListenableCharacterDrawer extends ACursorTrackerOfDelegateFrame implements  ListenablePainter {
	final static int CARAT_LENGTH = 10; 
	public AListenableCharacterDrawer(ADelegateFrame theDelegateFrame) {
		super(theDelegateFrame);
		delegateFrame.addPainter(this);
	}
		
	public void paint (ADelegateFrame theDelegateFrame, ListenableGraphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + lastChar, charX, charY);
	}
	public void mousePressed(MouseEvent event) {
		super.mousePressed(event);
		delegateFrame.repaint();
	}
	public void keyTyped(KeyEvent event) {
		super.keyTyped(event);
		delegateFrame.repaint();		
	}	
}
//END OF FILE
//START OF FILE: src/windowapp/alocaleventforwardertofixedframe.java
package windowApp;

import util.awt.ADelegateFrame;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;

public class ALocalEventForwarderToFixedFrame implements EventQueueHandler{
	ADelegateFrame frame;
	public ALocalEventForwarderToFixedFrame(ADelegateFrame theFrame) {
		frame = theFrame;
	}
	public void newEvent(SerializableEvent event) {
		//ADelegateFrame frame =  (ADelegateFrame)event.getSource();
		frame.processEvent(event);		
	}
}
//END OF FILE
//START OF FILE: src/windowapp/alocaleventmirrorer.java
package windowApp;

import util.awt.ADelegateFrame;
import util.awt.EventQueueHandler;
import util.awt.SerializableEvent;

public class ALocalEventMirrorer implements EventQueueHandler{
	ADelegateFrame frame1, frame2;
	public ALocalEventMirrorer(ADelegateFrame theFrame1, ADelegateFrame theFrame2) {
		frame1 = theFrame1;
		frame2 = theFrame2;
	}
	public void newEvent(SerializableEvent event) {
		int frameId = event.getSource();
		ADelegateFrame frame =  ADelegateFrame.getFrame(frameId);
		//ADelegateFrame frame =  (ADelegateFrame)event.getSource();
		if (frame == frame1) {
			frame2.processEvent(event);	
			frame2.repaint();
		} else {
			frame1.processEvent(event);
			frame1.repaint();
		}
	}
}
//END OF FILE
//START OF FILE: src/windowapp/aninheritingcharacterdrawer.java
package windowApp;


import java.awt.Frame;
import java.awt.Graphics;

import util.awt.ADelegateFrame;

public class AnInheritingCharacterDrawer extends Frame {
	final static int CARAT_LENGTH = 10; 
	ADelegateFrame delegateFrame;
	int charX, charY;
	char c;	
	
	public void paint ( Graphics g) {
		g.drawLine(charX, charY, charX, charY - CARAT_LENGTH);
		g.drawString("" + c, charX, charY);
	}	
}
//END OF FILE
//START OF FILE: src/windowapp/characterdrawerlauncher.java
package windowApp;

import util.awt.ADelegateFrame;

public class CharacterDrawerLauncher {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
	}
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		new ACharacterDrawer(frame);
		frame.setSize(300, 200);
		frame.setVisible(true);		
		return frame;
	}
}
//END OF FILE
//START OF FILE: src/windowapp/globalpaintercomposerandlauncher.java
package windowApp;

import util.awt.ADelegateFrame;

public class GlobalPainterComposerAndLauncher  {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
		createGlobalFrameAndPainter();
	}
	public static ADelegateFrame createCharacterDrawer(String theTitle) {
		ADelegateFrame frame = new ADelegateFrame(theTitle);
		new AListenableCharacterDrawer(frame);
		frame.setSize(300, 200);
		frame.setVisible(true);		
		return frame;
	}
	public static ADelegateFrame createGlobalFrameAndPainter() {
		ADelegateFrame globalFrame = new ADelegateFrame("global frame");
		new AGlobalPainter(globalFrame);
		globalFrame.setSize(300, 200);
		globalFrame.setVisible(true);
		return globalFrame;		
	}
}
//END OF FILE
//START OF FILE: src/windowapp/globaltrackercomposerandlauncher.java
package windowApp;

import util.awt.ADelegateFrame;

public class GlobalTrackerComposerAndLauncher extends CharacterDrawerLauncher {
	public static void main(String[] args) {
		createCharacterDrawer("frame 1");
		createCharacterDrawer("frame 2");
		createGlobalFrameAndPainter();
	}
	public static ADelegateFrame createGlobalFrameAndPainter() {
		ADelegateFrame globalFrame = new ADelegateFrame("global frame");
		new AGlobalPainter(globalFrame);
		globalFrame.setSize(300, 200);
		globalFrame.setVisible(true);
		return globalFrame;		
	}
}
//END OF FILE
//START OF FILE: src/windowapp/localmirror.java
package windowApp;

import java.lang.reflect.Method;
import java.util.List;

import javax.swing.JOptionPane;

import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;

public class LocalMirror {
	public static void main(String[] args) {
//		if (args.length != 1) {
//			System.out.println("Missing class name argument");
//			System.exit(1);
//		}
		  String className = JOptionPane.showInputDialog(null,
				  "Window app class name?",
				  "Enter class name",
				  JOptionPane.QUESTION_MESSAGE);
		  
		try {
			Class c = Class.forName(className);
			Class[] parameterTypes = {args.getClass()};
			Method mainMethod = c.getMethod("main", parameterTypes);
			Object[] parameters = {args};
			mainMethod.invoke(null, parameters);
		} catch (Exception e) {
			e.printStackTrace();
		}		
		AnInputQueue.getEventQueue().clearEventQueuehandlers();
		//LocalCharacterDrawer.main(args);
		List<ADelegateFrame> frames = ADelegateFrame.getAllFrames();
		if (frames.size() != 2) {
			System.out.println("Mirror requires exactly two frames to be created by application");
		}		
		AnInputQueue.getEventQueue().addEventQueueHandler(new ALocalEventMirrorer(frames.get(0), frames.get(1)));

	}	
}
//END OF FILE
//START OF FILE: src/windowapp/localmirrorcharacterdrawer.java
package windowApp;

import util.awt.ADelegateFrame;
import util.awt.AnInputQueue;

public class LocalMirrorCharacterDrawer extends CharacterDrawerLauncher{
	public static void main(String[] args) {
		ADelegateFrame frame1 = createCharacterDrawer("frame 1");
		ADelegateFrame frame2 = createCharacterDrawer("frame 2");
		AnInputQueue.getEventQueue().clearEventQueuehandlers();
		AnInputQueue.getEventQueue().addEventQueueHandler(new ALocalEventMirrorer(frame1, frame2));
	}		
//	public static ADelegateFrame createCharacterDrawer(String theTitle) {
//		ADelegateFrame frame = new ADelegateFrame();
//		frame.setTitle(theTitle);
//		new ACharacterDrawer(frame);
//		frame.setSize(300, 200);
//		frame.setVisible(true);		
//		return frame;
//	}
}
//END OF FILE
