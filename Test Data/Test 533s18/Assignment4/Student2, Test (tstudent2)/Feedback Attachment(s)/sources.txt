//START OF FILE: src/common/client/clientparameters.java
package common.client;


public interface ClientParameters {
	String SERVER_HOST = "localhost";

}
//END OF FILE
//START OF FILE: src/common/client/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package common.client;
//END OF FILE
//START OF FILE: src/common/commandprocessor/alicecommandprocessorfactory.java
package common.commandprocessor;

import common.ui.AliceUI;
import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.ADistributedProcessController;

public class AliceCommandProcessorFactory extends ADistributedProcessController implements AliceUI{

	static HalloweenCommandProcessor singleton;
	public static HalloweenCommandProcessor getOrCreateSingleton() {
		if (singleton == null) {
			singleton = BeauAndersonFinalProject.createSimulation(
					SIMULATION_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
		CommandProcessorFactory.setCommandProcessor(singleton);
		}
		return singleton;
			
	}

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/bobcommandprocessorfactory.java
package common.commandprocessor;

import common.ui.BobUI;
import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.ADistributedProcessController;

public class BobCommandProcessorFactory extends ADistributedProcessController implements BobUI{

	static HalloweenCommandProcessor singleton;
	public static HalloweenCommandProcessor getOrCreateSingleton() {
		if (singleton == null) {
			singleton = BeauAndersonFinalProject.createSimulation(
					SIMULATION_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
		CommandProcessorFactory.setCommandProcessor(singleton);
		}
		return singleton;
			
	}

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/cathycommandprocessorfactory.java
package common.commandprocessor;

import common.ui.CathyUI;
import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.ADistributedProcessController;

public class CathyCommandProcessorFactory extends ADistributedProcessController implements CathyUI{

	static HalloweenCommandProcessor singleton;
	public static HalloweenCommandProcessor getOrCreateSingleton() {
		if (singleton == null) {
			singleton = BeauAndersonFinalProject.createSimulation(
					SIMULATION_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
		CommandProcessorFactory.setCommandProcessor(singleton);
		}
		return singleton;
			
	}

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/commandprocessorfactory.java
package common.commandprocessor;

import stringProcessors.HalloweenCommandProcessor;

public class CommandProcessorFactory {
	static HalloweenCommandProcessor commandProcessor;

	public static HalloweenCommandProcessor getCommandProcessor() {
		return commandProcessor;
	}

	public static void setCommandProcessor(
			HalloweenCommandProcessor commandProcessor) {
		CommandProcessorFactory.commandProcessor = commandProcessor;
	}
	

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/davidcommandprocessorfactory.java
package common.commandprocessor;

import common.ui.DavidUI;
import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.ADistributedProcessController;

public class DavidCommandProcessorFactory extends ADistributedProcessController implements DavidUI{

	static HalloweenCommandProcessor singleton;
	public static HalloweenCommandProcessor getOrCreateSingleton() {
		if (singleton == null) {
			singleton = BeauAndersonFinalProject.createSimulation(
					SIMULATION_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
		CommandProcessorFactory.setCommandProcessor(singleton);
		}
		return singleton;
			
	}

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/programmedcommandexecutor.java
package common.commandprocessor;

public interface ProgrammedCommandExecutor {
	String DO_NAME = "d";
	String UNDO_NAME = "u";
	String EXECUTE_NAME = "e";
	String FORWARD_X = "x";
	String FORWARD_Y = "y";
	void doTimedCommands();
	void undoTimedCommands();
	long getCommandExecutionTime();
	void executeCommandLoop();

}
//END OF FILE
//START OF FILE: src/common/commandprocessor/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package common.commandprocessor;
//END OF FILE
//START OF FILE: src/common/controller/atrickortreatclientcontroller.java
package common.controller;

import java.util.Scanner;

import common.commandprocessor.CommandProcessorFactory;
import stringProcessors.HalloweenCommandProcessor;
import util.annotations.Visible;
import util.misc.ThreadSupport;
import util.remote.ARelayerClientController;

public class ATrickOrTreatClientController extends ARelayerClientController implements TrickOrTreatClientController{
	public static final int NUM_Y_MOVES = 40;
	public static final int NUM_X_MOVES = 40;
	
//	public static final int MOVE_OFFSET = 3;

	public static final int NUM_DOS_UNDOS = 2;
	int interCommandTime = 0;
	
	long commandExecutionTime;
	protected boolean markCommands = true;
//	String lastSerializedObject = "";
//	String lastDeSerializedObject = "";


	
	@Visible(false)
	public void doTimedCommands() {
//		

		long startTime = System.currentTimeMillis();
		doCommands();
		long endTime = System.currentTimeMillis();
		setCommandExecutionTime ((endTime - startTime));
		System.out.println("Loop execution time:" + (endTime - startTime));
	}
	public void doCommands() {
//		System.out.println("Executing do commands");
		HalloweenCommandProcessor aCommandProcessor = CommandProcessorFactory.getCommandProcessor(); 

//		System.out.println("start time" + System.currentTimeMillis());
//		aCommandProcessor.processCommand("move 50 -50");
//		System.out.println("end time after one command" + System.currentTimeMillis());
		for (int i=0; i < NUM_X_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move 3 0");
			if (interCommandTime != 0)
				ThreadSupport.sleep(interCommandTime);


		}
		for (int i=0; i < NUM_Y_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move 0 -3");
			if (interCommandTime != 0)
				ThreadSupport.sleep(interCommandTime);
		}
		
//		System.out.println("Loop execution time:" + (endTime - startTime));
	}
	public void forwardYCommands() {
//		System.out.println("Executing do commands");
		HalloweenCommandProcessor aCommandProcessor = CommandProcessorFactory.getCommandProcessor(); 

//		System.out.println("start time" + System.currentTimeMillis());
//		aCommandProcessor.processCommand("move 50 -50");
//		System.out.println("end time after one command" + System.currentTimeMillis());
		
		for (int i=0; i < NUM_Y_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move 0 -3");
			if (interCommandTime != 0)
				ThreadSupport.sleep(interCommandTime);
		}
		
//		System.out.println("Loop execution time:" + (endTime - startTime));
	}
	public void forwardXCommands() {
//		System.out.println("Executing do commands");
		HalloweenCommandProcessor aCommandProcessor = CommandProcessorFactory.getCommandProcessor(); 

//		System.out.println("start time" + System.currentTimeMillis());
//		aCommandProcessor.processCommand("move 50 -50");
//		System.out.println("end time after one command" + System.currentTimeMillis());
		for (int i=0; i < NUM_X_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move 3 0");
			if (interCommandTime != 0)
				ThreadSupport.sleep(interCommandTime);


		}
		
//		System.out.println("Loop execution time:" + (endTime - startTime));
	}

	@Override
	public void undoTimedCommands() {


		long startTime = System.currentTimeMillis();
		System.out.println("start time" + System.currentTimeMillis());
		undoCommands();
		
		long endTime = System.currentTimeMillis();
		setCommandExecutionTime ((endTime - startTime));


		System.out.println("Loop execution time:" + (commandExecutionTime));
	
		
	}
	
	 void undoCommands() {

		HalloweenCommandProcessor aCommandProcessor = CommandProcessorFactory.getCommandProcessor(); 

//		long startTime = System.currentTimeMillis();
//		System.out.println("start time" + System.currentTimeMillis());
//		aCommandProcessor.processCommand("move 50 -50");
//		System.out.println("end time after one command" + System.currentTimeMillis());
		for (int i=0; i < NUM_Y_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move 0  3");


		}
		for (int i=0; i < NUM_X_MOVES; i++) {
//			aCommandProcessor.processCommand("move 1 -1");
			aCommandProcessor.setInputString("move -3 0");


		}
		
//		long endTime = System.currentTimeMillis();
//		commandExecutionTime = (endTime - startTime);
//
//		System.out.println("Loop execution time:" + (commandExecutionTime));
	
		
	}
	@Override
	public boolean isMarkCommands() {
		return markCommands;
	}
	@Override
	public void setMarkCommands(boolean markCommands) {
		this.markCommands = markCommands;
	}
	@Override
	@Visible(false)
	public long getCommandExecutionTime() {
		return commandExecutionTime;
	}
	@Override
	@Visible(false)
	public void setCommandExecutionTime(long commandExecutionTime) {
		this.commandExecutionTime = commandExecutionTime;
		propertyChangeSupport.firePropertyChange("CommandExecutionTime", 0, commandExecutionTime);
	}
	public void executeTimedCommands() {
		long startTime = System.currentTimeMillis();
		for (int i = 0; i < NUM_DOS_UNDOS; i++) {
			doCommands();
			undoCommands();
		}
		long endTime = System.currentTimeMillis();
		setCommandExecutionTime ((endTime - startTime));


//		System.out.println("Loop execution time:" + (commandExecutionTime));
	}
	protected static Scanner scanner = new Scanner(System.in);
	@Override
	public void executeCommandLoop() {
//		AScatterGatherSelectionManager.setMAX_OUTSTANDING_WRITES(1000);

		while (true) {
			System.out.println("Please input, u, d, e, x, y or a simulation command");
			String userInput = scanner.nextLine();
			if (userInput.equals(DO_NAME))
				doTimedCommands();
			else if (userInput.equals(UNDO_NAME))
				undoTimedCommands();
			else if (userInput.equals(EXECUTE_NAME))
				executeTimedCommands();
			else if (userInput.equals(FORWARD_X)) {
				forwardXCommands();
			} else if (userInput.equals(FORWARD_Y)) {
				forwardYCommands();
			} else
			{
				CommandProcessorFactory.getCommandProcessor().setInputString(userInput);
			}
			
		}
		
	}
	
	@Override
	public int getInterCommandTime() {
		return interCommandTime;
	}
	@Override
	public void setInterCommandTime(int interCommandTime) {
		this.interCommandTime = interCommandTime;
		propertyChangeSupport.firePropertyChange("InterCommandTime", 
				null, interCommandTime);
	}

}
//END OF FILE
//START OF FILE: src/common/controller/alicecontrollerui.java
package common.controller;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.AliceUI;
import util.trace.Tracer;

public class AliceControllerUI implements AliceUI {
	public static OEFrame createUI() {
		TrickOrTreatClientController aController = TrickOrTreatClientControllerFactory.getOrCreateSingleton();
		OEFrame controllerFrame = ObjectEditor.edit(aController);
		controllerFrame.setLocation(CONTROLLER_X, CONTROLLER_Y);
		controllerFrame.setSize(CONTROLLER_WIDTH, CONTROLLER_HEIGHT);
		controllerFrame.setTitle(NAME);
		Tracer.showWarnings(false);
//		Tracer.showInfo(false);
		return controllerFrame;
		
	}

}
//END OF FILE
//START OF FILE: src/common/controller/bobcontrollerui.java
package common.controller;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.BobUI;
import util.trace.Tracer;

public class BobControllerUI implements BobUI {
	public static OEFrame createUI() {
		TrickOrTreatClientController aController = TrickOrTreatClientControllerFactory.getOrCreateSingleton();
		OEFrame controllerFrame = ObjectEditor.edit(aController);
		controllerFrame.setLocation(CONTROLLER_X, CONTROLLER_Y);
		controllerFrame.setSize(CONTROLLER_WIDTH, CONTROLLER_HEIGHT);
		controllerFrame.setTitle(NAME);
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		return controllerFrame;
		
	}

}
//END OF FILE
//START OF FILE: src/common/controller/cathycontrollerui.java
package common.controller;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.CathyUI;
import util.trace.Tracer;

public class CathyControllerUI implements CathyUI {
	public static OEFrame createUI() {
		TrickOrTreatClientController aController = TrickOrTreatClientControllerFactory.getOrCreateSingleton();
		OEFrame controllerFrame = ObjectEditor.edit(aController);
		controllerFrame.setLocation(CONTROLLER_X, CONTROLLER_Y);
		controllerFrame.setSize(CONTROLLER_WIDTH, CONTROLLER_HEIGHT);
		controllerFrame.setTitle(NAME);
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		return controllerFrame;
		
	}

}
//END OF FILE
//START OF FILE: src/common/controller/davidcontrollerui.java
package common.controller;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.DavidUI;
import util.trace.Tracer;

public class DavidControllerUI implements DavidUI {
	public static OEFrame createUI() {
		TrickOrTreatClientController aController = TrickOrTreatClientControllerFactory.getOrCreateSingleton();
		OEFrame controllerFrame = ObjectEditor.edit(aController);
		controllerFrame.setLocation(CONTROLLER_X, CONTROLLER_Y);
		controllerFrame.setSize(CONTROLLER_WIDTH, CONTROLLER_HEIGHT);
		controllerFrame.setTitle(NAME);
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		return controllerFrame;
		
	}

}
//END OF FILE
//START OF FILE: src/common/controller/servercontrollerui.java
package common.controller;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.ServerUI;
import util.remote.RelayerController;
import util.remote.RelayerControllerFactory;
import util.trace.Tracer;

public class ServerControllerUI implements ServerUI {
	static final int Y_OFFSET_FROM_BOB = 15;
	public static OEFrame createUI() {
		Tracer.showWarnings(false);
		RelayerController aController = RelayerControllerFactory.getOrCreateSingleton();
		OEFrame controllerFrame = ObjectEditor.edit(aController);
		controllerFrame.setLocation(CONTROLLER_X, CONTROLLER_Y - Y_OFFSET_FROM_BOB);
		controllerFrame.setSize(CONTROLLER_WIDTH, CONTROLLER_HEIGHT);
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		return controllerFrame;
		
	}

}
//END OF FILE
//START OF FILE: src/common/controller/trickortreatclientcontroller.java
package common.controller;

import common.commandprocessor.ProgrammedCommandExecutor;
import util.remote.RelayerClientController;

public interface TrickOrTreatClientController extends RelayerClientController, ProgrammedCommandExecutor{
	boolean isMarkCommands();

	void setMarkCommands(boolean markCommands);

	int getInterCommandTime();

	void setInterCommandTime(int interCommandTime);

	void setCommandExecutionTime(long commandExecutionTime);

}
//END OF FILE
//START OF FILE: src/common/controller/trickortreatclientcontrollerfactory.java
package common.controller;

import util.remote.RelayerClientControllerFactory;

public class TrickOrTreatClientControllerFactory {
	static TrickOrTreatClientController singleton;
	public static void setSingleton(TrickOrTreatClientController newVal) {
		singleton = newVal;
	}
	public static TrickOrTreatClientController getOrCreateSingleton() {
		if (singleton == null) {
			singleton = new ATrickOrTreatClientController();
			RelayerClientControllerFactory.setSingleton( singleton);
		}
		return singleton;
			
	}

}
//END OF FILE
//START OF FILE: src/common/controller/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package common.controller;
//END OF FILE
//START OF FILE: src/common/ui/aliceui.java
package common.ui;

public interface AliceUI extends UI {

	public static final String NAME = "Alice";
	public static final int SIMULATION_COMMAND_X_OFFSET = 0;
	public static final String SIMULATION_PREFIX = NAME + ":";
//	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET + COMMAND_DISPLACEMENT;
	int CONTROLLER_X = ServerUI.CONTROLLER_X;
}
//END OF FILE
//START OF FILE: src/common/ui/bobui.java
package common.ui;

public interface BobUI extends UI {

	public static final String NAME = "Bob";
	public static final int SIMULATION_COMMAND_X_OFFSET = 200;
	public static final String SIMULATION_PREFIX = NAME + ":";
//	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET + COMMAND_DISPLACEMENT;
	int CONTROLLER_X = ServerUI.CONTROLLER_X;




}
//END OF FILE
//START OF FILE: src/common/ui/cathyui.java
package common.ui;

public interface CathyUI extends UI {

	public static final String NAME = "Cathy";
	public static final int SIMULATION_COMMAND_X_OFFSET = 400;
	public static final String SIMULATION_PREFIX = NAME + ":";
//	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET + COMMAND_DISPLACEMENT;
	int CONTROLLER_X = ServerUI.CONTROLLER_X;
}
//END OF FILE
//START OF FILE: src/common/ui/davidui.java
package common.ui;

public interface DavidUI extends UI {

	public static final String NAME = "David";
	public static final int SIMULATION_COMMAND_X_OFFSET = 600;
	public static final String SIMULATION_PREFIX = NAME + ":";
//	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET + COMMAND_DISPLACEMENT;
	int CONTROLLER_X = ServerUI.CONTROLLER_X;
}
//END OF FILE
//START OF FILE: src/common/ui/serverui.java
package common.ui;

public interface ServerUI extends UI {

	public static final String NAME = "Server";
	public static final int SIMULATION_COMMAND_X_OFFSET = 900;
	public static final String SIMULATION_PREFIX = NAME + ":";
//	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET;
	int CONTROLLER_X = SIMULATION_COMMAND_X_OFFSET;




}
//END OF FILE
//START OF FILE: src/common/ui/ui.java
package common.ui;

public interface UI {

	public static  final int COUPLED_SIMULATION_X_OFFSET = 250;
	public static int SIMULATION_COMMAND_Y_OFFSET = 30;
	public static int SIMULATION_WIDTH = 300;
	public static int SIMULATION_HEIGHT = 700;
	int CONTROLLER_WIDTH = 420;
	int CONTROLLER_HEIGHT = 300;
	int CONTROLLER_Y = SIMULATION_HEIGHT - 100;
//	int CONTROLLER_Y = SIMULATION_COMMAND_Y_OFFSET;

	int COMMAND_DISPLACEMENT = 0;
}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/alicecustomgipcandrmiandniosimulationlauncher.java
package gipc.custom.simulation.launcher;

import inputport.rpc.duplex.syncreceive.syncrpc.test.ASyncRPCSyncReceiveFactorySetter;
import gipc.simulation.client.AliceGIPCAndRMIAndNIOClient;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
@Tags({DistributedTags.CLIENT_1, DistributedTags.GIPC, Comp533Tags.CUSTOM_IPC})

public class AliceCustomGIPCAndRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		(new ASyncRPCSyncReceiveFactorySetter()).setFactories();
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();	
		RMITraceUtility.setTracing();
		GIPCRPCTraceUtility.setTracing();
		String[] myArgs = {
				"localhost", 
				CustomGIPCAndRMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Alice",
				"true",
				"localhost",
				RMIRegistryLauncher.RMI_PORT,
				CustomGIPCAndRMIAndNIOServerLauncher.GIPC_SERVER_PORT};
		
		AliceGIPCAndRMIAndNIOClient.launchAlice(myArgs);
//		AliceGIPCAndRMIAndNIOClient.launchAlice(args);

		
	}

}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/alicesimulationgipcclient.java
package gipc.custom.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationGIPCClient implements AliceUI {

public static void main(String[] args) {
	Tracer.showWarnings(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showInfo(true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/bobcustomgipcandrmiandniosimulationlauncher.java
package gipc.custom.simulation.launcher;

import inputport.rpc.duplex.syncreceive.syncrpc.test.ASyncRPCSyncReceiveFactorySetter;
import gipc.simulation.client.BobGIPCAndRMIAndNIOClient;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.client.BobRMIAndNIOClient;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
@Tags({DistributedTags.CLIENT_2, DistributedTags.GIPC, Comp533Tags.CUSTOM_IPC})
public class BobCustomGIPCAndRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		(new ASyncRPCSyncReceiveFactorySetter()).setFactories();
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();	
		
		String[] myArgs = {
				"localhost", 
				CustomGIPCAndRMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Bob",
				"true",
				"localhost",
				RMIRegistryLauncher.RMI_PORT,
				CustomGIPCAndRMIAndNIOServerLauncher.GIPC_SERVER_PORT};
		
		BobGIPCAndRMIAndNIOClient.launchBob(myArgs);
//		BobGIPCAndRMIAndNIOClient.launchBob(args);

		
	}

}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/bobsimulationgipcclient.java
package gipc.custom.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationGIPCClient implements BobUI {

//	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);
//	Tracer.showInfo(false);
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showWarnings(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showInfo(true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/cathysimulationgipcclient.java
package gipc.custom.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationGIPCClient implements CathyUI {

//	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);

//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showWarnings(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/customgipcandrmiandnioserverlauncher.java
package gipc.custom.simulation.launcher;

import inputport.rpc.duplex.syncreceive.syncrpc.test.ASyncRPCSyncReceiveFactorySetter;
import gipc.simulation.server.AGIPCAndRMIAndNIOSimulationServer;
import rmi.simulation.launcher.RMIAndNIOServerLauncher;
import rmi.simulation.launcher.RMIRegistryLauncher;
import rmi.simulation.registry.ADistributedRMIRegistryStarter;
import rmi.simulation.server.AnRMIAndNIOSimulationServer;
import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
@Tags({DistributedTags.SERVER, DistributedTags.GIPC, Comp533Tags.CUSTOM_IPC})
public class CustomGIPCAndRMIAndNIOServerLauncher extends RMIAndNIOServerLauncher{
	public static final String GIPC_SERVER_PORT = "3090";
	public static void main (String[] args) {
		(new ASyncRPCSyncReceiveFactorySetter()).setFactories();
		NIOTraceUtility.setTracing();
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		GIPCRPCTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		String[] myArgs = {NIO_SERVER_PORT, "localhost", RMIRegistryLauncher.RMI_PORT, GIPC_SERVER_PORT };
		AGIPCAndRMIAndNIOSimulationServer.launch(args);
	}

}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/customrmiregistrylauncherfromgipc.java
package gipc.custom.simulation.launcher;

import java.rmi.registry.LocateRegistry;
import java.util.Scanner;

import rmi.simulation.launcher.RMIRegistryLauncher;
import rmi.simulation.registry.ADistributedRMIRegistryStarter;
import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.tags.DistributedTags;
import assignments.util.mainArgs.ServerArgsProcessor;
@Tags({DistributedTags.REGISTRY})
public class CustomRMIRegistryLauncherFromGIPC {
	public static void main (String[] args) {
		RMIRegistryLauncher.main(args);
	}
	
}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/genericclientcustomgipcandrmiandniosimulationlauncher.java
package gipc.custom.simulation.launcher;

import inputport.rpc.duplex.syncreceive.syncrpc.test.ASyncRPCSyncReceiveFactorySetter;
import gipc.simulation.client.AliceGIPCAndRMIAndNIOClient;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
@Tags({DistributedTags.CLIENT, DistributedTags.GIPC, Comp533Tags.CUSTOM_IPC})

public class GenericClientCustomGIPCAndRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		(new ASyncRPCSyncReceiveFactorySetter()).setFactories();
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();	
		RMITraceUtility.setTracing();
		GIPCRPCTraceUtility.setTracing();
//		String[] myArgs = {
//				"localhost", 
//				CustomGIPCAndRMIAndNIOServerLauncher.NIO_SERVER_PORT,
//				"Alice",
//				"true",
//				"localhost",
//				RMIRegistryLauncher.RMI_PORT,
//				CustomGIPCAndRMIAndNIOServerLauncher.GIPC_SERVER_PORT};
		
//		AliceGIPCAndRMIAndNIOClient.launchAlice(myArgs);
		AliceGIPCAndRMIAndNIOClient.launchAlice(args);

		
	}

}
//END OF FILE
//START OF FILE: src/gipc/custom/simulation/launcher/interactivedemoerofgipcsimulation.java
package gipc.custom.simulation.launcher;

import gipc.simulation.server.AGIPCSimulationServerLauncher;

public class InteractiveDemoerOfGIPCSimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				AGIPCSimulationServerLauncher.class,
				AliceSimulationGIPCClient.class,
				BobSimulationGIPCClient.class,
				CathySimulationGIPCClient.class
				
		};
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/customserializer/client/acustomserializergipcsimulationclientlauncher.java
package gipc.customserializer.client;


import gipc.simulation.client.AGIPCSimulationClientLauncher;
import serialization.SerializerSelector;
import serialization.logical.ALogicalStructureSerializerFactory;
import stringProcessors.HalloweenCommandProcessor;





public class ACustomSerializerGIPCSimulationClientLauncher extends AGIPCSimulationClientLauncher  {	

	public ACustomSerializerGIPCSimulationClientLauncher(String aClientName, String aServerHost, String aServerId, String aServerName, HalloweenCommandProcessor aCommandProcessor,
			 boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName, aCommandProcessor, aBroadcastData);
		
	}
	
	
	
	@Override
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
//		Tracer.showInfo(true);

//		Tracer.setKeywordPrintStatus(ACustomSerializer.class, true);

		SerializerSelector.setSerializerFactory(new ALogicalStructureSerializerFactory());



		
	}

	
//	public  InputPort getRPCClientInputPort(PortAccessKind aPortAccessKind) {
//		Tracer.showInfo(true);
//
//		return DuplexRPCInputPortWithSyncReceiveSelector.createDuplexRPCClientInputPortWithSyncReceive(serverHost, serverId, serverName, clientName);
//	}
}
//END OF FILE
//START OF FILE: src/gipc/customserializer/launcher/alicesimulationcustomserializergipcclient.java
package gipc.customserializer.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.customserializer.client.ACustomSerializerGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationCustomSerializerGIPCClient implements AliceUI {

//	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//	
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
////	new AGIPCSimulationClientLauncher( NAME, GIPCSimulationServerLauncher.SESSION_SERVER_ID,, aCommandProcessor, true);
//	ClearanceManager clearanceManager = new AClearanceManager();
//	OEFrame oeFrame = ObjectEditor.edit(clearanceManager);
//	oeFrame.setLocation(700, 500);
//
//	clearanceManager.waitForClearance();
//	long startTime = System.currentTimeMillis();
//
//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 1 0");
//
//
//	}
//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 0 -1");
//
//
//	}
//	long endTime = System.currentTimeMillis();
//
//	System.out.println("Loop execution time:" + (endTime - startTime));
//
//
//	
//
//  
//  }
public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	Tracer.showInfo(true);
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new ACustomSerializerGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
  }
}

//END OF FILE
//START OF FILE: src/gipc/customserializer/launcher/bobsimulationcustomserializergipcclient.java
package gipc.customserializer.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.customserializer.client.ACustomSerializerGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationCustomSerializerGIPCClient implements BobUI {

//	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
//
//
//  }
	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		OEFrame oeFrame = BobControllerUI.createUI();
		HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
		(new ACustomSerializerGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
		Tracer.showInfo(true);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
	  }
}

//END OF FILE
//START OF FILE: src/gipc/customserializer/launcher/cathysimulationcustomserializergipcclient.java
package gipc.customserializer.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.customserializer.client.ACustomSerializerGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationCustomSerializerGIPCClient implements CathyUI {

	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
//
//
//  }
	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		OEFrame oeFrame = CathyControllerUI.createUI();
		HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
		(new ACustomSerializerGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
	  }
}

//END OF FILE
//START OF FILE: src/gipc/customserializer/launcher/interactivedemoerofcustomserializergipcsimulation.java
package gipc.customserializer.launcher;

public class InteractiveDemoerOfCustomSerializerGIPCSimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				SimulationCustomSerializerGIPCServerMain.class,
				AliceSimulationCustomSerializerGIPCClient.class,
				BobSimulationCustomSerializerGIPCClient.class,
				CathySimulationCustomSerializerGIPCClient.class				
		};
//		MainClassLaunchingUtility.interactiveLaunch(classes);
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/customserializer/launcher/simulationcustomserializergipcservermain.java
package gipc.customserializer.launcher;

import common.controller.ServerControllerUI;
import gipc.customserializer.server.ACustomSerializerGIPCSimulationServerLauncher;
import gipc.simulation.server.AGIPCSimulationServerLauncher;



public class SimulationCustomSerializerGIPCServerMain extends AGIPCSimulationServerLauncher   {
	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		ServerControllerUI.createUI();

		(new ACustomSerializerGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}

}
//END OF FILE
//START OF FILE: src/gipc/customserializer/server/acustomserializergipcsimulationserverlauncher.java
package gipc.customserializer.server;

import gipc.simulation.server.AGIPCSimulationServerLauncher;
import serialization.SerializerSelector;
import serialization.logical.ALogicalStructureSerializer;
import serialization.logical.ALogicalStructureSerializerFactory;
import util.trace.Tracer;



public class ACustomSerializerGIPCSimulationServerLauncher extends AGIPCSimulationServerLauncher   {
	public ACustomSerializerGIPCSimulationServerLauncher(String aServerName,
			String aServerId) {
		super (aServerName, aServerId);

	}	
	@Override
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
//		Tracer.showInfo(true);
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, false);
//		Tracer.setImplicitDisplayKeywordKind(ImplicitKeywordKind.OBJECT_PACKAGE_NAME);
//		Tracer.setKeywordPrintStatus(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
		Tracer.setKeywordPrintStatus(ALogicalStructureSerializer.class, true);
		SerializerSelector.setSerializerFactory(new ALogicalStructureSerializerFactory());
//		DuplexRPCInputPortSelector.setInputPortFactory(new AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory());
//		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
//		SynchronousDuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(new AProcedureSyncingDuplexReceivedCallInvokerFactory());
		
	}
		
//	public  InputPort getRPCServerInputPort(PortAccessKind aPortAccessKind) {
//		
//		return DuplexRPCInputPortWithSyncReceiveSelector.createDuplexRPCServerInputPortWithSyncReceive(serverId, serverName);
//	}
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		(new ACustomSerializerGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/afaulttoleranrpcfilterer.java
package gipc.session.faulttolerant;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import inputport.rpc.SerializableCall;
import inputport.rpc.SerializableMethod;

public class AFaultToleranRPCFilterer implements FaultTolerantFilterer {
	String[] broadcastHeaders = {};
	Set<String> broadcastHeadersSet = new HashSet();
	String[] relayedHeaders = {};
	

	Set<String> relayedHeadersSet = new HashSet();


	@Override
	public String[] getBroadcastHeaders() {
		return broadcastHeaders;
	}

	@Override
	public void setBroadcastHeaders(String[] newVal) {
		this.broadcastHeaders = newVal;
		broadcastHeadersSet = new HashSet(Arrays.asList(broadcastHeaders));
	}
	@Override
	public String[] getRelayedHeaders() {
		return relayedHeaders;
	}
	@Override
	public void setRelayedHeaders(String[] newVal) {
		this.relayedHeaders = newVal;
		relayedHeadersSet = new HashSet(Arrays.asList(relayedHeaders));
	}
	
	@Override
	public boolean isBroadcastCall (String aDestination, Object message) {
//		if (!(message instanceof SerializableCall))
//			return false;
//		SerializableCall aSerializableCall = (SerializableCall) message;
//		SerializableMethod aSerializableMethod = aSerializableCall.getSerializableMethod(); 
//		if (aSerializableMethod == null)
//			return false;
//		String aHeader = aSerializableMethod.toHeader();
//		return broadcastHeadersSet.contains(aHeader);
		return isCallContanedIn(aDestination, message, broadcastHeadersSet);
	}

	@Override
	public boolean isRelayCall (String aDestination, Object message) {
//		if (!(message instanceof SerializableCall))
//			return false;
//		SerializableCall aSerializableCall = (SerializableCall) message;
//		SerializableMethod aSerializableMethod = aSerializableCall.getSerializableMethod(); 
//		if (aSerializableMethod == null)
//			return false;
//		String aHeader = aSerializableMethod.toHeader();
//		return broadcastHeadersSet.contains(aHeader);
		return isCallContanedIn(aDestination, message, relayedHeadersSet);
	}
	
	protected boolean isCallContanedIn (String aDestination, Object message, Set<String> aSet) {
		if (!(message instanceof SerializableCall))
			return false;
		SerializableCall aSerializableCall = (SerializableCall) message;
		SerializableMethod aSerializableMethod = aSerializableCall.getSerializableMethod(); 
		if (aSerializableMethod == null)
			return false;
		String aHeader = aSerializableMethod.toHeader();
		return aSet.contains(aHeader);
	}
	

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/afaulttolerancemanager.java
package gipc.session.faulttolerant;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;

import gipc.session.faulttolerant.messages.ABroadcastMessage;
import gipc.session.faulttolerant.messages.AFinishedSynchronizingMessage;
import gipc.session.faulttolerant.messages.ALastReceivedSequenceNumber;
import gipc.session.faulttolerant.messages.AMostRecentRelay;
import gipc.session.faulttolerant.messages.ARelayedMessage;
import gipc.session.faulttolerant.messages.BroadcastMessage;
import gipc.session.faulttolerant.messages.FinishedSynchronizingMessage;
import gipc.session.faulttolerant.messages.MostRecentRelay;
import gipc.session.faulttolerant.messages.RelayedMessage;
import gipc.session.faulttolerant.messages.SynchronizingMessage;
import gipc.session.relayingclient.ARelayerElector;
import inputport.datacomm.simplex.object.DeserializingForwarder;
import inputport.datacomm.simplex.object.SerializingForwarder;
import sessionport.rpc.duplex.DuplexRPCSessionPort;
import util.trace.Tracer;

public class AFaultToleranceManager extends ARelayerElector implements FaultToleranceManager {
	int nextGeneratedMessageNumber = -1; // will always be incremented by received broadcast message before being used
	int nextRelayedMessageNumber = 0; 
//	boolean pendingRelayOfBroadcast;
	
//	int lastSentNumber;
//	int lastRelayedNumber;
//	int lastReceivedNumber = -1;
	BlockingQueue<BroadcastMessage> pendingSentBroadcasts = new LinkedBlockingDeque<>(); // by client
	RelayedMessage lastAckedBroadcast;
//	boolean lastBroadcastAcked;
	BroadcastMessage lastReceivedBroadcast; // by server
//	IdentifiableMessage lastIdentifiableMessageReceived;
//	SequencedMessage lastSequencedMessageG;
//	BroadcastMessage mostRecentEcho; // last received message was my echo
//	int mostRecentEchoSequenceNumber;
	SynchronizingMessage  possibleSynchronizingMessage = new ALastReceivedSequenceNumber(nextRelayedMessageNumber - 1);
//	RelayedMessage lastReceivedRelayedMessage;
	protected boolean synchronizing;
	protected int numberOfPendingSynchronizingMessages;
	protected int numPendingRelays; // do not want to change sequence number until all relays have happened
	// do not need buffer now, as relayer will syncyronize, but will keepi it anyway
//	SequencedMessageBuffer buffer = new ASequencedMessageBuffer();
	protected Map<String, SynchronizingMessage> nameToSynchronizingMessage = new HashMap<>();
//	protected Set<String> clientsNeedingSynchronizing = new HashSet();
	
	DuplexRPCSessionPort sessionPort;
	public AFaultToleranceManager(DuplexRPCSessionPort aSessionPort) {
		sessionPort = aSessionPort;		
	}
	
//	public int getNextGeneratedMessageNumber() {
//		return nextGeneratedMessageNumber;
//	}
//	public void setNextGeneratedMessageNumber(int nextMessageNumber) {
//		this.nextGeneratedMessageNumber = nextMessageNumber;
//	}
//	public int getNextRelayedMessageNumber() {
//		return nextRelayedMessageNumber;
//	}
//	public void setNextRelayedMessageNumber(int nextRelayedMessageNumber) {
//		this.nextRelayedMessageNumber = nextRelayedMessageNumber;
//	}
	
//	public int getLastSentNumber() {
//		return lastSentNumber;
//	}
//	public void setLastSentNumber(int lastSentNumber) {
//		this.lastSentNumber = lastSentNumber;
//	}
//	
//	public int getLastRelayedNumber() {
//		return lastRelayedNumber;
//	}
//	public void setLastRelayedNumber(int lastRelayedNumber) {
//		this.lastRelayedNumber = lastRelayedNumber;
//	}
//	public int getLastReceivedNumber() {
//		return lastReceivedNumber;
//	}
//	public void setLastReceivedNumber(int lastReceivedNumber) {
//		this.lastReceivedNumber = lastReceivedNumber;
//	}
//	public BroadcastMessage getLastBroadcast() {
//		return lastBroadcast;
//	}
//	public void setLastBroadcast(BroadcastMessage lastMessageSent) {
//		this.lastBroadcast = lastMessageSent;	
//		setLastBroadcastAcked(false);
//	}
//	protected boolean isLastBroadcastAcked() {
//		return pendingBroadcasts.size() == 0;;
//	}
//	protected void setLastBroadcastAcked(boolean lastBroadcastAcked) {
//		this.lastBroadcastAcked = lastBroadcastAcked;
//	
//	}
//	// all messages relayed after this will have this number
//	public void processBroadcastMessageReceived(BroadcastMessage aMessage) {
//		lastReceivedBroadcast = aMessage;
//		nextGeneratedMessageNumber++;
////		nextMessageNumber++;		
//	}
//	public SequencedMessage setLastSequencedMessageReceived() {
//		return lastSequencedMessageG;
//	}
//	public void setLastSequencedMessageGenerated(SequencedMessage lastMessageSent) {
//		setNextGeneratedMessageNumber(lastMessageSent.getSequenceNunber() + 1);
////		this.lastSequencedMessageG = lastMessageSent;		
//	}
	
	
//	public void setLastRelayedMessageReceived(SequencedMessage aMessage) {
//		setNextRelayedMessageNumber(aMessage.getSequenceNunber() + 1);		
//	}
	public String getId(Object aMessage) {
		return sessionPort.getLocalName() + "." + System.identityHashCode(aMessage);
	}
	public BroadcastMessage getBroadcastMessage (Object aMessage) {
		return new ABroadcastMessage(aMessage, getId(aMessage));
	}
	
//	public IdentifiableMessage getLastMessageReceived() {
//		return lastIdentifiableMessageReceived;
//	}
//	public void setLastMessageReceived(IdentifiableMessage lastMessageReceived) {
//		this.lastIdentifiableMessageReceived = lastMessageReceived;
//	}
	
	protected List generateRelayRequest(BroadcastMessage aMessage) {
		lastReceivedBroadcast = aMessage;
		nextGeneratedMessageNumber++;
		numPendingRelays = getRelayerNames().size();
//		Tracer.info(this, Thread.currentThread() + "forwarding relay request  " + aMessage.getIdentifier() + " incremented next generated numer to:" + nextGeneratedMessageNumber);
		Tracer.info(this, "processed relay request incrementing counter to:" + nextGeneratedMessageNumber);
		return Arrays.asList(new Object[]{aMessage.getMessage()});
	}
	/*
	 * This can be the sending thread on the same machine such as the main thread, otherwise it is the
	 * selection thread
	 */
	boolean waiting;
	public synchronized List<Object> processReceivedBroadcastMessage(BroadcastMessage aMessage) {
		while (numPendingRelays != 0)
			try {
				Tracer.info(this, "Relay request waits as previous request has pending relays:" + numPendingRelays );
//				System.out.println ("Waiting broadcast thread:" + Thread.currentThread() + " numPendngrelays:" + numPendingRelays);
				waiting = true;
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		waiting = false;
		return generateRelayRequest(aMessage);
//		lastReceivedBroadcast = aMessage;
//		nextGeneratedMessageNumber++;
//		numPendingRelays = getCurrentRelayerNames().size();
//		Tracer.info(this, Thread.currentThread() + "forwarding relay request  " + aMessage.getIdentifier() + " incremented next generated numer to:" + nextGeneratedMessageNumber);
//
//		return Arrays.asList(new Object[]{aMessage.getMessage()});
	}
	static List<Object> emptyList = new ArrayList();
	protected  void generateSynchronizationMessage(RelayedMessage aReceivedBroadcast) {
		possibleSynchronizingMessage = new  AMostRecentRelay
				(aReceivedBroadcast.getBroadcastObject(), aReceivedBroadcast.getIdentifier(), aReceivedBroadcast.getSequenceNumber());
////		if (pendingSentBroadcasts.size() == 0)
////			return;
//		BroadcastMessage firstPendingBroadcast = pendingSentBroadcasts.peek();
//		if (firstPendingBroadcast != null && firstPendingBroadcast.getIdentifier().equals(firstPendingBroadcast.getIdentifier())) {
//			try {
//				pendingSentBroadcasts.take(); // we know this will not blok
//				possibleSynchronizingMessage = new AMostRecentRelay
//						(firstPendingBroadcast.getMessage(), firstPendingBroadcast.getIdentifier(), aReceivedBroadcast.getSequenceNumber());
////				mostRecentEcho = firstPendingBroadcast;
////				mostRecentEchoSequenceNumber = aReceivedBroadcast.getSequenceNumber();
//				Tracer.info(this, "Received relay of my broadcast, generated most recent echo message as possible synchronizing mesage:" + possibleSynchronizingMessage );
//
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		} else { // recent message was not mine
//
//			possibleSynchronizingMessage = new ALastReceivedSequenceNumber (aReceivedBroadcast.getSequenceNumber());
//			Tracer.info(this, "Received relay of someone else's broadcast, generated last received sequence number message as possible synchronizing mesage:" + possibleSynchronizingMessage );
//
//		}
	}
	protected  void maybeProcessMyRelay(RelayedMessage aReceivedRelay) {
//		if (pendingSentBroadcasts.size() == 0)
//			return;
		BroadcastMessage firstPendingBroadcast = pendingSentBroadcasts.peek();
		// will the anded check not always return true
//		if (firstPendingBroadcast != null && firstPendingBroadcast.getIdentifier().equals(aReceivedRelay.getIdentifier())) {

		if (firstPendingBroadcast != null && firstPendingBroadcast.getIdentifier().equals(firstPendingBroadcast.getIdentifier())) {
			try {
				pendingSentBroadcasts.take(); // we know this will not blok
				
				Tracer.info(this, "Received relay of my broadcast, generated most recent echo message as possible synchronizing mesage:" + possibleSynchronizingMessage );

			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} else { // recent message was not mine

			possibleSynchronizingMessage = new ALastReceivedSequenceNumber (aReceivedRelay.getSequenceNumber());
			Tracer.info(this, "Received relay of someone else's broadcast, generated last received sequence number message as possible synchronizing mesage:" + possibleSynchronizingMessage );

		}
	}
	
//	public List processBufferedReceivedRelayedMessage(SequencedMessage aReceivedBroadcast) {
//		maybeProcessRelayOfMyBroadcast(aReceivedBroadcast); // my broadcasts will be received in sequence
//		int aSequenceNumber = aReceivedBroadcast.getSequenceNunber();
//		if (getNextRelayedMessageNumber() > aSequenceNumber) {
//			return emptyList; // duplicate
//		}
//		if (getNextRelayedMessageNumber()  == aSequenceNumber) {		// expected	
//			List<SequencedMessage> aNewMessages = buffer.removeMessagesFrom(aReceivedBroadcast.getSequenceNunber() + 1);
//			aNewMessages.add(0, aReceivedBroadcast);
//			setNextRelayedMessageNumber(aNewMessages.get(aNewMessages.size() -1).getSequenceNunber() + 1);
//			return toActualMessages(aNewMessages);
//		} else { // early message
//			buffer.insertMessage(aReceivedBroadcast);
//			return emptyList;
//		}
//	}
	public List processReceivedRelayedMessage(RelayedMessage aReceivedRelay) {
		Tracer.info(this, "Received message from relay server:" + aReceivedRelay);
//		lastReceivedRelayedMessage = aReceivedBroadcast; // this is the last one, from anyone
		maybeProcessMyRelay(aReceivedRelay);
		generateSynchronizationMessage(aReceivedRelay); // my broadcasts will be received in sequence
		int aSequenceNumber = aReceivedRelay.getSequenceNumber();
		if (nextRelayedMessageNumber > aSequenceNumber) {
			Tracer.info(this, "Received duplicate message from relay server, my sequence number:" + nextRelayedMessageNumber);
			return emptyList; // duplicate, my message is re-echoed as it was rebroadcast for others
		}
		if (nextRelayedMessageNumber  == aSequenceNumber) {	
			// expected	
//			List<SequencedMessage> aNewMessages = buffer.removeMessagesFrom(aReceivedBroadcast.getSequenceNunber() + 1);
//			aNewMessages.add(0, aReceivedBroadcast);
//			setNextRelayedMessageNumber(aNewMessages.get(aNewMessages.size() -1).getSequenceNunber() + 1);
			nextRelayedMessageNumber++;
			Tracer.info(this, "Next relay message number:" + nextRelayedMessageNumber);


			return Arrays.asList(new Object[]{aReceivedRelay.getMessage()});
		} else { // early message
			Tracer.error("Received early message, expected number " + nextRelayedMessageNumber + " actual sequence number:" + aSequenceNumber );
//			buffer.insertMessage(aReceivedBroadcast);
			return emptyList;
		}
	}
//	public List toActualMessages(List<SequencedMessage> aSequencedMessages) {
//		List result = new ArrayList();
//		for (SequencedMessage aSequencedMessage:aSequencedMessages) {
//			result.add(aSequencedMessage.getMessage());
//		}
//		return result;
//	}
	
//	public List oldProcessReceivedMessage(String remoteEnd, Object serializable) {
//		if (serializable instanceof IdentifiableMessage) {
//			Object realMessage = ((IdentifiableMessage) serializable).getMessage();
//			if (FaultTolerantFiltererFactory.getOrCreateSingleton().isBroadcastMessage(sessionPort.getLocalName(), realMessage)) {
//				return processReceivedBroadcastMessage((BroadcastMessage) serializable);
//			} else if (serializable instanceof SequencedMessage && FaultTolerantFiltererFactory.getOrCreateSingleton().isRelayedMessage(sessionPort.getLocalName(), realMessage)) {
//				return processReceivedRelayedMessage((SequencedMessage) serializable);
//			} else {
//				System.err.println("Unexpected indentifiable message:" + serializable);
//				return emptyList;
//			}			
//		} else
//			return  Arrays.asList(new Object[] {serializable});
////		if (serializable instanceof SequencedMessage) {
////			return processReceivedRelayedMessage((SequencedMessage) serializable);
////			
////		} 
////		 else if (serializable instanceof IdentifiableMessage) {
////			return processReceivedBroadcastMessage((IdentifiableMessage) serializable);
////		}
////		 else 
////			 return  Arrays.asList(new Object[] {serializable});
//	}
	protected synchronized List processReceivedSynchronizingMessage(String remoteEnd, SynchronizingMessage aSynchronizingMessage) {
		numberOfPendingSynchronizingMessages --;
		nameToSynchronizingMessage.put(remoteEnd, aSynchronizingMessage);
		Tracer.info(this, "Received from " + remoteEnd + " synchronizing message:"  + aSynchronizingMessage + " pending synchronizing messages:" + 0);

		return maybeFinishSynchronizing();
//		return emptyList;
//		int aSequenceNumber = aSynchronizingMessage.getSequenceNumber();
//		if (aSequenceNumber == nextGeneratedMessageNumber + 1) // missed broadcast, assume it just arrived
//			return processReceivedMessage(remoteEnd, aSynchronizingMessage.getMessage());
//		else {
//			return emptyList;
//		}
		
	}
	protected synchronized List processReceivedFinishedSynchronizingMessage(String remoteEnd, FinishedSynchronizingMessage aSynchronizingMessage) {
		Tracer.info(this, "Received finished synchronizing message from relay server");
		sendPendingMessages();
		return emptyList;
	}
	@Override
	public synchronized List processReceivedMessage(DeserializingForwarder aSourceTrapper, String remoteEnd, Object serializable) {
		if (serializable instanceof BroadcastMessage) {
				return processReceivedBroadcastMessage((BroadcastMessage) serializable);
		} else if (serializable instanceof RelayedMessage) {
				return processReceivedRelayedMessage((RelayedMessage) serializable);
		} else if (serializable instanceof SynchronizingMessage) {
				return processReceivedSynchronizingMessage(remoteEnd, (SynchronizingMessage) serializable);
		} else if (serializable instanceof FinishedSynchronizingMessage) {
			 return processReceivedFinishedSynchronizingMessage(remoteEnd, (FinishedSynchronizingMessage) serializable);
		} else
		
		{
			return  Arrays.asList(new Object[] {serializable});
		}
//		if (serializable instanceof SequencedMessage) {
//			return processReceivedRelayedMessage((SequencedMessage) serializable);
//			
//		} 
//		 else if (serializable instanceof IdentifiableMessage) {
//			return processReceivedBroadcastMessage((IdentifiableMessage) serializable);
//		}
//		 else 
//			 return  Arrays.asList(new Object[] {serializable});
	}

//	@Override
//	public synchronized List processSentBroadcastMessage(Object aMessage) {
	/*
	 * Sending thread on local machine
	 */
	public synchronized List processSentBroadcastMessage(Object aMessage) {
//		while (synchronizing) {
//			try {
//				Tracer.info(this, "Message sender waiting for synchronization phase to end");
//				wait();
//				Tracer.info(this, "Message sender unblocked as synchronization phase ended");
//
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
		
		BroadcastMessage aBroadcastMessage = getBroadcastMessage(aMessage);
		Tracer.info(this, "Local client sending broadcast request to server:" + aBroadcastMessage);

		// record before sending just in case response received before recording
		try {
			pendingSentBroadcasts.put(aBroadcastMessage); // ok to block sender if the queue is full
			Tracer.info(this, "Queued broadcast message in pending list to match echoed reply");;

		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		notify(); // any other thread that is waiting
		if (synchronizing) {
			Tracer.info(this, "Broadcast not sent to relayer as syncronization phase is on");

			return emptyList; // do not send now, send it after all pending messages are sent
		}
		return Arrays.asList(new Object[] {aBroadcastMessage});
	}
	@Override
	public synchronized List processSentMessage (SerializingForwarder aSource, String remoteName, Object aMessage) {
		if (FaultTolerantFiltererFactory.getOrCreateSingleton().isBroadcastCall(remoteName, aMessage)) {
//			String anId = FaultToleranceManagerFactory.getSingleton().getId(aMessage);
//			IdentifiableMessage aIdentifiableMessage = FaultToleranceManagerFactory.getSingleton().getIdentifiableMessage(aMessage);
//			// record before sending just in case response received before recording
//			FaultToleranceManagerFactory.getSingleton().setLastIdentifiableMessageSent(aIdentifiableMessage);
			return processSentBroadcastMessage(aMessage);
			
			} else if (FaultTolerantFiltererFactory.getOrCreateSingleton().isRelayCall(remoteName, aMessage)) {
//				SequencedMessage aSequencedMesage = FaultToleranceManagerFactory.getSingleton().getSequencedMessage(aMessage);
				return processSentRelayedMessage(remoteName, aMessage);
			} else 
				return Arrays.asList(new Object[]{aMessage});
	}
	/*
	 * sender and receiver threads can be different and on same computer,
	 * this is the method invoker thread which received the call and is sending the message
	 * this is the wrapped message sent by relayer to the clients, who will unwrap it
	 * this can be the local sending thread (can it), or is it always the method invoker
	 */
	public synchronized List processSentRelayedMessage(String aRemoteName, Object aMessage) {
//		if (synchronizing && !clientsNeedingSynchronizing.contains(aRemoteName))
//			return emptyList;
//		System.out.println ("Sent relayed:" + Thread.currentThread());
		RelayedMessage aRelayedMessage = getRelayedMessage(aMessage);
		// record before sending just in case response received before recording
		numPendingRelays--;
		Tracer.info(this, "sending to client:" + aRemoteName + " relay result " + aRelayedMessage + " pending relays:" + numPendingRelays);


		if (numPendingRelays <= 0) {
			Tracer.info(this, "All relay results of previous relay request sent, notifying any blocked new sent relay requests");
			if (waiting)
//			System.out.println ("Notifying waitinhg thread:" + Thread.currentThread());
			notifyAll(); // anyone waiting should go
		}
		return Arrays.asList(new Object[] {aRelayedMessage});
	}
	
	public RelayedMessage getRelayedMessage (Object aMessage) {
		if (lastReceivedBroadcast == null) {
			Tracer.error("Sequencing a message not received");
			return null;
		}		
		return new ARelayedMessage(aMessage, lastReceivedBroadcast.getIdentifier(), nextGeneratedMessageNumber, lastReceivedBroadcast.getMessage());
	}
	// what if we are sending our own message when this happened, but that will not fail
	
	// do not need this because of synchronizing messages
//	protected void haveBecomeRelayer() {
//		nextGeneratedMessageNumber = nextRelayedMessageNumber - 1; // they are always off by one
//		
//	}
//	
	
	
//	public boolean processConnectionChange(List<String> relayerNames) {
//		boolean aNewRelayer = super.processConnectionChange(relayerNames);
//		if (!aNewRelayer)
//			return aNewRelayer;
//		if (getCurrentRelayerName().equals(sessionPort.getLocalName())) {
//			haveBecomeRelayer();
//		}
//		return aNewRelayer;
////		return getCurrentRelayer();
//		
//	
//   }
	
	
	
	public  void  sendSynchronizingMessage() {
//		SynchronizingMessage aSynchronizingMessage = null;
//		if (mostRecentEcho == null)
//			aSynchronizingMessage = ANoMostRecentEcho.SINGLETON;
//		else
//			aSynchronizingMessage =  new AMostRecentEcho(
//					mostRecentEcho.getMessage(), mostRecentEcho.getIdentifier(), mostRecentEchoSequenceNumber);
//		SynchronizingMessage message = new ASynchronizingMessage(
//				lastReceivedRelayedMessage.getMessage(), lastReceivedRelayedMessage.getIdentifier(), lastReceivedRelayedMessage.getSequenceNumber());
		Tracer.info(this, "Sending to new  relayer synchronizing message:" + possibleSynchronizingMessage );
		sessionPort.send(getCurrentRelayerName(), possibleSynchronizingMessage);		
	}
//	public   void  sendPendingMessage(BroadcastMessage aPendingMessage) {
//		while (!pendingSentBroadcasts.isEmpty()) {
//			sessionPort.send(getCurrentRelayerName(), aPendingMessage.getMessage());			
//		}
//		synchronizing = false;
//	}
	/*
	 * sycnrhronized so that the queue is stable, do not need to use take
	 * this is the receiving thread (Selector) that received the synchronization message
	 */
//	public synchronized  void  sendPendingMessages() {
//	Tracer.info(this, "Sending pending messages");
	public  synchronized void  sendPendingMessages() {
		while (!pendingSentBroadcasts.isEmpty()) {
				BroadcastMessage aPendingBroadcast = pendingSentBroadcasts.remove();
				Tracer.info(this, "Sending pending broadcast:" + aPendingBroadcast);

				sessionPort.send(aPendingBroadcast);
			
			
		}
		synchronizing = false;
		Tracer.info(this, "Synchronization phase ends");

	}
	// doing a system broadcast, selection thread
    protected List maybeFinishSynchronizing() {
    	if (numberOfPendingSynchronizingMessages == 0) {
    		Tracer.info(this, "Received all pending synchronizing messages");

    		 List retVal = processSynchronizingMessages();
    		FinishedSynchronizingMessage aFinishedSynchronizingMessage = new AFinishedSynchronizingMessage();
    		for (String aRelayerName:getRelayerNames()) {
    			Tracer.info(this, "Sending finsished snchronizing message to:" + aRelayerName);
    			// if same thread does the send then it will block for the pendng relays, and never return value to 
    			// forwarder, the same forwarder will be reentrant
    			// sending thread must not receive in ADuplexServerInputPort
    			sessionPort.send(aRelayerName, aFinishedSynchronizingMessage );
    		}
    		return retVal;
    	}
    	return emptyList;
	}
	protected MostRecentRelay getMaxRecentRelay() {
//		int aMaxSequenceNumber = -1;
		MostRecentRelay result = null;
		for (SynchronizingMessage aSynchronizingMessage:nameToSynchronizingMessage.values()) {
			if (aSynchronizingMessage instanceof MostRecentRelay &&
			(result == null ||  
			((MostRecentRelay) aSynchronizingMessage).getSequenceNumber() > result.getSequenceNumber())) {
				result = (MostRecentRelay) aSynchronizingMessage;
			}			
		}
		return result;
	}
	
	/*
	 * selection thread that sent the synchronizing messae
	 */
    protected List processSynchronizingMessages() {
    	MostRecentRelay aMaxRecentRelay = getMaxRecentRelay();
    	if (aMaxRecentRelay == null) // no one has received anything, nothing to do
    		return emptyList;
    	boolean aSomeClientNeedsSynchronizing = false;
    	
//    	RelayedMessage aRelayBackMesage = new ARelayedMessage(
//    			aMaxSynchronizingMessage.getMessage(), 
//    			aMaxSynchronizingMessage.getIdentifier(), 
//    			aMaxSynchronizingMessage.getSequenceNumber());
    	for (String aDestination:nameToSynchronizingMessage.keySet()) {
    		SynchronizingMessage aSynchronizingMessage = nameToSynchronizingMessage.get(aDestination);
    		// difference shoudl not be less than 1
    		if (aSynchronizingMessage.getSequenceNumber() < aMaxRecentRelay.getSequenceNumber()) {
//    			sessionPort.send(aDestination, aRelayBackMesage); // send back the wrapped message so it does not bounce back
//    			clientsNeedingSynchronizing.add(aDestination);
    			aSomeClientNeedsSynchronizing = true;
    		} 
//    		else {
//    			aSourceOfMaxSynchronizingMessage = aDestination; //take this out
//    		}
    	}
    	if (aSomeClientNeedsSynchronizing) {
    		Tracer.info(this, "Some client needs synchronizing of partially relayed message:" + aMaxRecentRelay);
    		// last sender of synchronizing message will be the source! Should not matter
    		nextGeneratedMessageNumber = aMaxRecentRelay.getSequenceNumber() -1; // this will get incremented by next call

    		return generateRelayRequest(
    				new ABroadcastMessage(aMaxRecentRelay.getMessage(), aMaxRecentRelay.getIdentifier()));
    				
    	
//    		lastReceivedBroadcast = new ABroadcastMessage(aMaxSynchronizingMessage.getMessage(), aMaxSynchronizingMessage.getIdentifier());
//    		// the relayed version of this message will be labelled with next Generated number + 1
//    		nextGeneratedMessageNumber = aMaxSynchronizingMessage.getSequenceNumber(); 
//    		numPendingRelays = getCurrentRelayerNames().size();
//    		Tracer.info(this, "Forwarding to relayer synchronizing message:" + aMaxSynchronizingMessage + "pending relays =" + numPendingRelays);
//    		return Arrays.asList(new Object[]{aMaxSynchronizingMessage.getMessage()});

    		
    	} else {
    		nextGeneratedMessageNumber = aMaxRecentRelay.getSequenceNumber(); // will increment this for the next round
    	}
    	Tracer.info(this, "no client needs synchronization");
    	return emptyList;
//    	nextGeneratedMessageNumber = aMaxSynchronizingMessage.getSequenceNumber();
    	
    	
    	
    }
	
	
	
	
	/*
	 * Synchronized as changing shared variable synchronizing
	 * @see gipc.session.relayingclient.ARelayerElector#processJoin(java.lang.String)
	 */
	protected  synchronized void initJoinData(String aRelayerName) {
		Tracer.info(this, "Synchronizing phase starts, joining relayer:" + aRelayerName);
		synchronizing = true;
		numberOfPendingSynchronizingMessages = getRelayerNames().size();
		nameToSynchronizingMessage.clear();
	}
//	public  void processJoin(String aRelayerName) {	
   // asynchronous call invoker, do not want it to block on sends do we
	@Override
	public synchronized  void  processJoin(String aRelayerName) {	

//	public synchronized  void  processJoin(String aRelayerName) {	
		synchronized (this) {
//		System.out.println("join phase starts" + Thread.currentThread());
		Tracer.info(this, "join phase starts");
		
		if (nextRelayedMessageNumber == 0) {	// startup phase 
			Tracer.info(this, "Startup phase, joining relayer:" + aRelayerName);
			return;
		}
		Tracer.info(this, "Synchronizing phase starts, joining relayer:" + aRelayerName);
		synchronizing = true;
		numberOfPendingSynchronizingMessages = getRelayerNames().size();
		nameToSynchronizingMessage.clear();
		}
//		clientsNeedingSynchronizing.clear();
		sendSynchronizingMessage();
		
		Tracer.info(this, "join phase ends");
//		System.out.println("join phase ends" + Thread.currentThread());


//		SequencedMessage aStatusMessage;
//		if (lastBroadcast != null && lastBroadcastAcked) {
//			aStatusMessage = new ASequencedMessage(lastBroadcast.getMessage(), lastBroadcast.getIdentifier(), lastBroadcastSequenceNumber);
//		} else {
//			aStatusMessage = new ASequencedMessage(null, "", -1);
////			ObjectTranslatingIPTrapperSelector.getTrapperSelector().getSendTrapperFactory(
//		}
		
	}
}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/asentcommand.java
package gipc.session.faulttolerant;

public class ASentCommand implements SentCommand {
	String source;
	String command;
	int id;
	public ASentCommand(String aSource, String aCommand) {
		this.source = aSource;
		this.command = aCommand;
		id = this.hashCode();
	}
	@Override
	public int getId() {
		return id;
	}
	@Override
	public String getSource() {
		return source;
	}
//	@Override
//	public void setaSource(String aSource) {
//		this.aSource = aSource;
//	}
	@Override
	public String getCommand() {
		return command;
	}
//	@Override
//	public void setaCommand(String aCommand) {
//		this.aCommand = aCommand;
//	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/faulttolerancemanager.java
package gipc.session.faulttolerant;

import java.util.List;

import gipc.session.relayingclient.RelayerElector;
import inputport.datacomm.simplex.object.DeserializingForwarder;
import inputport.datacomm.simplex.object.SerializingForwarder;

public interface FaultToleranceManager extends RelayerElector{

//	public abstract int getNextGeneratedMessageNumber();
//
//	public abstract void setNextGeneratedMessageNumber(int nextMessageNumber);
//
//	public abstract int getLastSentNumber();
//
//	public abstract void setLastSentNumber(int lastSentNumber);
//
//	public abstract int getLastRelayedNumber();
//
//	public abstract void setLastRelayedNumber(int lastRelayedNumber);
//
//	public abstract int getLastReceivedNumber();
//
//	public abstract void setLastReceivedNumber(int lastReceivedNumber);
//
//	public abstract IdentifiableMessage getLastBroadcast();
//
//	public abstract void setLastBroadcast(IdentifiableMessage lastMessageSent);
//
//    String getId(Object aMessage);
//
//	void setLastRelayedMessageReceived(SequencedMessage aMessage);
//
//
//	void setLastBroadcastMessageReceived(IdentifiableMessage aMessage);
//
//	IdentifiableMessage getIdentifiableMessage(Object aMessage);
//
//	IdentifiableMessage getLastMessageReceived();
//
//	void setLastMessageReceived(IdentifiableMessage lastMessageReceived);
//
//	SequencedMessage getSequencedMessage(Object aMessage);

//	List<Object> processSentBroadcastMessage(Object aMessage);
//
//	List<Object> processSentRelayedMessage(Object aMessage);

	List<Object> processSentMessage(SerializingForwarder aSourceTrapper, String remoteName, Object aMessage);

	List<Object> processReceivedMessage(DeserializingForwarder aSourceTrapper, String remoteEnd, Object serializable);}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/faulttolerancemanagerfactory.java
package gipc.session.faulttolerant;

import gipc.session.relayingclient.RelayerElectorFactory;
import sessionport.rpc.duplex.DuplexRPCSessionPort;

public class FaultToleranceManagerFactory {
	static FaultToleranceManager singleton;
	public static void setSingleton(FaultToleranceManager newVal) {
		singleton = newVal;
	}
	public static FaultToleranceManager createSingleton(DuplexRPCSessionPort aSessionPort) {
		if (singleton == null) {
			singleton = new AFaultToleranceManager(aSessionPort);
			RelayerElectorFactory.setSingleton(singleton);
		}
		return singleton;
			
	}
	public static FaultToleranceManager getSingleton() {
		return singleton;
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/faulttolerantfilterer.java
package gipc.session.faulttolerant;

public interface FaultTolerantFilterer {

	public abstract String[] getBroadcastHeaders();

	public abstract void setBroadcastHeaders(String[] newVal);

	public abstract boolean isBroadcastCall(String aDestination, Object message);

	String[] getRelayedHeaders();

	void setRelayedHeaders(String[] newVal);

	boolean isRelayCall(String aDestination, Object message);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/faulttolerantfiltererfactory.java
package gipc.session.faulttolerant;


public class FaultTolerantFiltererFactory {
	static FaultTolerantFilterer singleton;
	public static void setSingleton(FaultTolerantFilterer newVal) {
		singleton = newVal;
	}
	public static FaultTolerantFilterer getOrCreateSingleton() {
		if (singleton == null) {
			singleton = new AFaultToleranRPCFilterer();
		}
		return singleton;
			
	}
	
}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/sentcommand.java
package gipc.session.faulttolerant;

public interface SentCommand {

	public abstract String getSource();

//	public abstract void setaSource(String aSource);

	public abstract String getCommand();

	int getId();

//	public abstract void setaCommand(String aCommand);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/afaulttolerantdeserializingforwarder.java
package gipc.session.faulttolerant.forwarders;

import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;

import gipc.session.faulttolerant.FaultToleranceManagerFactory;
import inputport.datacomm.ReceiveNotifier;
import inputport.datacomm.simplex.object.ADeserializingForwarder;
import port.delay.MessageWithDestination;
import util.trace.Tracer;

public class AFaultTolerantDeserializingForwarder extends ADeserializingForwarder implements Runnable {
	BlockingQueue<MessageWithDestination> receiveQueue = new LinkedBlockingDeque<>();


	public AFaultTolerantDeserializingForwarder(ReceiveNotifier aReceiveNotifier) {
		super(aReceiveNotifier);
//		Thread aThread = new Thread(this);
//		aThread.setName("Fault Tolerant Received");
//		aThread.start();
	}

	public void notifySerializable(String remoteEnd, Object serializable) {
//		if (remoteEnd.equals("Session Server"))
//			doNotifySerializable(remoteEnd, serializable);
//		else
//		receiveQueue.add(new AMessageWithDestination(serializable, remoteEnd));
		doNotifySerializable(remoteEnd, serializable);

//		List<Object> aProcessedMessages = 
//				FaultToleranceManagerFactory.getSingleton().
//				   processReceivedMessage(null, remoteEnd, serializable);
//		for (Object aProcessedMessage:aProcessedMessages) {
//		
//		   super.notifySerializable(remoteEnd, aProcessedMessage);
//		}
	}
	
	public void doNotifySerializable(String remoteEnd, Object serializable) {
		Tracer.info(this, "Forwarding to fault tolerance manager:" + serializable);
		List<Object> aProcessedMessages = 
				FaultToleranceManagerFactory.getSingleton().
				   processReceivedMessage(null, remoteEnd, serializable);

		for (Object aProcessedMessage:aProcessedMessages) {
			Tracer.info(this, "Forwarding to destination:" + serializable);

		   super.notifySerializable(remoteEnd, aProcessedMessage);
		}
	}


	@Override
	public void run() {
		try {
			MessageWithDestination aMesageWithDestination = receiveQueue.take();
			doNotifySerializable(aMesageWithDestination.getDestination(), aMesageWithDestination.getData());
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/afaulttolerantdeserializingforwarderfactory.java
package gipc.session.faulttolerant.forwarders;

import inputport.InputPort;
import inputport.datacomm.ReceiveNotifier;
import inputport.datacomm.simplex.object.ADeserializingForwarderFactory;
import inputport.datacomm.simplex.object.DeserializingForwarder;

public class AFaultTolerantDeserializingForwarderFactory extends ADeserializingForwarderFactory {
	
	@Override
	public DeserializingForwarder createReceiveTrapper(InputPort anInputPort,
			ReceiveNotifier<Object> receiveRegistrarAndNotifier) {
		return new AFaultTolerantDeserializingForwarder (receiveRegistrarAndNotifier);
	}
}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/afaulttolerantserializingforwarder.java
package gipc.session.faulttolerant.forwarders;

import java.nio.ByteBuffer;
import java.util.List;

import gipc.session.faulttolerant.FaultToleranceManagerFactory;
import inputport.InputPort;
import inputport.datacomm.NamingSender;
import inputport.datacomm.simplex.object.ASerializingForwarder;
import util.trace.Tracer;

public class AFaultTolerantSerializingForwarder extends ASerializingForwarder {
	

	public AFaultTolerantSerializingForwarder(InputPort anInputPort,
			NamingSender<ByteBuffer> aDestination) {
		super(anInputPort, aDestination);
	}
	
	public void send(String remoteName, Object aMessage) {
//		Object anActualSentMessage = aMessage;
		Tracer.info(this, "Forwarding to fault tolerance manager:" + aMessage);

		List<Object> aProcessedMessages = FaultToleranceManagerFactory.getSingleton().processSentMessage(null, remoteName, aMessage);
		for (Object aProcessedMessage: aProcessedMessages) {
			super.send(remoteName, aProcessedMessage);
			Tracer.info(this, "Forwarding to destination:" + aMessage);

		}
//		if (FaultTolerantFiltererFactory.getOrCreateSingleton().isBroadcastMessage(remoteName, aMessage)) {
////		String anId = FaultToleranceManagerFactory.getSingleton().getId(aMessage);
////		IdentifiableMessage aIdentifiableMessage = FaultToleranceManagerFactory.getSingleton().getIdentifiableMessage(aMessage);
////		// record before sending just in case response received before recording
////		FaultToleranceManagerFactory.getSingleton().setLastIdentifiableMessageSent(aIdentifiableMessage);
//		anActualSentMessage = FaultToleranceManagerFactory.getSingleton().processSentBroadcastMessage(aMessage);
//		if (anActualSentMessage == null) // means do not send
//			return; 
//		} else if (FaultTolerantFiltererFactory.getOrCreateSingleton().isRelayedMessage(remoteName, aMessage)) {
////			SequencedMessage aSequencedMesage = FaultToleranceManagerFactory.getSingleton().getSequencedMessage(aMessage);
//			anActualSentMessage = FaultToleranceManagerFactory.getSingleton().processSentRelayedMessage(aMessage);
//		}
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/afaulttolerantserializingforwarderfactory.java
package gipc.session.faulttolerant.forwarders;

import java.nio.ByteBuffer;

import inputport.InputPort;
import inputport.datacomm.NamingSender;
import inputport.datacomm.simplex.object.ASerializingForwarderFactory;
import inputport.datacomm.simplex.object.SerializingForwarder;

public class AFaultTolerantSerializingForwarderFactory extends ASerializingForwarderFactory {
	SerializingForwarder lastSendTrapper;
	@Override
	public SerializingForwarder createSendTrapper(InputPort anInputPort,
			NamingSender<ByteBuffer> aDestination) {
//		lastSendTrapper = new  AFaultTolerantSerializingForwarder(anInputPort, aDestination);
		return new AFaultTolerantSerializingForwarder(anInputPort, aDestination);
//		return lastSendTrapper;

	}
//	@Override
//	public SendTrapper<Object, ByteBuffer> getLastSendTrapper() {
//		return lastSendTrapper;
//	}


}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/faulttolerantdeserializingforwarder.java
package gipc.session.faulttolerant.forwarders;

import java.nio.ByteBuffer;

import inputport.datacomm.ReceiveTrapper;

public interface FaultTolerantDeserializingForwarder extends ReceiveTrapper<ByteBuffer, Object> {

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/forwarders/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.faulttolerant.forwarders;
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/alicesimulationgipcfaulttolerantrelayingclient.java
package gipc.session.faulttolerant.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.session.faulttolerant.relayingclient.AGIPCSimulationFaultTolerantRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.AliceSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationGIPCFaultTolerantRelayingClient extends AGIPCSimulationFaultTolerantRelayingClientLauncher implements AliceUI, AliceSessionPort {

public AliceSimulationGIPCFaultTolerantRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return ALICE_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(true);
//	OEFrame oeFrame = AliceControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
//	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setLocation(AliceControllerUI.CONTROLLER_X, AliceControllerUI.CONTROLLER_Y);
	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new AliceSimulationGIPCFaultTolerantRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/bobsimulationgipcfaulttolerantrelayingclient.java
package gipc.session.faulttolerant.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.session.faulttolerant.relayingclient.AGIPCSimulationFaultTolerantRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.BobSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationGIPCFaultTolerantRelayingClient extends AGIPCSimulationFaultTolerantRelayingClientLauncher implements BobUI, BobSessionPort {

public BobSimulationGIPCFaultTolerantRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return BOB_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(true);
//	OEFrame oeFrame = BobControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
//	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setLocation(BobControllerUI.CONTROLLER_X, BobControllerUI.CONTROLLER_Y);

	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
	(new BobSimulationGIPCFaultTolerantRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/cathysimulationgipcfaulttolerantrelayingclient.java
package gipc.session.faulttolerant.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.session.faulttolerant.relayingclient.AGIPCSimulationFaultTolerantRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.CathySessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationGIPCFaultTolerantRelayingClient extends AGIPCSimulationFaultTolerantRelayingClientLauncher implements CathyUI, CathySessionPort {

public CathySimulationGIPCFaultTolerantRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return CATHY_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(true);
//	OEFrame oeFrame = CathyControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
//	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setLocation(CathyControllerUI.CONTROLLER_X, CathyControllerUI.CONTROLLER_Y);

	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
	(new CathySimulationGIPCFaultTolerantRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/davidsimulationgipcfaulttolerantrelayingclient.java
package gipc.session.faulttolerant.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.DavidCommandProcessorFactory;
import common.controller.DavidControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.DavidUI;
import gipc.session.faulttolerant.relayingclient.AGIPCSimulationFaultTolerantRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.DavidSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class DavidSimulationGIPCFaultTolerantRelayingClient extends AGIPCSimulationFaultTolerantRelayingClientLauncher implements DavidUI, DavidSessionPort {

public DavidSimulationGIPCFaultTolerantRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return DAVID_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(true);
	Tracer.showInfo(true);
//	OEFrame oeFrame = CathyControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
//	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setLocation(DavidControllerUI.CONTROLLER_X, DavidControllerUI.CONTROLLER_Y);
	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = DavidCommandProcessorFactory.getOrCreateSingleton();
	(new DavidSimulationGIPCFaultTolerantRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/interactivedemoerofgipcfaulttolerantrelayingclient.java
package gipc.session.faulttolerant.launcher;

import bus.uigen.pipe.MainClassLaunchingUtility;
import gipc.session.sessionmanager.ACustomSerializerSessionServerLauncher;

public class InteractiveDemoerOfGIPCFaultTolerantRelayingClient {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {		
		Class[] classes = {
//				SessionPortSessionServerLauncher.class,
				ACustomSerializerSessionServerLauncher.class,
				AliceSimulationGIPCFaultTolerantRelayingClient.class,
				BobSimulationGIPCFaultTolerantRelayingClient.class,
				CathySimulationGIPCFaultTolerantRelayingClient.class,
				DavidSimulationGIPCFaultTolerantRelayingClient.class,

//				ABobDuplexRPCSessionPort.class,
//				AModularCathyDuplexRPCSessionPort.class,
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}	

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/launcher/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.faulttolerant.launcher;
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/abroadcastmessage.java
package gipc.session.faulttolerant.messages;

public class ABroadcastMessage extends AnIdentifiableMessage implements BroadcastMessage{

	public ABroadcastMessage() {
	}

	public ABroadcastMessage(Object message, String identifier) {
		super(message, identifier);
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/afinishedsynchronizingmessage.java
package gipc.session.faulttolerant.messages;

public class AFinishedSynchronizingMessage implements FinishedSynchronizingMessage  {

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/alastreceivedsequencenumber.java
package gipc.session.faulttolerant.messages;

public class ALastReceivedSequenceNumber   implements SynchronizingMessage{
	int sequenceNumber;
	public ALastReceivedSequenceNumber() {
		
	}
	public ALastReceivedSequenceNumber(int sequenceNumber) {
		super();
		this.sequenceNumber = sequenceNumber;
	}
	@Override
	public int getSequenceNumber() {
		return sequenceNumber;
	}
	protected void setSequenceNumber(int sequenceNumber) {
		this.sequenceNumber = sequenceNumber;
	}
	public String toString() {
		return "Last received sequence number:" + sequenceNumber;
	}
}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/amostrecentrelay.java
package gipc.session.faulttolerant.messages;
/*
 * sent from client to relayer with last relayed message
 */
public class AMostRecentRelay extends ASequencedMessage implements MostRecentRelay {

	public AMostRecentRelay() {
	}

	public AMostRecentRelay(Object message, String identifier,
			int sequenceNunber) {
		super(message, identifier, sequenceNunber);
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/arelayedmessage.java
package gipc.session.faulttolerant.messages;

public class ARelayedMessage extends ASequencedMessage implements RelayedMessage{
	Object sourceBroadcast;
	public Object getBroadcastObject() {
		return sourceBroadcast;
	}

	public void setBroadcastObject(Object sourceBroadcast) {
		this.sourceBroadcast = sourceBroadcast;
	}

	public ARelayedMessage() {
	}

	public ARelayedMessage(Object message, String identifier, int sequenceNunber, Object aSourceBroadcast) {
		super(message, identifier, sequenceNunber);
		sourceBroadcast = aSourceBroadcast;
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/asequencedmessage.java
package gipc.session.faulttolerant.messages;

public class ASequencedMessage extends AnIdentifiableMessage implements SequencedMessage{
	int sequenceNumber;

	public ASequencedMessage(Object message, String identifier, int sequenceNunber) {
		super(message, identifier);
		this.sequenceNumber = sequenceNunber;
	}
	public ASequencedMessage() {
		
	}
	@Override
	public int getSequenceNumber() {
		return sequenceNumber;
	}

	@Override
	public void setSequenceNumber(int sequenceNunber) {
		this.sequenceNumber = sequenceNunber;
	}
	
	public String toString() {
		return sequenceNumber + "," + super.toString();
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/asequencedmessagebuffer.java
package gipc.session.faulttolerant.messages;

import java.util.ArrayList;
import java.util.List;

public class ASequencedMessageBuffer implements SequencedMessageBuffer {
	List<SequencedMessage> buffer = new ArrayList();
	@Override
	public int insertMessage(SequencedMessage aMessage) {
		int anIndex = indexOf(aMessage);
		if (anIndex == -1)
			anIndex = buffer.size();
		buffer.add(anIndex, aMessage);
		return anIndex;
		
	}
	@Override
	public int indexOf(SequencedMessage aMessage) {
		return indexOf(aMessage.getSequenceNumber());
	}
	
	@Override
	public int indexOf(int aSequenceNumber) {
		int retVal = buffer.size();
		for (int i = 0; i < buffer.size(); i++) {
			if (buffer.get(i).getSequenceNumber() > aSequenceNumber)
				return i;
		}
		return -1;
	}
	
	@Override
	public List<SequencedMessage> removeMessagesFrom (int aSequenceNumber) {
		List<SequencedMessage> result = new ArrayList();
		int anIndex = indexOf(aSequenceNumber);
		if (anIndex == -1)
			return result;
		for (int i = anIndex; i < buffer.size(); i++ ) {
			result.add(buffer.get(i));
			
		}
		
		for (int i = anIndex; i < buffer.size(); i++ ) {
			buffer.remove(anIndex);
			
		}
		return result;
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/anidentifiablemessage.java
package gipc.session.faulttolerant.messages;

public class AnIdentifiableMessage implements IdentifiableMessage {
	Object message;
	String identifier;
	
	public AnIdentifiableMessage(Object message, String identifier) {
		super();
		this.message = message;
		this.identifier = identifier;
	}
	public AnIdentifiableMessage() {
		
	}
	@Override
	public Object getMessage() {
		return message;
	}
	@Override
	public void setMessage(Object message) {
		this.message = message;
	}
	@Override
	public String getIdentifier() {
		return identifier;
	}
	@Override
	public void setIdentifier(String identifier) {
		this.identifier = identifier;
	}
	
	public String toString() {
		return identifier + ":" + message;
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/broadcastmessage.java
package gipc.session.faulttolerant.messages;

public interface BroadcastMessage extends IdentifiableMessage{

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/finishedsynchronizingmessage.java
package gipc.session.faulttolerant.messages;

import java.io.Serializable;

public interface FinishedSynchronizingMessage extends Serializable{

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/identifiablemessage.java
package gipc.session.faulttolerant.messages;

import java.io.Serializable;

public interface IdentifiableMessage extends Serializable{

	public abstract Object getMessage();

	public abstract void setMessage(Object message);

	public abstract String getIdentifier();

	public abstract void setIdentifier(String identifier);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/mostrecentrelay.java
package gipc.session.faulttolerant.messages;

public interface MostRecentRelay extends SynchronizingMessage, SequencedMessage{

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/nextexpectedsequencenumber.java
package gipc.session.faulttolerant.messages;

public interface NextExpectedSequenceNumber {
	int getSequenceNumber();

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/relayedmessage.java
package gipc.session.faulttolerant.messages;

public interface RelayedMessage extends SequencedMessage {
	 Object getBroadcastObject() ;

	 void setBroadcastObject(Object sourceBroadcast);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/sequencedmessage.java
package gipc.session.faulttolerant.messages;

public interface SequencedMessage extends IdentifiableMessage{

	public abstract int getSequenceNumber();

	public abstract void setSequenceNumber(int sequenceNunber);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/sequencedmessagebuffer.java
package gipc.session.faulttolerant.messages;

import java.util.List;

public interface SequencedMessageBuffer {

	public abstract int insertMessage(SequencedMessage aMessage);

	public abstract int indexOf(SequencedMessage aMessage);

	public abstract int indexOf(int aSequenceNumber);

	public abstract List<SequencedMessage> removeMessagesFrom(
			int aSequenceNumber);

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/synchronizingmessage.java
package gipc.session.faulttolerant.messages;

import java.io.Serializable;

public interface SynchronizingMessage extends Serializable{
	int getSequenceNumber();

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/messages/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.faulttolerant.messages;
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.faulttolerant;
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/relayingclient/agipcsimulationfaulttolerantrelayingclientlauncher.java
package gipc.session.faulttolerant.relayingclient;

import common.controller.TrickOrTreatClientControllerFactory;
import gipc.session.faulttolerant.FaultToleranceManagerFactory;
import gipc.session.faulttolerant.FaultTolerantFiltererFactory;
import gipc.session.faulttolerant.forwarders.AFaultTolerantDeserializingForwarderFactory;
import gipc.session.faulttolerant.forwarders.AFaultTolerantSerializingForwarderFactory;
import gipc.session.relayingclient.AGIPCSimulationRelayingClientLauncher;
import gipc.session.relayingclient.RelayerConnectorFactory;
import inputport.ConnectionListener;
import inputport.InputPort;
import inputport.datacomm.simplex.object.ObjectTranslatingIPTrapperSelector;
import port.PortAccessKind;
import port.PortKind;
import port.SessionChoice;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.server.AnRMISimulationRelayer;
import sessionport.rpc.duplex.DuplexRPCSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.RelayerControllerFactory;
import util.trace.Tracer;

public class AGIPCSimulationFaultTolerantRelayingClientLauncher extends AGIPCSimulationRelayingClientLauncher{
	public AGIPCSimulationFaultTolerantRelayingClientLauncher(String aClientName,
			String aServerHost, String aServerId, String aServerName,
			HalloweenCommandProcessor aCommandProcessor, boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName, aCommandProcessor,
				aBroadcastData);
		commandProcessor.setConnectedToSimulation(false);
		RelayerControllerFactory.getOrCreateSingleton().setEchoBack(true);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().setInterCommandTime(300);
		addFaultToleranceFilterers();
//		Tracer.showInfo(true);
//		Tracer.setKeywordPrintStatus(AFaultTolerantSerializingForwarderFactory.class, true);
//		Tracer.setKeywordPrintStatus(AFaultTolerantDeserializingForwarderFactory.class, true);

//
		Tracer.setDisplayThreadName(true);
//		Tracer.setKeywordPrintStatus(AFaultToleranceManager.class, true);

		
	}
	// cannot use parameterized version as no launcher support exists for duplex session port in registry right now
//		protected  InputPort getPort() {
//
//			return DuplexRPCSessionPortSelector.createDuplexRPCSessionPort("localhost", 
//					"" + serverId, serverName, getSessionName(), clientId, clientName,
//					ParticipantChoice.MEMBER
//					);	
//			
//		}
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
		ObjectTranslatingIPTrapperSelector.getTrapperSelector().setReceiveTrapperFactory(new AFaultTolerantDeserializingForwarderFactory());
		ObjectTranslatingIPTrapperSelector.getTrapperSelector().setSendTrapperFactory(new AFaultTolerantSerializingForwarderFactory());
		addFaultToleranceFilterers();


	}
		protected RMISimulationRelayer getSessionServer() {
			return new AnRMISimulationRelayer();
		}
		protected void registerRemoteObjects() {
			DuplexRPCSessionPort aSessionPort = (DuplexRPCSessionPort) mainPort;
			RMISimulationRelayer sessionServer = getSessionServer();			
			aSessionPort.register(sessionServer);
			
//			Adder adder = new AnAdder();
			
		}
		// do nothing do not create any proxies
		protected  void createProxies() {

//			sessionServerProxy = (RMISimulationSessionServer) DirectedRPCProxyGenerator.generateRPCProxy((DuplexRPCClientInputPort) mainPort, registeredSessionServerClass());
//			sessionServerProxy = (RMISimulationSessionServer)  createProxy (registeredSessionServerClass());
		}
		// do nothing
//		public  void  launchClient(String aMyName, HalloweenCommandProcessor aCommandProcessor, boolean aBroadcast) {
//			
//		}
		// do nothing
//		@Override
//		public  void  connectInCoupler() {
//			
//		}
//		protected void connectOutCoupler() {
//			  if (broadcastData) {
//				   new ADynamicallyBoundSimulationOutCoupler(commandProcessor,  clientName);
//			   }
//		}
//		@Override
//		protected void setStateAfterPortButBeforeConnection() {
//			createFaultToleranceManager(mainPort);
//			RelayerControllerFactory.getOrCreateSingleton().setEchoBack(true);
//
//
//		}
		protected void createUI(InputPort anInputPort) {

			super.createUI(anInputPort);
		
		}
		
		protected void createFaultToleranceManager(InputPort anInputPort) {
			FaultToleranceManagerFactory.createSingleton((DuplexRPCSessionPort) anInputPort);
		}
		protected void addFaultToleranceFilterers() {
			FaultTolerantFiltererFactory.getOrCreateSingleton().
				setBroadcastHeaders(new String[] {"broadcast(java.lang.String,java.lang.String)"});
			FaultTolerantFiltererFactory.getOrCreateSingleton().
				setRelayedHeaders(new String[] {"processCommand(java.lang.String)"});

		}

		protected  ConnectionListener getConnectionListener (InputPort anInputPort) {
			createFaultToleranceManager(anInputPort);

			return RelayerConnectorFactory.createSingleton((DuplexRPCSessionPort) anInputPort, createRMISimulationInCoupler());
		}
		public PortKind getPortKind() {
			return PortKind.SESSION_PORT;
		}
		public PortAccessKind getPortAccessKind() {
			return PortAccessKind.DUPLEX;
		}	
		protected SessionChoice getSessionChoice() {
			return SessionChoice.P2P;
		}

}
//END OF FILE
//START OF FILE: src/gipc/session/faulttolerant/relayingclient/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.faulttolerant.relayingclient;
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/adynamicallyboundsimulationoutcoupler.java
package gipc.session.relayingclient;

import rmi.simulation.client.AnRMISimulationOutCoupler;
import rmi.simulation.common.RMISimulationRelayer;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;

public class ADynamicallyBoundSimulationOutCoupler extends AnRMISimulationOutCoupler{

	public ADynamicallyBoundSimulationOutCoupler(
			HalloweenCommandProcessor anObservedSimulaton,
			 String aName) {
		super(anObservedSimulaton, null, aName, IPCMechanism.RMI);
		// TODO Auto-generated constructor stub
	}
	public RMISimulationRelayer getSessionServer() {
		RMISimulationRelayer result = super.getSessionServer();
		if (result == null)
			result = RelayerConnectorFactory.getSingleton().getCurrentRelayer();
		return result;
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/agipcsimulationrelayingclientlauncher.java
package gipc.session.relayingclient;

import gipc.customserializer.client.ACustomSerializerGIPCSimulationClientLauncher;
import inputport.ConnectionListener;
import inputport.InputPort;
import inputport.rpc.DirectedRPCProxyGenerator;
import port.PortAccessKind;
import port.PortKind;
import port.SessionChoice;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.server.AnRMISimulationRelayer;
import sessionport.rpc.duplex.DuplexRPCSessionPort;
import stringProcessors.HalloweenCommandProcessor;

public class AGIPCSimulationRelayingClientLauncher extends ACustomSerializerGIPCSimulationClientLauncher{
	public AGIPCSimulationRelayingClientLauncher(String aClientName,
			String aServerHost, String aServerId, String aServerName,
			HalloweenCommandProcessor aCommandProcessor, boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName, aCommandProcessor,
				aBroadcastData);
		DirectedRPCProxyGenerator.setDoShortCircuitLocalCallsToRemotes(false);
		
	}
	// cannot use parameterized version as no launcher support exists for duplex session port in registry right now
//		protected  InputPort getPort() {
//
//			return DuplexRPCSessionPortSelector.createDuplexRPCSessionPort("localhost", 
//					"" + serverId, serverName, getSessionName(), clientId, clientName,
//					ParticipantChoice.MEMBER
//					);	
//			
//		}
		protected RMISimulationRelayer getSessionServer() {
			return new AnRMISimulationRelayer();
		}
		protected void registerRemoteObjects() {
			DuplexRPCSessionPort aSessionPort = (DuplexRPCSessionPort) mainPort;
			RMISimulationRelayer sessionServer = getSessionServer();
			aSessionPort.register(sessionServer);
			
//			Adder adder = new AnAdder();
			
		}
		// do nothing do not create any proxies
		protected  void createProxies() {

//			sessionServerProxy = (RMISimulationSessionServer) DirectedRPCProxyGenerator.generateRPCProxy((DuplexRPCClientInputPort) mainPort, registeredSessionServerClass());
//			sessionServerProxy = (RMISimulationSessionServer)  createProxy (registeredSessionServerClass());
		}
		// do nothing
//		public  void  launchClient(String aMyName, HalloweenCommandProcessor aCommandProcessor, boolean aBroadcast) {
//			
//		}
		// do nothing
		@Override
		public  void  connectInCoupler() {
			
		}
		protected void connectOutCoupler() {
			  if (broadcastData) {
				   new ADynamicallyBoundSimulationOutCoupler(commandProcessor,  clientName);
			   }
		}

		protected  ConnectionListener getConnectionListener (InputPort anInputPort) {
			return RelayerConnectorFactory.createSingleton((DuplexRPCSessionPort) mainPort, createRMISimulationInCoupler());
		}
		public PortKind getPortKind() {
			return PortKind.SESSION_PORT;
		}
		public PortAccessKind getPortAccessKind() {
			return PortAccessKind.DUPLEX;
		}	
		protected SessionChoice getSessionChoice() {
			return SessionChoice.P2P;
		}

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/arelayerconnector.java
package gipc.session.relayingclient;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import inputport.ConnectionType;
import inputport.rpc.DirectedRPCProxyGenerator;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationRelayer;
import sessionport.rpc.duplex.DuplexRPCSessionPort;

public class ARelayerConnector implements RelayerConnector{
	DuplexRPCSessionPort sessionPort;
	Map<String, RMISimulationRelayer>  remoteEndToRelayer = new HashMap();
	

//	String currentRelayerName;
	RelayerElector relayerElector;
	RMISimulationInCoupler inCoupler;
	public ARelayerConnector(DuplexRPCSessionPort aSessionPort, RMISimulationInCoupler anInCoupler) {
		sessionPort = aSessionPort;
		inCoupler = anInCoupler;
		relayerElector = RelayerElectorFactory.getSingleton();
	}
	
	

	

	@Override
	public synchronized void connected(String remoteEnd, ConnectionType aConnectionType) {
		if (aConnectionType == ConnectionType.MEMBER_TO_SESSION ) {
//		System.out.print("Connected  " + remoteEnd);
		RMISimulationRelayer aRelayerProxy = (RMISimulationRelayer) DirectedRPCProxyGenerator.generateRPCProxy(sessionPort, remoteEnd, RMISimulationRelayer.class, null);
		remoteEndToRelayer.put(remoteEnd, aRelayerProxy);	
		maybeRetargetRelayer();
		}
		
	}

	@Override
	public synchronized void disconnected(String remoteEndName,
			boolean explicitDsconnection, String systemMessage, ConnectionType aConnectionType) {
		remoteEndToRelayer.remove(remoteEndName);
		maybeRetargetRelayer();
		
	}

	@Override
	public void notConnected(String remoteEnd, String message, ConnectionType aConnectionType) {
		
	}
	public   void  connectToRelayer() {
		try {
			
			RMISimulationRelayer aRelayer = getCurrentRelayer();
			aRelayer.join(sessionPort.getLocalName(), inCoupler);
		   
			
				   
		   } catch (Exception e) {
			
	      e.printStackTrace();
	    }
	  
	  }
//	public String getCurrentRelayerName() {
//		return currentRelayerName;
//	}
	public RMISimulationRelayer getCurrentRelayer() {
		if (relayerElector.getCurrentRelayerName() != null) {
			return remoteEndToRelayer.get(relayerElector.getCurrentRelayerName());
		} else
			return null;
	}
	protected void maybeRetargetRelayer() {
		if (remoteEndToRelayer.size() == 0)
			return; // should never be executed
//		String oldRelayerName = currentRelayerName;
		String oldRelayerName = relayerElector.getCurrentRelayerName();
		RMISimulationRelayer oldRelayer = getCurrentRelayer();
		List<String> relayerNames = new ArrayList(remoteEndToRelayer.keySet());
//		System.out.println("Current relayer names:" + relayerNames);
		if (!relayerElector.processConnectionChange(relayerNames)) 
			return;
//		Collections.sort(relayerNames);
//		currentRelayerName = relayerNames.get(0);
		String newRelayerName = relayerElector.getCurrentRelayerName();
		RMISimulationRelayer newRelayer = getCurrentRelayer();
//		if (newRelayer == oldRelayer)
//			return;
		try {
		if (oldRelayer != null) {
			
			oldRelayer.leave(sessionPort.getLocalName());
			relayerElector.processLeave(oldRelayerName);
			
		}
		newRelayer.join(sessionPort.getLocalName(), inCoupler);		
		relayerElector.processJoin(newRelayerName);

		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
//	public void setCurrentRelayerName(String currentRelayerName) {
//		this.currentRelayerName = currentRelayerName;
//	}
	public Map<String, RMISimulationRelayer> getRemoteEndToRelayer() {
		return remoteEndToRelayer;
	}

	public void setRemoteEndToRelayer(
			Map<String, RMISimulationRelayer> remoteEndToRelayer) {
		this.remoteEndToRelayer = remoteEndToRelayer;
	}
}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/arelayerelector.java
package gipc.session.relayingclient;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ARelayerElector implements RelayerElector {
	List<String> currentRelayerNames = new ArrayList();
	
	protected String currentRelayerName;
//	Map<String, Object>  remoteEndToRelayer = new HashMap();
//	public ARetargetableRelayerManager(DuplexRPCSessionPort aSessionPort) {
//		sessionPort = aSessionPort;
//	}
	@Override
	public String getCurrentRelayerName() {
		return currentRelayerName;
	}
//	public Object processPeerConnection(String aPeerName, Object aRelayer) {
//		remoteEndToRelayer.put(aPeerName, aRelayer);
//		return processElectRelayer();
//		
//	}
//	
//	public Object processPeerDisconnection(String aPeerName, Object aRelayer) {
//		remoteEndToRelayer.remove(aPeerName);
//		return processElectRelayer();		
//	}
	
	@Override
	/**
	 * return true if new relayer;
	 */
	
	public boolean processConnectionChange(List<String> aRelayerNames) {
			
			if (aRelayerNames.size() == 0)
				return currentRelayerName != null ; // should never be executed
//			String oldRelayerName = currentRelayerName;
//			List<String> relayerNames = new ArrayList(remoteEndToRelayer.keySet());
			Collections.sort(aRelayerNames);
//			System.out.println("Sorted relayer names:" + aRelayerNames);

			String oldRelayerName = currentRelayerName;			
//			currentRelayerName = aRelayerNames.get(0);
			currentRelayerName = aRelayerNames.get(aRelayerNames.size() - 1);
			currentRelayerNames = aRelayerNames;
//			System.out.println(Thread.currentThread() + "New relayer name" + currentRelayerName);

			return !currentRelayerName.equals(oldRelayerName); // new relayer
//			return getCurrentRelayer();
			
		
	}
	@Override
	public void processJoin(String aRelayerName) {
		
	}
	@Override
    public void processLeave(String aRelayerName) {
		
	}
	protected List<String> getRelayerNames() {
		return currentRelayerNames;
	}

	protected void setCurrentRelayerNames(List<String> currentRelayerNames) {
		this.currentRelayerNames = currentRelayerNames;
	}

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/relayerconnector.java
package gipc.session.relayingclient;

import java.util.Map;

import inputport.ConnectionListener;
import rmi.simulation.common.RMISimulationRelayer;

public interface RelayerConnector extends ConnectionListener {

//	public String getCurrentRelayerName() ;
//
//	public void setCurrentRelayerName(String currentRelayerName) ;
	public Map<String, RMISimulationRelayer> getRemoteEndToRelayer() ;

	public void setRemoteEndToRelayer(
			Map<String, RMISimulationRelayer> remoteEndToRelayer) ;
	public RMISimulationRelayer getCurrentRelayer();

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/relayerconnectorfactory.java
package gipc.session.relayingclient;

import rmi.simulation.common.RMISimulationInCoupler;
import sessionport.rpc.duplex.DuplexRPCSessionPort;


public class RelayerConnectorFactory {
	static RelayerConnector singleton;
	public static void setSingleton(RelayerConnector newVal) {
		singleton = newVal;
	}
	public static RelayerConnector createSingleton(DuplexRPCSessionPort aSessionPort, RMISimulationInCoupler anInCoupler) {
		if (singleton == null) {
			singleton = new ARelayerConnector(aSessionPort, anInCoupler);
		}
		return singleton;
			
	}
	public static RelayerConnector getSingleton() {
		return singleton;
	}
}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/relayerelector.java
package gipc.session.relayingclient;

import java.util.List;

public interface RelayerElector {

	//	Map<String, Object>  remoteEndToRelayer = new HashMap();
	//	public ARetargetableRelayerManager(DuplexRPCSessionPort aSessionPort) {
	//		sessionPort = aSessionPort;
	//	}
	public abstract String getCurrentRelayerName();

	//	public Object processPeerConnection(String aPeerName, Object aRelayer) {
	//		remoteEndToRelayer.put(aPeerName, aRelayer);
	//		return processElectRelayer();
	//		
	//	}
	//	
	//	public Object processPeerDisconnection(String aPeerName, Object aRelayer) {
	//		remoteEndToRelayer.remove(aPeerName);
	//		return processElectRelayer();		
	//	}

	public abstract boolean processConnectionChange(List<String> relayerNames);

	void processJoin(String aRelayerName);

	void processLeave(String aRelayerName);

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/relayerelectorfactory.java
package gipc.session.relayingclient;

public class RelayerElectorFactory {
	static RelayerElector singleton;
	public static void setSingleton(RelayerElector newVal) {
		singleton = newVal;
	}
	public static RelayerElector getSingleton() {
		if (singleton == null) {
			singleton = new ARelayerElector();
		}
		return singleton;
			
	}
	
}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/launcher/alicesimulationgipcrelayingclient.java
package gipc.session.relayingclient.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.session.relayingclient.AGIPCSimulationRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.AliceSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationGIPCRelayingClient extends AGIPCSimulationRelayingClientLauncher implements AliceUI, AliceSessionPort {

public AliceSimulationGIPCRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return ALICE_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new AliceSimulationGIPCRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/launcher/bobsimulationgipcrelayingclient.java
package gipc.session.relayingclient.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.session.relayingclient.AGIPCSimulationRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.BobSessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationGIPCRelayingClient extends AGIPCSimulationRelayingClientLauncher implements BobUI, BobSessionPort {

public BobSimulationGIPCRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return BOB_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
	(new BobSimulationGIPCRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/launcher/cathysimulationgipcrelayingclient.java
package gipc.session.relayingclient.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.session.relayingclient.AGIPCSimulationRelayingClientLauncher;
import port.sessionserver.SessionServerLauncher;
import sessionport.rpc.group.mvc.flexible.example.CathySessionPort;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationGIPCRelayingClient extends AGIPCSimulationRelayingClientLauncher implements CathyUI, CathySessionPort {

public CathySimulationGIPCRelayingClient(String aClientName,
			String aServerHost, String aServerId,
			String aServerName, HalloweenCommandProcessor aCommandProcessor,
			boolean aBroadcastData) {
		super(aClientName,  aServerHost, aServerId, aServerName,
				aCommandProcessor, aBroadcastData);
		// TODO Auto-generated constructor stub
	}
@Override
protected String getClientId() {
	return CATHY_ID;
	
}

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);
	OEFrame oeFrame = CathyControllerUI.createUI();
	OEFrame relayerFrame = ServerControllerUI.createUI();
	relayerFrame.setLocation((int) oeFrame.getLocation().getX(), (int) oeFrame.getLocation().getY());
	relayerFrame.setTitle(NAME + " Relayer");
	HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
	(new CathySimulationGIPCRelayingClient(NAME, "localhost", 
		
			SessionServerLauncher.SESSION_SERVER_ID,
			SessionServerLauncher.SESSION_SERVER_NAME, 
			aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/launcher/interactivedemoerofgipcrelayingclient.java
package gipc.session.relayingclient.launcher;

import bus.uigen.pipe.MainClassLaunchingUtility;
import gipc.session.sessionmanager.ACustomSerializerSessionServerLauncher;

public class InteractiveDemoerOfGIPCRelayingClient {
	public static void main(String args[]) {
		demo();
	}	
	public static void demo() {		
		Class[] classes = {
//				SessionPortSessionServerLauncher.class,
//				ACustomSerializerGIPCSimulationServerLauncher.class,
				ACustomSerializerSessionServerLauncher.class,
				AliceSimulationGIPCRelayingClient.class,
				BobSimulationGIPCRelayingClient.class,
				CathySimulationGIPCRelayingClient.class,
//				ABobDuplexRPCSessionPort.class,
//				AModularCathyDuplexRPCSessionPort.class,
		};
		MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}	

}
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/launcher/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.relayingclient.launcher;
//END OF FILE
//START OF FILE: src/gipc/session/relayingclient/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.relayingclient;
//END OF FILE
//START OF FILE: src/gipc/session/sessionmanager/acustomserializersessionserverlauncher.java
package gipc.session.sessionmanager;

import inputport.nio.manager.AScatterGatherSelectionManager;
import port.sessionserver.ASessionServerLauncher;
import serialization.SerializerSelector;
import serialization.logical.ALogicalStructureSerializer;
import serialization.logical.ALogicalStructureSerializerFactory;
import util.trace.Tracer;

public class ACustomSerializerSessionServerLauncher extends ASessionServerLauncher{

	public ACustomSerializerSessionServerLauncher(String aSessionServerId,
			String aSessionServerName, String aLogicalServerName) {
		super(aSessionServerId, aSessionServerName, aLogicalServerName);
	}
	public ACustomSerializerSessionServerLauncher(String aSessionServerId,
			String aSessionServerName) {
		super(aSessionServerId, aSessionServerName);
		// TODO Auto-generated constructor stub
	}
	@Override
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
//		Tracer.showInfo(true);
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, false);
//		Tracer.setKeywordPrintStatus(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
		Tracer.setKeywordPrintStatus(ALogicalStructureSerializer.class, true);
//		(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
//		Tracer.showInfo(true);
		SerializerSelector.setSerializerFactory(new ALogicalStructureSerializerFactory());

//		DuplexRPCInputPortSelector.setInputPortFactory(new AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory());
		
//		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
//		SynchronousDuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(new AProcedureSyncingDuplexReceivedCallInvokerFactory());

		
	}
	public static void main (String args[]) {	
		AScatterGatherSelectionManager.setMaxOutstandingWrites(1000);

		(new ACustomSerializerSessionServerLauncher("" + SESSION_SERVER_PORT, SESSION_SERVER_NAME)).launch();
	}
	

}
//END OF FILE
//START OF FILE: src/gipc/session/sessionmanager/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package gipc.session.sessionmanager;
//END OF FILE
//START OF FILE: src/gipc/simulation/client/agipcandrmiandniosimulationclient.java
package gipc.simulation.client;

import inputport.rpc.GIPCLocateRegistry;
import inputport.rpc.GIPCRegistry;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import rmi.simulation.client.AnRMIAndNIOSimulationClient;
import rmi.simulation.client.AnRMISimulationInCoupler;
import rmi.simulation.client.AnRMISimulationOutCoupler;
import rmi.simulation.client.RMIAndNIOSimulationClient;
import rmi.simulation.client.twophase.ATwoPhaseRMIAndNIOSimulationClient;
import rmi.simulation.client.twophase.ATwoPhaseRMISimulationInCoupler;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationInCoupler;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationRelayer;
import util.annotations.Tags;
import util.interactiveMethodInvocation.IPCMechanism;
import util.tags.DistributedTags;
@Tags({DistributedTags.CLIENT, DistributedTags.RMI, DistributedTags.GIPC, DistributedTags.NIO})
public class AGIPCAndRMIAndNIOSimulationClient 
		extends ATwoPhaseRMIAndNIOSimulationClient  
		implements GIPCAndRMIAndNIOSimulationClient{
	protected TwoPhaseRMISimulationRelayer gipcServerProxy;

	@Override
	public void initialize(String aServerHost, int aServerPort,
			String aClientName, String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset, String anRMIRegistryHost,
			int anRMIRegistryPort, int aGIPCServerPort) {
		super.initialize(aServerHost, aServerPort, aClientName, aPrefix, anXOffset,
				aYOffset, aWidth, aHeight, aCommandWindowXOffset, aCommandWindowYOffset, 
				anRMIRegistryHost, anRMIRegistryPort);
		TwoPhaseRMISimulationInCoupler inCoupler = new ATwoPhaseRMISimulationInCoupler(commandProcessor);

		GIPCRegistry aGIPCRegistry;

		try {
		
		
			// this is where we block if necessary
//			rmiRegistry = LocateRegistry.getRegistry();
			aGIPCRegistry = GIPCLocateRegistry.getRegistry(aServerHost, aGIPCServerPort, aClientName);
			
			gipcServerProxy = (TwoPhaseRMISimulationRelayer) aGIPCRegistry.lookup(TwoPhaseRMISimulationRelayer.class, RMISimulationServerLauncher.SESSION_SERVER);
		   
			gipcServerProxy.join(aClientName, inCoupler);
			
			new AnRMISimulationOutCoupler(commandProcessor, gipcServerProxy, aClientName, IPCMechanism.GIPC);
			 
//				ClientControllerFactory.getOrCreateSingleton().setServerId(RMISimulationServerLauncher.SESSION_SERVER);
			

				   
		   } catch (Exception e) {
			
	      e.printStackTrace();
	    }
		
	}
	public static void launchClient(String aServerHost, int aServerPort,
			String aClientName, String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset,
			String anRMIHost,
			int anRMIPort,
			int aGIPCPort) {
		GIPCAndRMIAndNIOSimulationClient aClient = new AGIPCAndRMIAndNIOSimulationClient();
		rmiAndNIOClient = aClient;
		nioManagerClient = aClient;
		aClient.initialize(aServerHost, aServerPort, aClientName, aPrefix,
				anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
				aCommandWindowYOffset, anRMIHost, anRMIPort, aGIPCPort);
		aClient.processCommands();

	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/client/agipcsimulationclientlauncher.java
package gipc.simulation.client;


import gipc.simulation.server.AGIPCSimulationServerLauncher;
import inputport.ConnectionListener;
import inputport.InputPort;
import inputport.nio.manager.AScatterGatherSelectionManager;
import inputport.rpc.duplex.AnAbstractDuplexRPCClientPortLauncher;
import port.ATracingConnectionListener;
import rmi.simulation.client.AnRMISimulationInCoupler;
import rmi.simulation.client.AnRMISimulationOutCoupler;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationRelayer;
import serialization.logical.ABeanSerializer;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;
import util.remote.RelayerClientControllerFactory;
import util.trace.Tracer;





public class AGIPCSimulationClientLauncher extends AnAbstractDuplexRPCClientPortLauncher  implements GIPCSimulationClientLauncher{
	protected boolean broadcastData;

	protected HalloweenCommandProcessor commandProcessor;
	

	public AGIPCSimulationClientLauncher(String aClientName, String aServerHost, String aServerId, String aServerName, HalloweenCommandProcessor aCommandProcessor,
			 boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName);
		commandProcessor = aCommandProcessor;
		broadcastData = aBroadcastData;
		RelayerClientControllerFactory.getOrCreateSingleton().setServerHost(aServerHost);
		
		// add in a wait for user here
		String aRealServerHost = RelayerClientControllerFactory.getOrCreateSingleton().getServerHost();
		

		String aFullServerId = aRealServerHost + ":" + aServerId;
		
		RelayerClientControllerFactory.getOrCreateSingleton().setServerId(aFullServerId);
		RelayerClientControllerFactory.getOrCreateSingleton().setRelayerId(aServerId);
		AScatterGatherSelectionManager.setMaxOutstandingWrites(6000);
//		Tracer.setKeywordPrintStatus(ASerializerPool.class, true);
		Tracer.setKeywordPrintStatus(ABeanSerializer.class, true);



		
	}
	

	protected Class registeredSessionServerClass() {
		return AGIPCSimulationServerLauncher.SESSION_SERVER_CLASS;
	}

	
	protected void createUI(InputPort anInputPort) {

		connectCouplers();
	
	}
	
	protected RMISimulationRelayer sessionServerProxy;

	protected  ConnectionListener getConnectionListener (InputPort anInputPort) {
		return new ATracingConnectionListener(anInputPort);
	}
	

	
	protected  void createProxies() {

//		sessionServerProxy = (RMISimulationSessionServer) DirectedRPCProxyGenerator.generateRPCProxy((DuplexRPCClientInputPort) mainPort, registeredSessionServerClass());
		sessionServerProxy = (RMISimulationRelayer)  createProxy (registeredSessionServerClass());
	}	 
	public  void  connectCouplers() {
		connectInCoupler();
		connectOutCoupler();
//		   try {
//
////		launchClient(clientName, commandProcessor, broadcastData);
//			   RMISimulationInCoupler inCoupler = createRMISimulationInCoupler();
//
//				try {
//					
//
//				   
//					sessionServerProxy.join(clientName, inCoupler);
//				   
////					   if (broadcastData) {
////						   new AnRMISimulationOutCoupler(commandProcessor, sessionServerProxy, clientName);
////					   }
//						   
//				   } catch (Exception e) {
//					
//			      e.printStackTrace();
//			    }
//	 
//
//	    } catch (Exception e) {
//	      e.printStackTrace();
//	    }
////		   if (broadcastData) {
////			   new AnRMISimulationOutCoupler(commandProcessor, sessionServerProxy, clientName);
////		   }
//		   connectOutCoupler();
	  
	  }
	protected void connectInCoupler() {
		   RMISimulationInCoupler inCoupler = createRMISimulationInCoupler();
		   try {
				

			   
				sessionServerProxy.join(clientName, inCoupler);
			   
//				   if (broadcastData) {
//					   new AnRMISimulationOutCoupler(commandProcessor, sessionServerProxy, clientName);
//				   }
					   
			   } catch (Exception e) {
				
		      e.printStackTrace();
		    }

		
	}
	protected RMISimulationInCoupler createRMISimulationInCoupler() {
		return  new AnRMISimulationInCoupler(commandProcessor);
	}
	
	protected void connectOutCoupler() {
		  if (broadcastData) {
			   new AnRMISimulationOutCoupler(commandProcessor, sessionServerProxy, clientName,IPCMechanism.GIPC);
		   }
	}
	
//	public  void  launchClient(String aMyName, HalloweenCommandProcessor aCommandProcessor, boolean aBroadcast) {
////		   RMISimulationInCoupler inCoupler = new AnRMISimulationInCoupler(aCommandProcessor);
//		   RMISimulationInCoupler inCoupler = createRMISimulationInCoupler();
//
//		try {
//			
//
//		   
//			sessionServerProxy.join(aMyName, inCoupler);
//		   
//			   if (aBroadcast) {
//				   new AnRMISimulationOutCoupler(aCommandProcessor, sessionServerProxy, aMyName);
//			   }
//				   
//		   } catch (Exception e) {
//			
//	      e.printStackTrace();
//	    }
//	  
//	  }
	
		

}
//END OF FILE
//START OF FILE: src/gipc/simulation/client/alicegipcandrmiandnioclient.java
package gipc.simulation.client;

import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION1_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;
public class AliceGIPCAndRMIAndNIOClient {
	public static void launchAlice(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AGIPCAndRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				SIMULATION1_PREFIX, 
				0, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args),
				ClientArgsProcessor.getGIPCPort(args));
	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/client/bobgipcandrmiandnioclient.java
package gipc.simulation.client;

import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION2_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_2_X_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;
public class BobGIPCAndRMIAndNIOClient {
	public static void launchBob(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AGIPCAndRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				SIMULATION2_PREFIX, 
				SIMULATION_2_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_2_X_OFFSET, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args),
				ClientArgsProcessor.getGIPCPort(args));
	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/client/gipcandrmiandniosimulationclient.java
package gipc.simulation.client;

import rmi.simulation.client.RMIAndNIOSimulationClient;

public interface GIPCAndRMIAndNIOSimulationClient extends RMIAndNIOSimulationClient{

	void initialize(String aServerHost, int aServerPort, String aClientName,
			String aPrefix, int anXOffset, int aYOffset, int aWidth,
			int aHeight, int aCommandWindowXOffset, int aCommandWindowYOffset,
			String anRMIRegistryHost, int anRMIRegistryPort, int aGIPCServerPort);
}
//END OF FILE
//START OF FILE: src/gipc/simulation/client/gipcsimulationclientlauncher.java
package gipc.simulation.client;

public interface GIPCSimulationClientLauncher {
	public static final String CLIENT_NAME =  "Session CLient";


}
//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/alicegipcandrmiandniosimulationlauncher.java
package gipc.simulation.launcher;

import gipc.simulation.client.AliceGIPCAndRMIAndNIOClient;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
public class AliceGIPCAndRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		
		String[] myArgs = {
				"localhost", 
				GIPCAndRMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Alice",
				"true",
				"localhost",
				RMIRegistryLauncher.RMI_PORT,
				GIPCAndRMIAndNIOServerLauncher.GIPC_SERVER_PORT};
		
		AliceGIPCAndRMIAndNIOClient.launchAlice(myArgs);
		
	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/alicesimulationgipcclient.java
package gipc.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationGIPCClient implements AliceUI {

public static void main(String[] args) {
	Tracer.showWarnings(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showInfo(true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/bobgipcandrmiandniosimulationlauncher.java
package gipc.simulation.launcher;

import gipc.simulation.client.BobGIPCAndRMIAndNIOClient;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.client.BobRMIAndNIOClient;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;

@Tags({DistributedTags.CLIENT})
public class BobGIPCAndRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		
		String[] myArgs = {
				"localhost", 
				GIPCAndRMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Bob",
				"true",
				"localhost",
				RMIRegistryLauncher.RMI_PORT,
				GIPCAndRMIAndNIOServerLauncher.GIPC_SERVER_PORT};
		
//		BobGIPCAndRMIAndNIOClient.launchBob(myArgs);
		BobGIPCAndRMIAndNIOClient.launchBob(args);
		
	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/bobsimulationgipcclient.java
package gipc.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationGIPCClient implements BobUI {

//	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);
//	Tracer.showInfo(false);
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showWarnings(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showInfo(true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/cathysimulationgipcclient.java
package gipc.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.simulation.client.AGIPCSimulationClientLauncher;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationGIPCClient implements CathyUI {

//	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);

//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	Tracer.showWarnings(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
	(new AGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop(); 
  }
}

//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/gipcandrmiandnioserverlauncher.java
package gipc.simulation.launcher;

import gipc.simulation.server.AGIPCAndRMIAndNIOSimulationServer;
import rmi.simulation.launcher.RMIAndNIOServerLauncher;
import rmi.simulation.launcher.RMIRegistryLauncher;
import rmi.simulation.registry.ADistributedRMIRegistryStarter;
import rmi.simulation.server.AnRMIAndNIOSimulationServer;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.gipc.GIPCRPCTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
@Tags({DistributedTags.SERVER, DistributedTags.GIPC})
public class GIPCAndRMIAndNIOServerLauncher extends RMIAndNIOServerLauncher{
	public static final String GIPC_SERVER_PORT = "3090";
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		GIPCRPCTraceUtility.setTracing();
		
		String[] myArgs = {NIO_SERVER_PORT, "localhost", RMIRegistryLauncher.RMI_PORT, GIPC_SERVER_PORT };
//		AGIPCAndRMIAndNIOSimulationServer.launch(myArgs);
		AGIPCAndRMIAndNIOSimulationServer.launch(args);
	}

}
//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/interactivedemoerofgipcsimulation.java
package gipc.simulation.launcher;

import gipc.simulation.server.AGIPCSimulationServerLauncher;

public class InteractiveDemoerOfGIPCSimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				AGIPCSimulationServerLauncher.class,
				AliceSimulationGIPCClient.class,
				BobSimulationGIPCClient.class,
				CathySimulationGIPCClient.class
				
		};
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/simulation/launcher/rmiregistrylauncherfromgipc.java
package gipc.simulation.launcher;

import java.rmi.registry.LocateRegistry;
import java.util.Scanner;

import rmi.simulation.launcher.RMIRegistryLauncher;
import rmi.simulation.registry.ADistributedRMIRegistryStarter;
import util.annotations.Tags;
import util.tags.DistributedTags;
import assignments.util.mainArgs.ServerArgsProcessor;

@Tags({DistributedTags.REGISTRY})
public class RMIRegistryLauncherFromGIPC {
	public static void main (String[] args) {
		RMIRegistryLauncher.main(args);
	}
	
}
//END OF FILE
//START OF FILE: src/gipc/simulation/server/agipcandrmiandniosimulationserver.java
package gipc.simulation.server;

import inputport.rpc.GIPCLocateRegistry;
import inputport.rpc.GIPCRegistry;

import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import assignments.util.mainArgs.ServerArgsProcessor;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationRelayer;
import rmi.simulation.server.AnRMIAndNIOSimulationServer;
import rmi.simulation.server.AnRMISimulationRelayer;
import rmi.simulation.server.RMIAndNIOSimulationServer;
import rmi.simulation.server.twophase.ATwoPhaseRMIAndNIOSimulationServer;
import util.annotations.Tags;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.tags.DistributedTags;
@Tags({DistributedTags.SERVER, DistributedTags.RMI, DistributedTags.GIPC, DistributedTags.NIO})

public class AGIPCAndRMIAndNIOSimulationServer extends ATwoPhaseRMIAndNIOSimulationServer 
	implements GIPCAndRMIAndNIOSimulationServer{
	@Override
	public void initialize(int aServerPort, String aRegistryHost,
			int aRegistryPort, int aGIPCPort) {
		super.initialize(aServerPort, aRegistryHost, aRegistryPort);
		TwoPhaseRMISimulationRelayer aRelayer = createRMIRelayer();
		GIPCRegistry gipcRegistry = GIPCLocateRegistry
				.createRegistry(aGIPCPort);
		gipcRegistry.rebind(SESSION_SERVER, aRelayer);
	}
	public static void launch(String[] args) {
		args = ServerArgsProcessor.removeEmpty(args);
		GIPCAndRMIAndNIOSimulationServer aServer = 
				new AGIPCAndRMIAndNIOSimulationServer();
		nioManagerSimulationServer = aServer;
		aServer.initialize(
				ServerArgsProcessor.getServerPort(args),
				ServerArgsProcessor.getRegistryHost(args),
				ServerArgsProcessor.getRegistryPort(args),
				ServerArgsProcessor.getGIPCServerPort(args));
		SimulationParametersControllerFactory.getSingleton().processCommands();
	}
	

}
//END OF FILE
//START OF FILE: src/gipc/simulation/server/agipcsimulationserverlauncher.java
package gipc.simulation.server;

import common.controller.ServerControllerUI;
import inputport.ConnectionListener;
import inputport.InputPort;
import inputport.rpc.duplex.AnAbstractDuplexRPCServerPortLauncher;
import inputport.rpc.duplex.DuplexRPCServerInputPort;
import port.ATracingConnectionListener;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.server.AnRMISimulationRelayer;
import util.trace.Tracer;



public class AGIPCSimulationServerLauncher extends AnAbstractDuplexRPCServerPortLauncher implements GIPCSimulationServerLauncher   {
	public AGIPCSimulationServerLauncher(String aServerName,
			String aServerPort) {
		super (aServerName, aServerPort);
	}
	public AGIPCSimulationServerLauncher() {
	}

	protected RMISimulationRelayer getSessionServer() {
		return new AnRMISimulationRelayer();
	}
	
	protected  ConnectionListener getConnectionListener (InputPort anInputPort) {
		return new ATracingConnectionListener(anInputPort);
	}

	protected void registerRemoteObjects() {
		DuplexRPCServerInputPort anRPCServerInputPort = (DuplexRPCServerInputPort) mainPort;
		RMISimulationRelayer sessionServer = getSessionServer();
		anRPCServerInputPort.register(sessionServer);
	}
	
	public static void main (String[] args) {
		Tracer.showWarnings(false);
		ServerControllerUI.createUI();
		Tracer.showInfo(true);


		(new AGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}	
}
//END OF FILE
//START OF FILE: src/gipc/simulation/server/gipcandrmiandniosimulationserver.java
package gipc.simulation.server;

import rmi.simulation.server.RMIAndNIOSimulationServer;

public interface GIPCAndRMIAndNIOSimulationServer extends RMIAndNIOSimulationServer{
	void initialize(int aServerPort, String aRegistryHost, int aRegistryPort, int aGIPCPort);


}
//END OF FILE
//START OF FILE: src/gipc/simulation/server/gipcsimulationserverlauncher.java
package gipc.simulation.server;

import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.server.AnRMISimulationRelayer;

public interface GIPCSimulationServerLauncher extends RMISimulationServerLauncher{
//	public static String SESSION_SERVER = "session server";
	public static final Class SESSION_SERVER_CLASS =  AnRMISimulationRelayer.class;
	public static final String SESSION_SERVER_ID = "9190";


}
//END OF FILE
//START OF FILE: src/gipc/socket/client/asocketgipcsimulationclientlauncher.java
package gipc.socket.client;


import gipc.simulation.client.AGIPCSimulationClientLauncher;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.buffer.socket.ASocketDuplexBufferInputPortFactory;
import stringProcessors.HalloweenCommandProcessor;





public class ASocketGIPCSimulationClientLauncher extends AGIPCSimulationClientLauncher  {	

	public ASocketGIPCSimulationClientLauncher(String aClientName, String aServerHost, String aServerId, String aServerName, HalloweenCommandProcessor aCommandProcessor,
			 boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName, aCommandProcessor, aBroadcastData);
		
	}
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
		DuplexBufferInputPortSelector.setDuplexBufferInputPortFactory(new ASocketDuplexBufferInputPortFactory());
	}		

}
//END OF FILE
//START OF FILE: src/gipc/socket/launcher/alicesimulationsocketgipcclient.java
package gipc.socket.launcher;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.AliceUI;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import gipc.socket.client.ASocketGIPCSimulationClientLauncher;

//import niotut.RspHandler;

import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.misc.AClearanceManager;
import util.misc.ClearanceManager;
import util.trace.Tracer;



public class AliceSimulationSocketGIPCClient implements AliceUI {

	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);

	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
	(new ASocketGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
//	new AGIPCSimulationClientLauncher( NAME, GIPCSimulationServerLauncher.SESSION_SERVER_ID,, aCommandProcessor, true);
	ClearanceManager clearanceManager = new AClearanceManager();
	OEFrame oeFrame = ObjectEditor.edit(clearanceManager);
	oeFrame.setLocation(700, 500);

	clearanceManager.waitForClearance();
	long startTime = System.currentTimeMillis();
//	System.out.println("start time" + System.currentTimeMillis());
//	aCommandProcessor.processCommand("move 50 -50");
//	System.out.println("end time after one command" + System.currentTimeMillis());
	for (int i=0; i < 250; i++) {
//		aCommandProcessor.processCommand("move 1 -1");
		aCommandProcessor.setInputString("move 1 0");


	}
	for (int i=0; i < 250; i++) {
//		aCommandProcessor.processCommand("move 1 -1");
		aCommandProcessor.setInputString("move 0 -1");


	}
	long endTime = System.currentTimeMillis();

	System.out.println("Loop execution time:" + (endTime - startTime));


	

//	TrickOrTreatNioClient.launchClient( SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	commandProcessor = BeauAndersonFinalProject.createSimulation(
////			"SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	
//    try {
////    	String currentDir = System.getProperty("user.dir");
////        System.out.println("Current dir using System:" +currentDir);
//    	
//      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//      Thread t = new Thread(client);
//      t.setDaemon(true);
//      t.start();
//      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//      client.createUI(aCommandProcessor);
////      client.initiateConnection();
////      RspHandler handler = new RspHandler();
////      client.send("Hello World".getBytes(), handler);
////      handler.waitForResponse();
//    } catch (Exception e) {
//      e.printStackTrace();
//    }
//  
  }
}

//END OF FILE
//START OF FILE: src/gipc/socket/launcher/bobsimulationsocketgipcclient.java
package gipc.socket.launcher;

import common.ui.BobUI;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import gipc.socket.client.ASocketGIPCSimulationClientLauncher;

//import niotut.RspHandler;

import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationSocketGIPCClient implements BobUI {

	public static final String SIMULATION2_PREFIX = "2:";

public static void main(String[] args) {
	Tracer.showWarnings(false);

	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
	(new ASocketGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();


  }
}

//END OF FILE
//START OF FILE: src/gipc/socket/launcher/interactivedemoerofsocketgipcsimulation.java
package gipc.socket.launcher;

import gipc.socket.server.ASocketGIPCSimulationServerLauncher;

public class InteractiveDemoerOfSocketGIPCSimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				ASocketGIPCSimulationServerLauncher.class,
				AliceSimulationSocketGIPCClient.class

				
		};
//		MainClassLaunchingUtility.interactiveLaunch(classes);
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/socket/server/asocketgipcsimulationserverlauncher.java
package gipc.socket.server;

import gipc.simulation.server.AGIPCSimulationServerLauncher;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.buffer.socket.ASocketDuplexBufferInputPortFactory;



public class ASocketGIPCSimulationServerLauncher extends AGIPCSimulationServerLauncher   {
	public ASocketGIPCSimulationServerLauncher(String aServerName,
			String aServerPort) {
		super (aServerName, aServerPort);
	}
	

	public static void main (String[] args) {
		(new ASocketGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}	
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
		DuplexBufferInputPortSelector.setDuplexBufferInputPortFactory(new ASocketDuplexBufferInputPortFactory());
	}

}
//END OF FILE
//START OF FILE: src/gipc/syncreceive/echoer/anobjectduplexsyncreceiveclientinputportlauncher.java
package gipc.syncreceive.echoer;



import java.util.Scanner;

import inputport.InputPort;
import inputport.datacomm.duplex.object.AnAbstractDuplexObjectClientPortLauncher;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexObjectInputPortWithSyncReceiveSelector;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import port.PortAccessKind;
import util.trace.Tracer;



public class AnObjectDuplexSyncReceiveClientInputPortLauncher extends AnAbstractDuplexObjectClientPortLauncher{
	
	public AnObjectDuplexSyncReceiveClientInputPortLauncher(String aClientName, String aServerHost, String aServerId, String aServerName) {
		super(aClientName, aServerHost, aServerId, aServerName);		
	}
	
	@Override
	public  InputPort getObjectClientInputPort(PortAccessKind aPortAccessKind) {
		Tracer.showInfo(true);
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive(serverHost,serverId, serverName, clientName);
//		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive(hostName, "9090", "test server", "test client");



	}
	
	DuplexClientInputPortWithSyncReceive<Object> myPort() {
		return (DuplexClientInputPortWithSyncReceive<Object>) mainPort;
	}
//	@Override
//	protected void initPortLaucherSupports() {
//		super.initPortLaucherSupports();
//		DuplexObjectInputPortSelector.setDuplexInputPortFactory(new AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory());
//	}	
	
	protected void createUI(InputPort anInputPort){
		String stringMessage = "hello server";

		Scanner in = new Scanner(System.in);	
		while (true) {
			myPort().send(stringMessage);
			ReceiveReturnMessage<Object> received = myPort().receive();
			System.out.println("Sync Received message: " + received + " from "  + received.getSource());
		    stringMessage  = in.nextLine();
			System.out.println("sending read input:" + stringMessage);
//		    message =  ByteBuffer.wrap(stringMessage.getBytes());	
		}
		
	}
	
	public static void main (String[] args) {
		(new AnObjectDuplexSyncReceiveClientInputPortLauncher("test client", "localhost", "9090", "test server")).launch();
	}

	
//	public static void main (String[] args) {
//		Tracer.showInfo(true);
//		DuplexClientInputPortWithSyncReceive<Object> clientInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive("localhost", "9090", "test server", "test client");
//
//		PrintingTypedReceiveListener echoingConnectionListener = new PrintingTypedReceiveListener(clientInputPort);
//		clientInputPort.addConnectionListener(echoingConnectionListener);
//		clientInputPort.addReceiveListener(echoingConnectionListener);
//		clientInputPort.connect();
//		String stringMessage = "hello server";
//
//		Scanner in = new Scanner(System.in);	
//		while (true) {
//			clientInputPort.send(stringMessage);
//			MessageWithSourceSyncRcv<Object> received = clientInputPort.receive();
//			System.out.println("Sync Received message: " + received + " from "  + received.getSource());
//		    stringMessage  = in.nextLine();
//			System.out.println("sending read input:" + stringMessage);
////		    message =  ByteBuffer.wrap(stringMessage.getBytes());	
//		}
//	}
	

}
//END OF FILE
//START OF FILE: src/gipc/syncreceive/echoer/anobjectduplexsyncreceiveserverinputportlauncher.java
package gipc.syncreceive.echoer;

import inputport.InputPort;
import inputport.ServerInputPort;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.echoer.example.AnAbstractDuplexObjectServerPortLauncher;
import inputport.datacomm.duplex.object.explicitreceive.DuplexObjectInputPortWithSyncReceiveSelector;
import port.PortAccessKind;
import port.old.PrintingReplyingObjectReceiver;
import util.trace.Tracer;



public class AnObjectDuplexSyncReceiveServerInputPortLauncher extends AnAbstractDuplexObjectServerPortLauncher {
	
	public AnObjectDuplexSyncReceiveServerInputPortLauncher(String aServerName,
			String aServerPort) {
		super (aServerName, aServerPort);
	}
	@Override
	public  ServerInputPort getObjectServerInputPort(PortAccessKind aPortAccessKind) {
		Tracer.showInfo(true);
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive(serverId, serverName);


	}
	
	
//	protected void createUI(InputPort anInputPort){
//		String stringMessage = "hello server";
//
//		Scanner in = new Scanner(System.in);	
//		while (true) {
//			myPort().send(stringMessage);
//			MessageWithSourceSyncRcv<Object> received = myPort().receive();
//			System.out.println("Sync Received message: " + received + " from "  + received.getSource());
//		    stringMessage  = in.nextLine();
//			System.out.println("sending read input:" + stringMessage);
////		    message =  ByteBuffer.wrap(stringMessage.getBytes());	
//		}
//		
//	}
	@Override
	protected  ReceiveListener getReceiveListener (InputPort anInputPort) {
		return new PrintingReplyingObjectReceiver((DuplexServerInputPort<Object>) anInputPort);
	}
	
//	@Override
//	protected  ConnectionListener getConnectionListener (InputPort anInputPort) {
//		return new PrintingReplyingObjectReceiver((DuplexServerInputPort<Object>) anInputPort);
//	}
	
//	public static void main (String[] args) {
//		Tracer.showInfo(true);
//		DuplexServerInputPort serverInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive("9090", "test server");
//		PrintingReplyingObjectReceiver echoingReceiveListener = new PrintingReplyingObjectReceiver(serverInputPort);
//		serverInputPort.addConnectionListener(echoingReceiveListener);
//		serverInputPort.addReceiveListener(echoingReceiveListener);	
//		serverInputPort.connect();
//	}
	
	public static void main (String[] args) {
		Tracer.showInfo(true);
		(new AnObjectDuplexSyncReceiveServerInputPortLauncher("test serverr", "9090")).launch();
//		DuplexServerInputPort serverInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive("9090", "test server");
//		PrintingReplyingObjectReceiver echoingReceiveListener = new PrintingReplyingObjectReceiver(serverInputPort);
//		serverInputPort.addConnectionListener(echoingReceiveListener);
//		serverInputPort.addReceiveListener(echoingReceiveListener);	
//		serverInputPort.connect();
	}

}
//END OF FILE
//START OF FILE: src/gipc/syncrpc/client/asyncrpcgipcsimulationclientlauncher.java
package gipc.syncrpc.client;


import gipc.customserializer.client.ACustomSerializerGIPCSimulationClientLauncher;
import inputport.rpc.duplex.DuplexRPCInputPortSelector;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;
import inputport.rpc.duplex.SynchronousDuplexReceivedCallInvokerSelector;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingDuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingSyncReceiveSentCallCompleterCallFactory;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;





public class ASyncRPCGIPCSimulationClientLauncher extends ACustomSerializerGIPCSimulationClientLauncher  {	

	public ASyncRPCGIPCSimulationClientLauncher(String aClientName, String aServerHost, String aServerId, String aServerName, HalloweenCommandProcessor aCommandProcessor,
			 boolean aBroadcastData) {
		super(aClientName, aServerHost, aServerId, aServerName, aCommandProcessor, aBroadcastData);
		
	}
	
	
	
	@Override
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
		Tracer.showInfo(true);
//		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, false);
		Tracer.setKeywordPrintStatus(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
//		Tracer.setKeywordPrintStatus(ACustomSerializer.class, true);
//		(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
//		Tracer.showInfo(true);
//		SerializerSelector.setSerializerFactory(new ACustomSerializerFactory());

		DuplexRPCInputPortSelector.setInputPortFactory(new AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory());
		
		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
		SynchronousDuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(new AProcedureSyncingDuplexReceivedCallInvokerFactory());

		
	}

	
//	public  InputPort getRPCClientInputPort(PortAccessKind aPortAccessKind) {
//		Tracer.showInfo(true);
//
//		return DuplexRPCInputPortWithSyncReceiveSelector.createDuplexRPCClientInputPortWithSyncReceive(serverHost, serverId, serverName, clientName);
//	}
}
//END OF FILE
//START OF FILE: src/gipc/syncrpc/launcher/alicesimulationsyncrpcgipcclient.java
package gipc.syncrpc.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import gipc.syncrpc.client.ASyncRPCGIPCSimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationSyncRPCGIPCClient implements AliceUI {

	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//	
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
////	new AGIPCSimulationClientLauncher( NAME, GIPCSimulationServerLauncher.SESSION_SERVER_ID,, aCommandProcessor, true);
//	ClearanceManager clearanceManager = new AClearanceManager();
//	OEFrame oeFrame = ObjectEditor.edit(clearanceManager);
//	oeFrame.setLocation(700, 500);
//
//	clearanceManager.waitForClearance();
//	long startTime = System.currentTimeMillis();
//
//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 1 0");
//
//
//	}
//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 0 -1");
//
//
//	}
//	long endTime = System.currentTimeMillis();
//
//	System.out.println("Loop execution time:" + (endTime - startTime));
//
//
//	
//
//  
//  }
public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
  }
}

//END OF FILE
//START OF FILE: src/gipc/syncrpc/launcher/bobsimulationsyncrpcgipcclient.java
package gipc.syncrpc.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import gipc.syncrpc.client.ASyncRPCGIPCSimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationSyncRPCGIPCClient implements BobUI {

	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
//
//
//  }
	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		OEFrame oeFrame = BobControllerUI.createUI();
		HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
		(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
	  }
}

//END OF FILE
//START OF FILE: src/gipc/syncrpc/launcher/cathysimulationsyncrpcgipcclient.java
package gipc.syncrpc.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import gipc.simulation.server.GIPCSimulationServerLauncher;
import gipc.syncrpc.client.ASyncRPCGIPCSimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationSyncRPCGIPCClient implements CathyUI {

	public static final String SIMULATION2_PREFIX = "2:";

//public static void main(String[] args) {
//	Tracer.showWarnings(false);
//
//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
//
//
//  }
	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		OEFrame oeFrame = CathyControllerUI.createUI();
		HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();
		(new ASyncRPCGIPCSimulationClientLauncher(NAME, "localhost", GIPCSimulationServerLauncher.SESSION_SERVER_ID, GIPCSimulationServerLauncher.SESSION_SERVER, aCommandProcessor, true )).launch();
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();  
	  }
}

//END OF FILE
//START OF FILE: src/gipc/syncrpc/launcher/interactivedemoerofsyncrpcgipcsimulation.java
package gipc.syncrpc.launcher;

public class InteractiveDemoerOfSyncRPCGIPCSimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				SimulationSyncRPCGIPCServerMain.class,
				AliceSimulationSyncRPCGIPCClient.class,
				BobSimulationSyncRPCGIPCClient.class,
				CathySimulationSyncRPCGIPCClient.class				
		};
//		MainClassLaunchingUtility.interactiveLaunch(classes);
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/gipc/syncrpc/launcher/simulationsyncrpcgipcservermain.java
package gipc.syncrpc.launcher;

import common.controller.ServerControllerUI;
import gipc.simulation.server.AGIPCSimulationServerLauncher;
import gipc.syncrpc.server.ASyncRPCGIPCSimulationServerLauncher;



public class SimulationSyncRPCGIPCServerMain extends AGIPCSimulationServerLauncher   {
	
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		ServerControllerUI.createUI();
		(new ASyncRPCGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}

}
//END OF FILE
//START OF FILE: src/gipc/syncrpc/server/asyncrpcgipcsimulationserverlauncher.java
package gipc.syncrpc.server;

import gipc.customserializer.server.ACustomSerializerGIPCSimulationServerLauncher;
import inputport.rpc.duplex.DuplexRPCInputPortSelector;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;
import inputport.rpc.duplex.SynchronousDuplexReceivedCallInvokerSelector;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingDuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingSyncReceiveSentCallCompleterCallFactory;
import util.trace.ImplicitKeywordKind;
import util.trace.Tracer;



public class ASyncRPCGIPCSimulationServerLauncher extends ACustomSerializerGIPCSimulationServerLauncher   {
	public ASyncRPCGIPCSimulationServerLauncher(String aServerName,
			String aServerId) {
		super (aServerName, aServerId);
	}	
	@Override
	protected void initPortLaucherSupports() {
		super.initPortLaucherSupports();
//		Tracer.showInfo(true);
		Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, false);
		Tracer.setImplicitDisplayKeywordKind(ImplicitKeywordKind.OBJECT_PACKAGE_NAME);
		Tracer.setKeywordPrintStatus(AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory.class, true);
//		Tracer.setKeywordPrintStatus(ACustomSerializer.class, true);
//		SerializerSelector.setSerializerFactory(new ACustomSerializerFactory());
		DuplexRPCInputPortSelector.setInputPortFactory(new AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory());
		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
		SynchronousDuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(new AProcedureSyncingDuplexReceivedCallInvokerFactory());
		
	}
		
//	public  InputPort getRPCServerInputPort(PortAccessKind aPortAccessKind) {
//		
//		return DuplexRPCInputPortWithSyncReceiveSelector.createDuplexRPCServerInputPortWithSyncReceive(serverId, serverName);
//	}
	public static void main (String[] args) {
//		Tracer.showInfo(true);
		(new ASyncRPCGIPCSimulationServerLauncher(SESSION_SERVER, SESSION_SERVER_ID)).launch();
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/socket/asocketduplexbufferinputportfactory.java
package inputport.datacomm.duplex.buffer.socket;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.buffer.AGenericDuplexBufferClientInputPort;
import inputport.datacomm.duplex.buffer.AGenericDuplexBufferServerInputPort;
import inputport.datacomm.duplex.buffer.DuplexBufferGenericClientInputPort;
import inputport.datacomm.duplex.buffer.DuplexBufferGenericServerInputPort;
import inputport.datacomm.duplex.buffer.DuplexClientInputPortDriver;
import inputport.datacomm.duplex.buffer.DuplexServerInputPortDriver;
import inputport.nio.manager.factories.SelectionManagerFactory;

import java.net.ServerSocket;
import java.net.Socket;

public class ASocketDuplexBufferInputPortFactory extends SelectionManagerFactory implements DuplexInputPortFactory {

	@Override
	public DuplexServerInputPort createDuplexServerInputPort(String theServerId,
			String theServerName) {
		DuplexBufferGenericServerInputPort<ServerSocket, Socket> skeleton = new AGenericDuplexBufferServerInputPort(theServerName, theServerId);
		DuplexServerInputPortDriver<ServerSocket, Socket> driver = new ASocketDuplexServerInputPortDriver(theServerId);
		skeleton.setDriver(driver);
		driver.setSkeleton(skeleton);
		return skeleton;
	}
	@Override
	public DuplexClientInputPort createDuplexClientInputPort(String theServerHost,
			String theServerId, String aServerName, String theClientName) {
		DuplexBufferGenericClientInputPort skeleton = new AGenericDuplexBufferClientInputPort(theServerHost, theServerId, aServerName, theClientName);
		DuplexClientInputPortDriver implementation = new ASocketDuplexClientInputPortDriver(theServerHost, theServerId, aServerName);
		skeleton.setDriver(implementation);
		implementation.setSkeleton(skeleton);
		return skeleton;
	}
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/socket/asocketduplexclientinputportdriver.java
package inputport.datacomm.duplex.buffer.socket;

import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.buffer.DuplexBufferGenericClientInputPort;
import inputport.datacomm.duplex.buffer.DuplexClientInputPortSkeleton;
import inputport.datacomm.simplex.buffer.socket.ASocketClientInputDriver;
import inputport.datacomm.simplex.buffer.socket.ASocketReadingRunnable;

import java.net.Socket;
import java.nio.ByteBuffer;

import port.old.BufferDuplexClientInputPortLauncher;
import util.misc.StoppableRunnable;



public class ASocketDuplexClientInputPortDriver extends ASocketClientInputDriver implements SocketDuplexClientInputPortDriver{
	DuplexClientInputPortSkeleton<Socket> duplexSkeleton;
	public ASocketDuplexClientInputPortDriver(
			String theRemoteHostName, String theRemotePort, String aServerName) {
		super(theRemoteHostName, theRemotePort, aServerName);		
	}
	@Override
	protected void connected(Socket aSocket) {
		StoppableRunnable socketReadingRunnable = new ASocketReadingRunnable(socket, this, this);
		Thread thread = new Thread(socketReadingRunnable);
		thread.setName("Socket Reading thread for " + aSocket);
		thread.start();
		super.connected(aSocket);
		
	}
	@Override
	public void socketRead(Socket aSocket,
			ByteBuffer theMessage) {
		duplexSkeleton.messageReceived(serverName, theMessage);		
	}

	
	public static void main (String[] args) {
		DuplexInputPortFactory inputPortFactory = new ASocketDuplexBufferInputPortFactory();
		DuplexBufferInputPortSelector.setDuplexBufferInputPortFactory(inputPortFactory);
		BufferDuplexClientInputPortLauncher.launch(args);
//		DuplexClientInputPort clientInputPort = BufferDuplexInputPortSelector.createBufferDuplexClientInputPort("localhost", "9090", "test server", "test client");
//		PrintingReceiveListener echoingConnectionListener = new PrintingReceiveListener();
//		clientInputPort.addConnectListener(echoingConnectionListener);
//		clientInputPort.addReceiveListener(echoingConnectionListener);
//		clientInputPort.connect();
//		ByteBuffer message =  ByteBuffer.wrap("hello server".getBytes());
////		byte[] padding = new byte[10];
////		message.position(message.limit());
////		message.put(padding);
////		message.flip();
//		System.out.println("String with padding:" + new String(message.array()));		
//		clientInputPort.send(message);
	}
//	@Override
//	public void reply(ByteBuffer message) {
////		return send(message);
//		send(message);
//	}
//	@Override
//	public void send(String remoteName, ByteBuffer message) {
//		send(message);
//		
//	}
	@Override
	public void setSkeleton(DuplexBufferGenericClientInputPort<Socket> theSkeleton) {
		super.setSkeleton(theSkeleton);
		duplexSkeleton = theSkeleton;
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/socket/asocketduplexserverinputportdriver.java
package inputport.datacomm.duplex.buffer.socket;

import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.SendToUnkonwnRemoteNameException;
import inputport.datacomm.duplex.buffer.DuplexServerInputPortSkeleton;
import inputport.datacomm.simplex.buffer.socket.ASocketServerInputDriver;
import inputport.nio.manager.AScatterGatherSelectionManager;

import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;

import port.old.PrintingReplyingReceiveListener;
import util.trace.Tracer;


public class ASocketDuplexServerInputPortDriver extends ASocketServerInputDriver 
             implements SocketDuplexServerInputPortDriver {
	DuplexServerInputPortSkeleton<ServerSocket, Socket> duplexSkeleton;
	ByteBuffer headerBuffer = ByteBuffer.allocate(AScatterGatherSelectionManager.BYTES_IN_INT);
	int sendId;

	public ASocketDuplexServerInputPortDriver(String thePortId) {
		super(thePortId);
	}

	@Override
	public synchronized void send(String aDestination, ByteBuffer message) {
		Socket aChannel = duplexSkeleton.getChannel(aDestination);
		if (aChannel == null) throw new SendToUnkonwnRemoteNameException();
		Socket aSocket = aChannel;
		try {
			Tracer.info(this, "Sending messsage: " + message + " to " + aSocket);
			int messageSize = message.limit() - message.position();
			headerBuffer.putInt(messageSize);
			headerBuffer.rewind();
			OutputStream socketOutputStream = aSocket.getOutputStream();
			socketOutputStream.write(headerBuffer.array(), headerBuffer.position(), headerBuffer.limit());
			socketOutputStream.write(message.array(), message.position(), message.limit());
			duplexSkeleton.messageSent(aDestination, message, sendId);
			sendId++;
		} catch (Exception e) {
//			close(aSocket);
			socketClosed(aSocket, e);
			e.printStackTrace();
		}	
		
	}
		

	public static void main (String[] args) {
		DuplexInputPortFactory inputPortFactory = new ASocketDuplexBufferInputPortFactory();
		DuplexServerInputPort serverInputPort = inputPortFactory.createDuplexServerInputPort("9090", "test server");
		PrintingReplyingReceiveListener echoingReceiveListener = new PrintingReplyingReceiveListener(serverInputPort);
		serverInputPort.addConnectionListener(echoingReceiveListener);
		serverInputPort.addReceiveListener(echoingReceiveListener);	
		serverInputPort.connect();
	}

	

	@Override
	public void setSkeleton(DuplexServerInputPortSkeleton theSkeleton) {
		super.setSkeleton(theSkeleton);
		duplexSkeleton = theSkeleton;
		
	}



	

	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/socket/socketduplexclientinputportdriver.java
package inputport.datacomm.duplex.buffer.socket;

import inputport.datacomm.duplex.buffer.DuplexClientInputPortDriver;
import inputport.datacomm.simplex.buffer.socket.SocketClientInputDriver;
import inputport.datacomm.simplex.buffer.socket.SocketReadListener;

import java.net.Socket;


public interface SocketDuplexClientInputPortDriver 
extends  DuplexClientInputPortDriver<Socket>, SocketClientInputDriver, 
SocketReadListener {
//	void setSkeleton(BufferGenericDuplexClientInputPort<Socket> theSkeleton);	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/socket/socketduplexserverinputportdriver.java
package inputport.datacomm.duplex.buffer.socket;

import inputport.datacomm.duplex.buffer.DuplexServerInputPortDriver;
import inputport.datacomm.simplex.buffer.socket.SocketServerInputDriver;

import java.net.ServerSocket;
import java.net.Socket;

public interface SocketDuplexServerInputPortDriver extends SocketServerInputDriver, DuplexServerInputPortDriver<ServerSocket, Socket> {
//	 void send(Socket aSocket, ByteBuffer message);
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/syncrcv/abufferduplexinputportwithsyncreceivefactory.java
package inputport.datacomm.duplex.buffer.syncrcv;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.ADuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;

import java.nio.ByteBuffer;



public class ABufferDuplexInputPortWithSyncReceiveFactory  extends ADuplexInputPortWithSyncReceiveFactory<ByteBuffer> implements DuplexInputPortWithSyncReceiveFactory<ByteBuffer>{

	@Override
	public DuplexServerInputPort<ByteBuffer> createDuplexServerInputPort(
			String theServerId, String theServerName) {
		return DuplexBufferInputPortSelector.createDuplexServerInputPort(theServerId, theServerName);
	}

	@Override
	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
			String theServerId, String serverName, String theClientName) {
		return DuplexBufferInputPortSelector.createDuplexClientInputPort(theHost, theServerId, serverName, theClientName);
	}	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/syncrcv/bufferduplexclientinputportlauncher.java
package inputport.datacomm.duplex.buffer.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;

import java.nio.ByteBuffer;
import java.util.Scanner;

import util.trace.Tracer;
import extraip.APrintingReceiveAndSendListener;

public class BufferDuplexClientInputPortLauncher {
	public static void main (String[] args) {
		Tracer.showInfo(true);
		DuplexClientInputPortWithSyncReceive<ByteBuffer> clientInputPort = BufferDuplexInputPortWithSyncReceiveSelector.createBufferDuplexClientInputPortWithSyncReceive("localhost", "9090", "test server", "test client");
//		PrintingReceiveListener echoingConnectionListener = new PrintingReceiveListener();
//		clientInputPort.addConnectListener(echoingConnectionListener);
//		clientInputPort.addReceiveListener(echoingConnectionListener);
//		clientInputPort.connect();
//		ByteBuffer message =  ByteBuffer.wrap("hello server".getBytes());
//		System.out.println("String with padding:" + new String(message.array()));		
//		clientInputPort.send(message);
		APrintingReceiveAndSendListener echoingConnectionListener = new APrintingReceiveAndSendListener(clientInputPort);
		clientInputPort.addConnectionListener(echoingConnectionListener);
		clientInputPort.addReceiveListener(echoingConnectionListener);
		clientInputPort.connect();
		String stringMessage = "hello server";
		ByteBuffer message = ByteBuffer.wrap(stringMessage.getBytes());
		Scanner in = new Scanner(System.in);	
		while (true) {
			clientInputPort.send(message);
			ReceiveReturnMessage<ByteBuffer> received = clientInputPort.receive();
			System.out.println("Sync Received message: " + new String (received.getMessage().array()) + " from "  + received.getSource());
		    stringMessage  = in.nextLine();
			System.out.println("sending read input:" + stringMessage);
		    message =  ByteBuffer.wrap(stringMessage.getBytes());		
		}
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/syncrcv/bufferduplexinputportwithsyncreceiveselector.java
package inputport.datacomm.duplex.buffer.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;

import java.nio.ByteBuffer;



public class BufferDuplexInputPortWithSyncReceiveSelector  {
//	static DuplexInputPortFactory<ByteBuffer> factory = new AnNIODuplexInputPortFactory();
	static DuplexInputPortWithSyncReceiveFactory<ByteBuffer> factory = new ABufferDuplexInputPortWithSyncReceiveFactory();
	public static void setBufferDuplexInputPortWithSyncReceiveFactory(DuplexInputPortWithSyncReceiveFactory<ByteBuffer> aFactory) {
		factory = aFactory;
	}
	public static DuplexServerInputPortWithSyncReceive<ByteBuffer> createBufferDuplexServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return factory.createDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexClientInputPortWithSyncReceive<ByteBuffer> createBufferDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName){
		return factory.createDuplexClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);
	}
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/buffer/syncrcv/bufferduplexserverinputportlauncher.java
package inputport.datacomm.duplex.buffer.syncrcv;

import inputport.datacomm.duplex.DuplexServerInputPort;
import port.old.PrintingReplyingReceiveListener;
import util.trace.Tracer;



public class BufferDuplexServerInputPortLauncher {
	public static void main (String[] args) {
		Tracer.showInfo(true);
		DuplexServerInputPort serverInputPort = BufferDuplexInputPortWithSyncReceiveSelector.createBufferDuplexServerInputPortWithSyncReceive("9090", "test server");
		PrintingReplyingReceiveListener echoingReceiveListener = new PrintingReplyingReceiveListener(serverInputPort);
		serverInputPort.addConnectionListener(echoingReceiveListener);
		serverInputPort.addReceiveListener(echoingReceiveListener);	
		serverInputPort.connect();
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/ablockingqueuewithblockedthreadcount.java
package inputport.datacomm.duplex.object.explicitreceive;

import java.util.concurrent.LinkedBlockingQueue;


public class ABlockingQueueWithBlockedThreadCount<E> extends LinkedBlockingQueue<E> implements BlockingQueueWithBlockedThreadCount<E> {
	protected int numBlockedThreads;
	@Override
	public synchronized E take() throws InterruptedException {
		numBlockedThreads++;
		E retVal = super.take();
		numBlockedThreads--;
		return retVal;
		
	}	
	/* (non-Javadoc)
	 * @see inputport.datacomm.duplex.object.explicitreceive.BlockingQueueWithBlockedThreadCount#getNumBlockedThreads()
	 */
	@Override
	public int getNumBlockedThreads() {
		return numBlockedThreads;
	}
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/aduplexclientinputportwithsyncreceive.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.ConnectionListener;
import inputport.ConnectionType;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.ReceiveTrapper;
import inputport.datacomm.SendTrapper;
import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;
import inputport.datacomm.simplex.buffer.ByteBufferSendListener;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Set;


public class ADuplexClientInputPortWithSyncReceive<MessageType>  implements 
	DuplexClientInputPortWithSyncReceive<MessageType>, ConnectionListener {
	DuplexClientInputPort<MessageType> duplexClientInputPort;
	ExplicitReceiveListener<MessageType> syncReceiveListener;
//	ReceiveRegistrarAndNotifier<MessageType> receiveRegistrarAndNotifier = new AReceiveRegistrarAndNotifier<MessageType>();
	/**
	 * Do nothing except listen to received messages
	 */
	public ADuplexClientInputPortWithSyncReceive(DuplexClientInputPort<MessageType> aDuplexClientInputPort) {
		duplexClientInputPort = aDuplexClientInputPort;
		duplexClientInputPort.addConnectionListener(this);
//		syncReceiveListener = new ASyncReceiveListener<MessageType>(null);
//		duplexClientInputPort.addReceiveListener(syncReceiveListener);	
	}
	
	/**
	 * Parameterless receive implementation
	 */
	@Override
	public ReceiveReturnMessage<MessageType> receive() {
//		return syncReceiveListener.getReceivedMessage();	
		return receive(getSender());		

	}
	/**
	 * Get message queued by receiving thread
	 */
	@Override
	public ReceiveReturnMessage<MessageType> receive(String clientName) {
		return syncReceiveListener.getReceivedMessage();		
	}
	@Override
	public void connected(String aRemoteEndName, ConnectionType aConnectionType) {
		syncReceiveListener = new ASyncReceiveListener<MessageType>(aRemoteEndName);
		duplexClientInputPort.addReceiveListener(syncReceiveListener);			
	}
	
	/*
	 * Delegation methods below 
	 */
	public void addConnectionListener (ConnectionListener portConnectListener) {
		duplexClientInputPort.addConnectionListener(portConnectListener);
	}
	public void addReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexClientInputPort.addReceiveListener(portReceiveListener);
	}
	public void addSendListener(ByteBufferSendListener portSendListener) {
		duplexClientInputPort.addSendListener(portSendListener);
	}
	public void connect() {
		duplexClientInputPort.connect();
	}
	public void disconnect() {
		duplexClientInputPort.disconnect();
	}
	public String getLocalName() {
		return duplexClientInputPort.getLocalName();
	}
	public String getLogicalRemoteEndPoint() {
		return duplexClientInputPort.getLogicalRemoteEndPoint();
	}
	public void notifyConnect(String remoteEnd, ConnectionType aConnectionType) {
		duplexClientInputPort.notifyConnect(remoteEnd, aConnectionType);
	}
	public void notifyConnectFailure(String remoteEnd, String message, ConnectionType aConnectionType) {
		duplexClientInputPort.notifyConnectFailure(remoteEnd, message, null);
	}
	public void notifyDisconnect(String remoteEnd, boolean eof,
			String closeReason, ConnectionType aConnectionType) {
		duplexClientInputPort.notifyDisconnect(remoteEnd, eof, closeReason, null);
	}
	public void notifyPortReceive(String remoteEnd, MessageType message) {
		duplexClientInputPort.notifyPortReceive(remoteEnd, message);
	}
	public void notifyPortSend(String aRemoteEnd, ByteBuffer message, int sendId) {
		duplexClientInputPort.notifyPortSend(aRemoteEnd, message, sendId);
	}
	public void removeConnectionListener(ConnectionListener portConnectListener) {
		duplexClientInputPort.removeConnectionListener(portConnectListener);
	}
	public void removeReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexClientInputPort.removeReceiveListener(portReceiveListener);
	}
	public void removeSendListener(ByteBufferSendListener portSendListener) {
		duplexClientInputPort.removeSendListener(portSendListener);
	}
	public void reply(MessageType message) {
		duplexClientInputPort.reply(message);
	}
	public void send(MessageType message) {
		duplexClientInputPort.send(message);
	}
	public void send(String remoteName, MessageType message) {
		duplexClientInputPort.send(remoteName, message);
	}
	@Override
	public void reply(String aRemoteEnd, MessageType aMessage) {
		send(aRemoteEnd, aMessage);
	}


	@Override
	public SendTrapper<MessageType, MessageType> getSendTrapper() {
		return duplexClientInputPort.getSendTrapper();
	}


	@Override
	public void setSendTrapper(SendTrapper<MessageType, MessageType> newVal) {
		duplexClientInputPort.setSendTrapper(newVal);
	}


	@Override
	public ReceiveTrapper<MessageType, MessageType> getReceiveTrapper() {
		return duplexClientInputPort.getReceiveTrapper();
	}


	@Override
	public void setReceiveTrapper(
			ReceiveTrapper<MessageType, MessageType> newVal) {
		duplexClientInputPort.setReceiveTrapper(newVal);
	}


	@Override
	public Set<String> getConnections() {
		return duplexClientInputPort.getConnections();
	}


	@Override
	public String getSender() {
		return duplexClientInputPort.getSender();
	}


	@Override
	public void setSender(String newVal) {
		duplexClientInputPort.setSender(newVal);

	}


	@Override
	public String getPhysicalRemoteEndPoint() {
		return duplexClientInputPort.getPhysicalRemoteEndPoint();
	}


	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		duplexClientInputPort.setPhysicalRemoteEndPoint(newVal);
		
	}


	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		duplexClientInputPort.setLogicalRemoteEndPoint(newVal);

		
	}
	@Override
	public boolean isConnected(String remoteName) {
		// TODO Auto-generated method stub
		return duplexClientInputPort.isConnected(remoteName);
	}


	@Override
	public List<ReceiveListener<MessageType>> getReceiveListeners() {
		// TODO Auto-generated method stub
		return duplexClientInputPort.getReceiveListeners();
	}

	

	@Override
	public void notConnected(String aRemoteEndName, String anExplanation,
			ConnectionType aConnectionType) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void disconnected(String aRemoteEndName,
			boolean anExplicitDsconnection, String anExplanation,
			ConnectionType aConnectionType) {
		// TODO Auto-generated method stub
		
	}

	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/aduplexinputportwithsyncreceivefactory.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;

public  abstract class ADuplexInputPortWithSyncReceiveFactory<MessageType> implements 
DuplexInputPortWithSyncReceiveFactory<MessageType>, DuplexInputPortFactory<MessageType> {
	
	
	
	@Override
	public DuplexClientInputPortWithSyncReceive<MessageType> createDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName) {
		DuplexClientInputPort<MessageType>  duplexClientInputPort = createDuplexClientInputPort(theHost, theServerId, aServerName, theClientName);
		return new ADuplexClientInputPortWithSyncReceive<MessageType>(duplexClientInputPort);
		
	}
	
	@Override
	public DuplexServerInputPortWithSyncReceive<MessageType> createDuplexServerInputPortWithSyncReceive(String aServerId, String aServerName) {
		DuplexServerInputPort<MessageType>  duplexServerInputPort = createDuplexServerInputPort(aServerId, aServerName);
		return new ADuplexServerInputPortWithSyncReceive<MessageType>(duplexServerInputPort);
		
	}

//	@Override
//	public DuplexServerInputPort<MessageType> createDuplexServerInputPort(
//			String theServerId, String theServerName) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
//			String theServerId, String serverName, String theClientName) {
//		// TODO Auto-generated method stub
//		return null;
//	}


	
	
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/aduplexobjectinputportwithsyncreceivefactory.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;



public class ADuplexObjectInputPortWithSyncReceiveFactory  extends ADuplexInputPortWithSyncReceiveFactory<Object> implements DuplexInputPortWithSyncReceiveFactory<Object>{

	@Override
	public DuplexServerInputPort<Object> createDuplexServerInputPort(
			String theServerId, String theServerName) {
		return DuplexObjectInputPortSelector.createDuplexServerInputPort(theServerId, theServerName);
	}

	@Override
	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
			String theServerId, String serverName, String theClientName) {
		return DuplexObjectInputPortSelector.createDuplexClientInputPort(theHost, theServerId, serverName, theClientName);
	}	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/aduplexserverinputportwithsyncreceive.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.ConnectionListener;
import inputport.ConnectionType;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.ReceiveTrapper;
import inputport.datacomm.SendTrapper;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;
import inputport.datacomm.simplex.buffer.ByteBufferSendListener;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ADuplexServerInputPortWithSyncReceive<MessageType>  implements 
	DuplexServerInputPortWithSyncReceive<MessageType>, ConnectionListener {
	DuplexServerInputPort<MessageType> duplexServerInputPort;
	Map<String, ExplicitReceiveListener<MessageType>> nameToSyncReceiveListener = new HashMap();
	/**
	 * Same as in client, attach a receive listener
	 */
	public ADuplexServerInputPortWithSyncReceive(DuplexServerInputPort<MessageType> aDuplexServerInputPort) {
		duplexServerInputPort = aDuplexServerInputPort;
		duplexServerInputPort.addConnectionListener(this);
	
	}
//	/**
//	 * Factory method	 
//	 */
//	protected ExplicitReceiveListener<MessageType>  createSyncReceiveListener() {
//		return new ASyncReceiveListener();
//	}
//	protected SyncReceiveListener<MessageType> getAndMaybeCreateSyncReceiveListener(String clientName) {
//		SyncReceiveListener<MessageType> syncReceiveListener = nameToSyncReceiveListener.get(clientName);
//		if (syncReceiveListener == null) {
//			syncReceiveListener = createSyncReceiveListener();
//			nameToSyncReceiveListener.put(clientName, syncReceiveListener);
//			duplexServerInputPort.addReceiveListener(syncReceiveListener);	
//		}
//		return syncReceiveListener;
//	}
	protected ExplicitReceiveListener<MessageType> getSyncReceiveListener(String clientName) {
		return  nameToSyncReceiveListener.get(clientName);
		
	}
	/*
	 * Add a separate listener for each client, to be queried by sending thread
	 */
	protected ExplicitReceiveListener<MessageType> createSyncReceiveListener(String clientName) {

		ExplicitReceiveListener<MessageType> syncReceiveListener = new ASyncReceiveListener(clientName);
			nameToSyncReceiveListener.put(clientName, syncReceiveListener);
			duplexServerInputPort.addReceiveListener(syncReceiveListener);	
//		}
		return syncReceiveListener;
	}

	@Override
	public ReceiveReturnMessage<MessageType> receive() {
		return receive(getSender());		
	}
	/**
	 * Get the message from the appropriate receive listener
	 */
	@Override
	public ReceiveReturnMessage<MessageType> receive(String aSource) {
		return getSyncReceiveListener(aSource).getReceivedMessage();		
	}
	public void addConnectionListener (ConnectionListener portConnectListener) {
		duplexServerInputPort.addConnectionListener(portConnectListener);
	}
	public void addReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexServerInputPort.addReceiveListener(portReceiveListener);
	}
	public void addSendListener(ByteBufferSendListener portSendListener) {
		duplexServerInputPort.addSendListener(portSendListener);
	}
	public void connect() {
		duplexServerInputPort.connect();
	}
	public void disconnect() {
		duplexServerInputPort.disconnect();
	}
	public String getLocalName() {
		return duplexServerInputPort.getLocalName();
	}
	
	public void notifyConnect(String remoteEnd, ConnectionType aConnectionType) {
		duplexServerInputPort.notifyConnect(remoteEnd, aConnectionType);
	}
	public void notifyConnectFailure(String remoteEnd, String message, ConnectionType aConnectionType) {
		duplexServerInputPort.notifyConnectFailure(remoteEnd, message, null);
	}
	public void notifyDisconnect(String remoteEnd, boolean eof,
			String closeReason, ConnectionType aConnectionType) {
		duplexServerInputPort.notifyDisconnect(remoteEnd, eof, closeReason, null);
	}
	public void notifyPortReceive(String remoteEnd, MessageType message) {
		duplexServerInputPort.notifyPortReceive(remoteEnd, message);
	}
	public void notifyPortSend(String aRemoteEnd, ByteBuffer message, int sendId) {
		duplexServerInputPort.notifyPortSend(aRemoteEnd, message, sendId);
	}
	public void removeConnectionListener(ConnectionListener portConnectListener) {
		duplexServerInputPort.removeConnectionListener(portConnectListener);
	}
	public void removeReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexServerInputPort.removeReceiveListener(portReceiveListener);
	}
	public void removeSendListener(ByteBufferSendListener portSendListener) {
		duplexServerInputPort.removeSendListener(portSendListener);
	}
	public void reply(MessageType message) {
		duplexServerInputPort.reply(message);
	}
	public void send(MessageType message) {
		duplexServerInputPort.send(message);
	}
	@Override
	public void reply(String aRemoteEnd, MessageType aMessage) {
		send(aRemoteEnd, aMessage);
	}
	public void send(String remoteName, MessageType message) {
		duplexServerInputPort.send(remoteName, message);
	}


	@Override
	public String getSender() {
		return duplexServerInputPort.getSender();
	}


	@Override
	public Set<String> getConnections() {
		return duplexServerInputPort.getConnections();
	}


	@Override
	public void setSender(String newVal) {
		duplexServerInputPort.setSender(newVal);
	}
	@Override
	public String getServerId() {
		return duplexServerInputPort.getServerId();
	}
	@Override
	public ReceiveTrapper<MessageType, MessageType> getReceiveTrapper() {
		return duplexServerInputPort.getReceiveTrapper();
	}
	@Override
	public void setReceiveTrapper(
			ReceiveTrapper<MessageType, MessageType> newVal) {
		duplexServerInputPort.setReceiveTrapper(newVal);
	}
	@Override
	public SendTrapper<MessageType, MessageType> getSendTrapper() {
		return duplexServerInputPort.getSendTrapper();
	}
	@Override
	public void setSendTrapper(SendTrapper<MessageType, MessageType> newVal) {
		duplexServerInputPort.setSendTrapper(newVal);
	}
	@Override
	public void connected(String aRemoteEndName, ConnectionType aConnectionType) {
		createSyncReceiveListener(aRemoteEndName);
		
	}
	@Override
	public void notConnected(String aRemoteEndName, String anExplanation, ConnectionType aConnectionType) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void disconnected(String aRemoteEndName,
			boolean anExplicitDsconnection, String anExplanation, ConnectionType aConnectionType) {
		// TODO Auto-generated method stub
		
	}
	
	@Override
	public boolean isConnected(String remoteName) {
		// TODO Auto-generated method stub
		return duplexServerInputPort.isConnected(remoteName);
	}
	@Override
	public List<ReceiveListener<MessageType>> getReceiveListeners() {
		return duplexServerInputPort.getReceiveListeners();
	}
	@Override
	public String getLogicalRemoteEndPoint() {
		return duplexServerInputPort.getLogicalRemoteEndPoint();
	}
	@Override
	public String getPhysicalRemoteEndPoint() {
		return duplexServerInputPort.getPhysicalRemoteEndPoint();
	}
	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		duplexServerInputPort.setLogicalRemoteEndPoint(newVal);
	}
	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		duplexServerInputPort.setPhysicalRemoteEndPoint(newVal);
	}

	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/asyncreceivelistener.java
package inputport.datacomm.duplex.object.explicitreceive;


import inputport.datacomm.duplex.object.explicitreceive.AReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import util.trace.Tracer;
import util.trace.port.objects.ReceivedMessageDequeued;
import util.trace.port.objects.ReceivedMessageQueueCreated;
import util.trace.port.objects.ReceivedMessageQueued;

/**
 * This should really tke client name as an argument and receive messages
 * from it only
 * 
 */

public class ASyncReceiveListener<MessageType> implements ExplicitReceiveListener<MessageType> {
	BlockingQueueWithBlockedThreadCount<ReceiveReturnMessage<MessageType>> receivedValueQueue = new ABlockingQueueWithBlockedThreadCount<>();
	String remoteEnd;	
	public ASyncReceiveListener(String aRemoteEnd) {
		ReceivedMessageQueueCreated.newCase(this, receivedValueQueue);
		remoteEnd = aRemoteEnd;
		
	}
	public boolean hasBlockedThread() {
		return receivedValueQueue.getNumBlockedThreads() > 0;
	}

	@Override
	public  void  messageReceived(String aRemoteEnd, MessageType aMessage) {
		try {
			if (remoteEnd != null && !aRemoteEnd.equals(aRemoteEnd)) {
				return; // will not queue the message
			}
			Tracer.info("Sync message received");
			receivedValueQueue.put(new AReceiveReturnMessage(aRemoteEnd, aMessage));
			ReceivedMessageQueued.newCase(this, receivedValueQueue, aMessage);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	@Override
	public ReceiveReturnMessage<MessageType> getReceivedMessage() {
		try {
			Tracer.info("waiting for received message");
			ReceiveReturnMessage<MessageType> retVal = receivedValueQueue.take();
			ReceivedMessageDequeued.newCase(this, receivedValueQueue, retVal);
			return retVal;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		
	}



}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/aninheritingduplexiobjectinputportwithsyncreceivefactory.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.ADuplexObjectInputPortFactory;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;



public class AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory  extends ADuplexObjectInputPortFactory 
	implements DuplexInputPortWithSyncReceiveFactory<Object>{

	@Override
	public DuplexClientInputPortWithSyncReceive<Object> createDuplexClientInputPortWithSyncReceive(
			String theHost, String theServerId, String aServerName,
			String theClientName) {
		DuplexClientInputPort  duplexClientInputPort = super.createDuplexClientInputPort(theHost, theServerId, aServerName, theClientName);
		return new ADuplexClientInputPortWithSyncReceive(duplexClientInputPort);
	}

	@Override
	public DuplexServerInputPortWithSyncReceive<Object> createDuplexServerInputPortWithSyncReceive(
			String aServerId, String aServerName) {
		DuplexServerInputPort  duplexServerInputPort = super.createDuplexServerInputPort(aServerId, aServerName);
		return new ADuplexServerInputPortWithSyncReceive(duplexServerInputPort);
		
	}

	@Override
	public DuplexServerInputPort<Object> createDuplexServerInputPort(
			String aServerId, String aServerName) {
		return createDuplexServerInputPortWithSyncReceive(aServerId, aServerName);
		
	}

	@Override
	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
			String theServerId, String aServerName, String theClientName) {
		
		return createDuplexClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);


	}	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/anobjectduplexinputportwithsyncreceivefactory.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;



public class AnObjectDuplexInputPortWithSyncReceiveFactory  extends ADuplexInputPortWithSyncReceiveFactory<Object> implements DuplexInputPortWithSyncReceiveFactory<Object>{

	@Override
	public DuplexServerInputPort<Object> createDuplexServerInputPort(
			String theServerId, String theServerName) {
		return DuplexObjectInputPortSelector.createDuplexServerInputPort(theServerId, theServerName);
	}

	@Override
	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
			String theServerId, String serverName, String theClientName) {
		return DuplexObjectInputPortSelector.createDuplexClientInputPort(theHost, theServerId, serverName, theClientName);
	}	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/blockingqueuewithblockedthreadcount.java
package inputport.datacomm.duplex.object.explicitreceive;

import java.util.concurrent.BlockingQueue;

public interface BlockingQueueWithBlockedThreadCount<E> extends BlockingQueue<E>{

	public abstract int getNumBlockedThreads();

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/duplexobjectinputportwithsyncreceiveselector.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;



public class DuplexObjectInputPortWithSyncReceiveSelector  {
//	static DuplexInputPortFactory<ByteBuffer> factory = new AnNIODuplexInputPortFactory();
	static DuplexInputPortWithSyncReceiveFactory<Object> factory = new ADuplexObjectInputPortWithSyncReceiveFactory();
	public static void setObjectDuplexInputPortWithSyncReceiveFactory(DuplexInputPortWithSyncReceiveFactory<Object> aFactory) {
		factory = aFactory;
	}
	public static DuplexServerInputPortWithSyncReceive<Object> createDuplexServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return factory.createDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexClientInputPortWithSyncReceive<Object> createDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName){
		return factory.createDuplexClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);
	}
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/objectduplexclientinputportlauncher.java
package inputport.datacomm.duplex.object.explicitreceive;



import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;

import java.util.Scanner;

import port.old.PrintingTypedReceiveListener;
import util.trace.Tracer;



public class ObjectDuplexClientInputPortLauncher {
	public static void main (String[] args) {
		Tracer.showInfo(true);
		DuplexClientInputPortWithSyncReceive<Object> clientInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive("localhost", "9090", "test server", "test client");
//		PrintingReceiveListener echoingConnectionListener = new PrintingReceiveListener();
//		clientInputPort.addConnectListener(echoingConnectionListener);
//		clientInputPort.addReceiveListener(echoingConnectionListener);
//		clientInputPort.connect();
//		ByteBuffer message =  ByteBuffer.wrap("hello server".getBytes());
//		System.out.println("String with padding:" + new String(message.array()));		
//		clientInputPort.send(message);
		PrintingTypedReceiveListener echoingConnectionListener = new PrintingTypedReceiveListener(clientInputPort);
		clientInputPort.addConnectionListener(echoingConnectionListener);
		clientInputPort.addReceiveListener(echoingConnectionListener);
		clientInputPort.connect();
		String stringMessage = "hello server";
//		ByteBuffer message = ByteBuffer.wrap(stringMessage.getBytes());
		Scanner in = new Scanner(System.in);	
		while (true) {
			clientInputPort.send(stringMessage);
			ReceiveReturnMessage<Object> received = clientInputPort.receive();
			System.out.println("Sync Received message: " + received + " from "  + received.getSource());
		    stringMessage  = in.nextLine();
			System.out.println("sending read input:" + stringMessage);
//		    message =  ByteBuffer.wrap(stringMessage.getBytes());	
		}
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/objectduplexserverinputportlauncher.java
package inputport.datacomm.duplex.object.explicitreceive;

import inputport.datacomm.duplex.DuplexServerInputPort;
import port.old.PrintingReplyingObjectReceiver;
import util.trace.Tracer;



public class ObjectDuplexServerInputPortLauncher {
	public static void main (String[] args) {
		Tracer.showInfo(true);
		DuplexServerInputPort serverInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive("9090", "test server");
		PrintingReplyingObjectReceiver echoingReceiveListener = new PrintingReplyingObjectReceiver(serverInputPort);
		serverInputPort.addConnectionListener(echoingReceiveListener);
		serverInputPort.addReceiveListener(echoingReceiveListener);	
		serverInputPort.connect();
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package inputport.datacomm.duplex.object.explicitreceive;
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/test/asyncreceiveclient1launcher.java
package inputport.datacomm.duplex.object.explicitreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient1Launcher;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.EXPLICIT_RECEIVE_CLIENT1})
public class ASyncReceiveClient1Launcher extends ACustomCounterClient1Launcher{
	public static void main (String[] args) {
		FactorySetterFactory.setSingleton(new ASyncReceiveFactorySetter());
		ObjectTraceUtility.setTracing();
		ACustomCounterClient.launch(CLIENT1_NAME);
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/test/asyncreceiveclient2launcher.java
package inputport.datacomm.duplex.object.explicitreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient2Launcher;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.EXPLICIT_RECEIVE_CLIENT2})
public class ASyncReceiveClient2Launcher extends ACustomCounterClient2Launcher{
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new ASyncReceiveFactorySetter());
		ACustomCounterClient.launch(CLIENT2_NAME);
	}
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/test/asyncreceivefactorysetter.java
package inputport.datacomm.duplex.object.explicitreceive.test;

import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.AnObjectDuplexInputPortWithSyncReceiveFactory;
import inputport.datacomm.simplex.object.AnObjectInputPortFactory;
import examples.gipc.counter.customization.ACustomDuplexObjectInputPortFactory;
import examples.gipc.counter.customization.FactorySetter;

public class ASyncReceiveFactorySetter implements FactorySetter {

	@Override
	public void setFactories() {
		 
			DuplexObjectInputPortSelector.setDuplexInputPortFactory(
					new AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory());
		
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/test/asyncreceiveserverlauncher.java
package inputport.datacomm.duplex.object.explicitreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import examples.gipc.counter.customization.ACustomCounterServer;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.EXPLICIT_RECEIVE_SERVER})
public class ASyncReceiveServerLauncher {
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new ASyncReceiveFactorySetter());
		ACustomCounterServer.launch();
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/duplex/object/explicitreceive/test/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package inputport.datacomm.duplex.object.explicitreceive.test;
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/buffer/syncrcv/abuffergroupinputportwithsyncreceivefactory.java
package inputport.datacomm.group.buffer.syncrcv;

import inputport.datacomm.duplex.buffer.syncrcv.BufferDuplexInputPortWithSyncReceiveSelector;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.group.syncrcv.GroupInputPortWithSyncReceiveFactory;
import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;

import java.nio.ByteBuffer;


public class ABufferGroupInputPortWithSyncReceiveFactory implements GroupInputPortWithSyncReceiveFactory<ByteBuffer>  {
	@Override
	public GroupServerInputPortWithSyncReceive<ByteBuffer> createGroupServerInputPortWithSyncReceive(String theServerId,
			String theServerName) {
		DuplexServerInputPortWithSyncReceive<ByteBuffer> duplexPort =  	BufferDuplexInputPortWithSyncReceiveSelector.createBufferDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
//		GroupNamingSender<ByteBuffer> namingSender = new AnUntypedGroupNamingSender(duplexPort);
		return new ABufferGroupServerInputPortWithSyncReceive (duplexPort);	
	}
	@Override
	public DuplexClientInputPortWithSyncReceive<ByteBuffer> createDuplexClientInputPortWithSyncReceive(String theServerHost,
			String theServerId, String aServerName, String theClientName) {
		return BufferDuplexInputPortWithSyncReceiveSelector.createBufferDuplexClientInputPortWithSyncReceive(theServerHost, theServerId, aServerName, theClientName);
		
	}
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/buffer/syncrcv/abuffergroupserverinputportwithsyncreceive.java
package inputport.datacomm.group.buffer.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.group.buffer.ABufferGroupServerInputPort;
import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;

import java.nio.ByteBuffer;


public class ABufferGroupServerInputPortWithSyncReceive extends ABufferGroupServerInputPort 
		implements GroupServerInputPortWithSyncReceive<ByteBuffer>{
	DuplexServerInputPortWithSyncReceive<ByteBuffer> duplexServerInputPortWithSyncReceive;

	public ABufferGroupServerInputPortWithSyncReceive(DuplexServerInputPortWithSyncReceive<ByteBuffer> aDuplexServerInputPort) {
		super(aDuplexServerInputPort);
		duplexServerInputPortWithSyncReceive = aDuplexServerInputPort;
	}

	@Override
	public ReceiveReturnMessage<ByteBuffer> receive() {
		return duplexServerInputPortWithSyncReceive.receive();
	}

	@Override
	public ReceiveReturnMessage<ByteBuffer> receive(String source) {
		return duplexServerInputPortWithSyncReceive.receive(source);
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/buffer/syncrcv/buffergroupinputportwithsyncreceiveselector.java
package inputport.datacomm.group.buffer.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.group.syncrcv.GroupInputPortWithSyncReceiveFactory;
import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;

import java.nio.ByteBuffer;



public class BufferGroupInputPortWithSyncReceiveSelector  {
	static GroupInputPortWithSyncReceiveFactory<ByteBuffer> inputPortFactory = new ABufferGroupInputPortWithSyncReceiveFactory();
	public static void setGroupInputPortWithSyncReceiveFactory(GroupInputPortWithSyncReceiveFactory<ByteBuffer> theInputPortFactory) {
		inputPortFactory = theInputPortFactory;
	}
	public static GroupServerInputPortWithSyncReceive<ByteBuffer> createGroupServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return inputPortFactory.createGroupServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexClientInputPortWithSyncReceive createDuplexClientInputPort(String theHost, String theServerId, String aServerName, String theClientName){
		return inputPortFactory.createDuplexClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);
	}
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/syncrcv/agroupinputportwithsyncreceivefactory.java
package inputport.datacomm.group.syncrcv;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.object.explicitreceive.ADuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.group.GroupServerInputPort;

public  abstract class AGroupInputPortWithSyncReceiveFactory<MessageType>  implements 
GroupInputPortWithSyncReceiveFactory<MessageType>{
	
	abstract protected GroupServerInputPort<MessageType> createGroupServerInputPort(String theServerId, String theServerName);
	abstract protected DuplexClientInputPort<MessageType> createDuplexClientInputPort(String theHost, String theServerId, String aServerName, String theClientName);
	
	@Override
	public DuplexClientInputPortWithSyncReceive<MessageType> createDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName) {
		DuplexClientInputPort<MessageType>  duplexClientInputPort = createDuplexClientInputPort(theHost, theServerId, aServerName, theClientName);
		return new ADuplexClientInputPortWithSyncReceive<MessageType>(duplexClientInputPort);
		
	}
	
	@Override
	public GroupServerInputPortWithSyncReceive<MessageType> createGroupServerInputPortWithSyncReceive(String aServerId, String aServerName) {
		GroupServerInputPort<MessageType> groupServerInputPort = createGroupServerInputPort(aServerId, aServerName);
		return new AGroupServerInputPortWithSyncReceive<MessageType>(groupServerInputPort);
		
	}

//	@Override
//	public DuplexServerInputPort<MessageType> createDuplexServerInputPort(
//			String theServerId, String theServerName) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public DuplexClientInputPort createDuplexClientInputPort(String theHost,
//			String theServerId, String serverName, String theClientName) {
//		// TODO Auto-generated method stub
//		return null;
//	}


	
	
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/syncrcv/agroupserverinputportwithsyncreceive.java
package inputport.datacomm.group.syncrcv;

import inputport.ConnectionListener;
import inputport.ConnectionType;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.ReceiveTrapper;
import inputport.datacomm.SendTrapper;
import inputport.datacomm.duplex.object.explicitreceive.ASyncReceiveListener;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;
import inputport.datacomm.group.GroupSendTrapper;
import inputport.datacomm.group.GroupServerInputPort;
import inputport.datacomm.group.GroupToUniSendTrapper;
import inputport.datacomm.simplex.buffer.ByteBufferSendListener;

import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class AGroupServerInputPortWithSyncReceive<MessageType>  implements 
	GroupServerInputPortWithSyncReceive<MessageType> {
	GroupServerInputPort<MessageType> groupServerInputPort;
	public void addConnectionListener(ConnectionListener portConnectListener) {
		groupServerInputPort.addConnectionListener(portConnectListener);
	}
	public void addReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		groupServerInputPort.addReceiveListener(portReceiveListener);
	}
	public void addSendListener(ByteBufferSendListener portSendListener) {
		groupServerInputPort.addSendListener(portSendListener);
	}
	public void connect() {
		groupServerInputPort.connect();
	}
	public void disconnect() {
		groupServerInputPort.disconnect();
	}
	public String getSender() {
		return groupServerInputPort.getSender();
	}
	public String getLocalName() {
		return groupServerInputPort.getLocalName();
	}
	public Set<String> getConnections() {
		return groupServerInputPort.getConnections();
	}
	public void notifyConnect(String remoteEnd, ConnectionType aConnectionType) {
		groupServerInputPort.notifyConnect(remoteEnd, aConnectionType);
	}
	public void notifyConnectFailure(String remoteEnd, String message, ConnectionType aConnectionType) {
		groupServerInputPort.notifyConnectFailure(remoteEnd, message, null);
	}
	public void notifyDisconnect(String remoteEnd, boolean eof,
			String closeReason, ConnectionType aConnectionType) {
		groupServerInputPort.notifyDisconnect(remoteEnd, eof, closeReason, null);
	}
	public void notifyPortReceive(String remoteEnd, MessageType message) {
		groupServerInputPort.notifyPortReceive(remoteEnd, message);
	}
	public void notifyPortSend(String aRemoteEnd, ByteBuffer message, int sendId) {
		groupServerInputPort.notifyPortSend(aRemoteEnd, message, sendId);
	}
	public void removeConnectionListener(ConnectionListener portConnectListener) {
		groupServerInputPort.removeConnectionListener(portConnectListener);
	}
	public void removeReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		groupServerInputPort.removeReceiveListener(portReceiveListener);
	}
	@Override
	public List<ReceiveListener<MessageType>> getReceiveListeners() {
		return groupServerInputPort.getReceiveListeners();
	}
	
	public void removeSendListener(ByteBufferSendListener portSendListener) {
		groupServerInputPort.removeSendListener(portSendListener);
	}
	public void reply(MessageType message) {
		groupServerInputPort.reply(message);
	}
	@Override
	public void reply(String aRemoteEnd, MessageType aMessage) {
		send(aRemoteEnd, aMessage);
	}
	public void send(MessageType message) {
		groupServerInputPort.send(message);
	}
	public void send(Collection<String> clientNames, MessageType message) {
		groupServerInputPort.send(clientNames, message);
	}
	public void send(String remoteName, MessageType message) {
		groupServerInputPort.send(remoteName, message);
	}
	public void sendAll(MessageType message) {
		groupServerInputPort.sendAll(message);
	}
	public void sendOthers(MessageType message) {
		groupServerInputPort.sendOthers(message);
	}
	public void setSender(String newVal) {
		groupServerInputPort.setSender(newVal);
	}
	Map<String, ExplicitReceiveListener<MessageType>> nameToSyncReceiveListener = new HashMap();
	
	public AGroupServerInputPortWithSyncReceive(GroupServerInputPort<MessageType> aGroupServerInputPort) {
		groupServerInputPort = aGroupServerInputPort;
	
	}
	protected ExplicitReceiveListener<MessageType>  createSyncReceiveListener(String aClientName) {
		return new ASyncReceiveListener(aClientName);
	}
	protected ExplicitReceiveListener<MessageType> getAndMaybeCreateSyncReceiveListener(String clientName) {
		ExplicitReceiveListener<MessageType> syncReceiveListener = nameToSyncReceiveListener.get(clientName);
		if (syncReceiveListener == null) {
			syncReceiveListener = createSyncReceiveListener(clientName);
			nameToSyncReceiveListener.put(clientName, syncReceiveListener);
			groupServerInputPort.addReceiveListener(syncReceiveListener);	
		}
		return syncReceiveListener;
	}

	@Override
	public ReceiveReturnMessage<MessageType> receive() {
		return receive(getSender());		
	}	
	@Override
	public ReceiveReturnMessage<MessageType> receive(String aSource) {
		return getAndMaybeCreateSyncReceiveListener(aSource).getReceivedMessage();		
	}
	@Override
	public String getServerId() {
		return groupServerInputPort.getServerId();
	}
	@Override
	public GroupSendTrapper<MessageType, MessageType> getGroupSendTrapper() {
		return groupServerInputPort.getGroupSendTrapper();
	}
	@Override
	public GroupToUniSendTrapper<MessageType, MessageType> getGroupToUniSendTrapper() {
		return groupServerInputPort.getGroupToUniSendTrapper();
	}
	@Override
	public void setGroupSendTrapper(
			GroupSendTrapper<MessageType, MessageType> groupSendTrapper) {
		groupServerInputPort.setGroupSendTrapper(groupSendTrapper);
	}
	@Override
	public void setGroupToUniSendTrapper(
			GroupToUniSendTrapper<MessageType, MessageType> groupToUniSendTrapper) {
		groupServerInputPort.setGroupToUniSendTrapper(groupToUniSendTrapper);
	}
	@Override
	public ReceiveTrapper<MessageType, MessageType> getReceiveTrapper() {
		return groupServerInputPort.getReceiveTrapper();
	}
	@Override
	public void setReceiveTrapper(
			ReceiveTrapper<MessageType, MessageType> newVal) {
		groupServerInputPort.setReceiveTrapper(newVal);
	}
	@Override
	public SendTrapper<MessageType, MessageType> getSendTrapper() {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public void setSendTrapper(SendTrapper<MessageType, MessageType> newVal) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public boolean isConnected(String remoteName) {
		// TODO Auto-generated method stub
		return groupServerInputPort.isConnected(remoteName);
	}
	
	@Override
	public String getLogicalRemoteEndPoint() {
		return groupServerInputPort.getLogicalRemoteEndPoint();
	}
	@Override
	public String getPhysicalRemoteEndPoint() {
		return groupServerInputPort.getPhysicalRemoteEndPoint();
	}
	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		groupServerInputPort.setLogicalRemoteEndPoint(newVal);
	}
	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		groupServerInputPort.setPhysicalRemoteEndPoint(newVal);
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/syncrcv/groupinputportwithsyncreceivefactory.java
package inputport.datacomm.group.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;

public interface GroupInputPortWithSyncReceiveFactory<MessageType> {
	 GroupServerInputPortWithSyncReceive<MessageType> createGroupServerInputPortWithSyncReceive(String theServerId, String theServerName);
	 DuplexClientInputPortWithSyncReceive<MessageType> createDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName);



}
//END OF FILE
//START OF FILE: src/inputport/datacomm/group/syncrcv/groupserverinputportwithsyncreceive.java
package inputport.datacomm.group.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.group.GroupServerInputPort;

public interface GroupServerInputPortWithSyncReceive<MessageType> extends  GroupServerInputPort<MessageType>, 
	DuplexServerInputPortWithSyncReceive<MessageType>{

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/asocketacceptingrunnable.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.ServerSocket;
import java.net.Socket;

import util.misc.HashIdentityMap;
import util.misc.IdentityMap;
import util.misc.StoppableRunnable;


public class ASocketAcceptingRunnable implements SocketAcceptingRunnable {
	ServerSocket serverSocket;
	SocketServerInputDriver driver;
	IdentityMap<Socket, Thread> socketToReadingThread = new HashIdentityMap();
	public  ASocketAcceptingRunnable(SocketServerInputDriver aSocketServerInputDriver,  ServerSocket aServerSocket) {
		driver = aSocketServerInputDriver;
		serverSocket = aServerSocket;
	}

	@Override
	public void run() {
		while (true) {
			try {
				Socket socket = serverSocket.accept();
				StoppableRunnable socketReadingRunnable = new ASocketReadingRunnable(socket, driver, driver);
				driver.socketAccepted(serverSocket, socket);
				Thread thread = new Thread(socketReadingRunnable);
				thread.setName("Socket reading thread for " + socket);
				socketToReadingThread.put(socket, thread);
				thread.start();
				
			} catch (Exception e) {
				e.printStackTrace();
				driver.socketNotAccepted(serverSocket, e);
			}
		}
		
	}

	@Override
	public Thread getReadingThread(Socket socket) {
		return socketToReadingThread.get(socket);
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/asocketclientinputdriver.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.ConnectionType;
import inputport.datacomm.simplex.buffer.SimplexClientInputPortSkeleton;
import inputport.nio.manager.AScatterGatherSelectionManager;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.ByteBuffer;

import util.trace.Tracer;


public class ASocketClientInputDriver  implements SocketClientInputDriver {
	InetAddress host;
	int port;
	protected String serverName;
	protected Socket socket;
	OutputStream socketOutputStream;
	SimplexClientInputPortSkeleton clientInputPortSkeleton;
	int sendId = 0;
	ByteBuffer 	headerBuffer = ByteBuffer.allocate(AScatterGatherSelectionManager.BYTES_IN_INT);

	public ASocketClientInputDriver(String theRemoteHostName, String theRemotePort, String aServerName) {
		try {
			host = InetAddress.getByName(theRemoteHostName);
			port = Integer.parseInt(theRemotePort);
			serverName = aServerName;			
//			headerBuffer.rewind();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	@Override
	public void setSkeleton(SimplexClientInputPortSkeleton<Socket> theSkeleton) {
		clientInputPortSkeleton = theSkeleton;		
	}
	
	
	@Override
	public SimplexClientInputPortSkeleton<Socket> getSkeleton() {
		return clientInputPortSkeleton;
	}

	@Override
	public void connect() {
		try {
			socket = new Socket(host, port);
			socketOutputStream = socket.getOutputStream();
			connected(socket);
		} catch (Exception e) {
			e.printStackTrace();
			notConnected(socket, e);
//			clientInputPortSkeleton.notifyConnectFailure(serverName, e.getMessage());
		}		
	}	

	@Override
	public void send(String aDestination, ByteBuffer message) {
		try {
			int messageSize = message.limit() - message.position();
			headerBuffer.putInt(messageSize);
			headerBuffer.rewind();
			Tracer.info(this, "Sending messsage: " + headerBuffer + " to " + socket);
			socketOutputStream.write(headerBuffer.array(), headerBuffer.position(), headerBuffer.limit());
			Tracer.info(this, "Sending messsage: " + message + " to " + socket);

			socketOutputStream.write(message.array(), message.position(), message.limit());
			clientInputPortSkeleton.messageSent(aDestination, message, sendId);
			sendId++;
		} catch (Exception e) {
			socketClosed(socket, e);
			e.printStackTrace();
		}	
	}


//	@Override
	protected void connected(Socket aSocket) {
		clientInputPortSkeleton.connected(serverName, ConnectionType.TO_SERVER);
		
	}
//	@Override
	void notConnected(
			Socket aSocket, Exception e) {
		clientInputPortSkeleton.notConnected(serverName, e.getMessage(), null);
		
	}

	@Override
	public void disconnect() {
		if (socket == null) return; //maybe the socket did not get connected
		try {
			socket.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
//	@Override
//	public void close(Socket channel) {
//		try {
//			channel.close();
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
//	}
	@Override
	public void socketClosed(Socket socket, Exception e) {
		clientInputPortSkeleton.disconnected(serverName, false, e.getMessage(), null);
		
	}

	
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/asocketinputportfactory.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.datacomm.simplex.SimplexClientInputPort;
import inputport.datacomm.simplex.SimplexInputPortFactory;
import inputport.datacomm.simplex.SimplexServerInputPort;
import inputport.datacomm.simplex.buffer.AGenericSimplexBufferClientInputPort;
import inputport.datacomm.simplex.buffer.AGenericSimplexBufferServerInputPort;
import inputport.datacomm.simplex.buffer.GenericSimplexClientInputPort;
import inputport.datacomm.simplex.buffer.GenericSimplexServerInputPort;
import inputport.datacomm.simplex.buffer.SimplexBufferClientInputPortDriver;
import inputport.datacomm.simplex.buffer.SimplexBufferServerInputPortDriver;

import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;



public class ASocketInputPortFactory implements SimplexInputPortFactory<ByteBuffer>{
	@Override
	public SimplexServerInputPort<ByteBuffer> createSimplexServerInputPort(String theServerId,
			String theServerName) {
		GenericSimplexServerInputPort<ServerSocket, Socket> skeleton = new AGenericSimplexBufferServerInputPort(theServerName, theServerId);
		SimplexBufferServerInputPortDriver<ServerSocket, Socket> driver = new ASocketServerInputDriver(theServerId);
		skeleton.setDriver(driver);
		driver.setSkeleton(skeleton);
		return skeleton;
	}
	@Override
	public SimplexClientInputPort<ByteBuffer> createSimplexClientInputPort(String theServerHost,
			String theServerId, String aServerName, String theClientName) {
		GenericSimplexClientInputPort skeleton = new AGenericSimplexBufferClientInputPort(theServerHost, theServerId, aServerName, theClientName);
		SimplexBufferClientInputPortDriver<Socket> implementation = new ASocketClientInputDriver(theServerHost, theServerId, aServerName);
		skeleton.setDriver(implementation);
		implementation.setSkeleton(skeleton);
		return skeleton;
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/asocketreadingrunnable.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.nio.manager.AScatterGatherSelectionManager;
import inputport.nio.manager.commands.classes.AReadCommand;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.SocketException;
import java.nio.ByteBuffer;

import util.misc.AStoppableRunnable;
import util.trace.Tracer;



public class ASocketReadingRunnable extends AStoppableRunnable {
	SocketReadListener readListener;
	SocketCloseListener closeListener;	
	Socket socket;
	InputStream socketInputStream;
	byte[] readMessagerBytes = new byte[AReadCommand.READ_BUFFER_SIZE];
	byte[] readHeaderBytes = new byte[AScatterGatherSelectionManager.BYTES_IN_INT];
	
	public ASocketReadingRunnable(Socket aSocket, SocketReadListener aReadListener, SocketCloseListener aCloseListener) {
		socket = aSocket;
		try {
			socketInputStream = socket.getInputStream();
		} catch (Exception e) {
			e.printStackTrace();
		}
		readListener = aReadListener;
		closeListener = aCloseListener;
		
	}
	
	public static int read(InputStream inputStream, byte[] buf, int offset, int length) throws IOException, InterruptedException  {
		int nextLength = length;
		int nextOffset = 0;
		
		while (true) {
			try {
		
				int retVal = inputStream.read(buf, nextOffset, nextLength);
				if (retVal == -1)
					 throw new EOFException();
				else if (retVal == nextLength) {
					return length;
				} else {
					nextOffset += retVal;
					nextLength -= retVal;
				}	
			} catch (SocketException e) {
//				e.printStackTrace();
				throw new IOException(e.getMessage());
				
			}
		
		}
	}
	
//	public ASocketReadingRunnable(Socket aSocket) {
//		socket = aSocket;
//		try {
//			socketInputStream = socket.getInputStream();
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
//	}
//	@Override
//	public synchronized void registerReadListener(
//			SocketReadListener aReadListener) {
//		readListener = aReadListener;		
//	}
//	@Override
//	public synchronized void registerCloseListener(
//			SocketCloseListener aCloseListener) {
//		closeListener = aCloseListener;	
//	}
	@Override
	public void run() {
		while (execute) {
			try {
				Tracer.info(this, "About to read from socket:" + socket);
				int retVal = read(socketInputStream, readHeaderBytes, 0, readHeaderBytes.length);
				Tracer.info(this, "read header bytes " + readHeaderBytes + " from " + socket);
				ByteBuffer readHeader = ByteBuffer.wrap(readHeaderBytes);
				int nextMessageLength = readHeader.getInt();
				retVal = read(socketInputStream, readMessagerBytes, 0, nextMessageLength);	
				Tracer.info(this, "read message bytes " + readMessagerBytes + " from " + socket);

				readListener.socketRead(socket, ByteBuffer.wrap(readMessagerBytes, 0, nextMessageLength));		
				
			} catch (InterruptedException ie) {
				closeListener.socketClosed(socket, ie);

				break;
			}
			catch (Exception e) {
				e.printStackTrace();
				closeListener.socketClosed(socket, e);
				break;
			}
			
		}
		
	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/asocketserverinputdriver.java
package inputport.datacomm.simplex.buffer.socket;
import inputport.datacomm.simplex.buffer.SimplexServerInputPortSkeleton;

import java.io.EOFException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;




public class ASocketServerInputDriver implements SocketServerInputDriver {
	SimplexServerInputPortSkeleton<ServerSocket, Socket> skeleton;
	protected SocketAcceptingRunnable acceptingRunnable;
	int portNumber;
	ServerSocket serverSocket;	
	String serverId;




	//InetAddress localHost;
	public ASocketServerInputDriver (String thePortId) {
		portNumber = Integer.parseInt(thePortId);
	}
	@Override
	public void connect() {
		serverSocket = createSocket();
		if (serverSocket != null)
			startAcceptThread();
	
	}
	
	ServerSocket createSocket() {
		try {			
			//localHost = InetAddress.getLocalHost();
			ServerSocket retVal = new ServerSocket();
			InetSocketAddress isa = new InetSocketAddress(portNumber);
			retVal.bind(isa);
			return retVal;			
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	@Override
	public void disconnect() {
		closeRequestChannel();
	}	
	void startAcceptThread() {
		acceptingRunnable = new ASocketAcceptingRunnable(this, serverSocket);
		Thread thread = new Thread (acceptingRunnable);
		thread.setName("Socket Accepting Thread for  " + serverSocket);
		thread.start();
	}
	@Override
	public void setSkeleton(SimplexServerInputPortSkeleton theSkeleton) {
		skeleton = theSkeleton;
		
	}
	
	@Override
	public void disconnect(Socket aSocket) {
		try {
			aSocket.close();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	@Override
	public void socketRead(Socket socket, ByteBuffer message) {
		skeleton.messageReceived(socket, message);
		
	}
	@Override
	public void socketClosed(Socket socket, Exception theReadException) {
		try {
			Thread readingThread = acceptingRunnable.getReadingThread(socket);
			if (readingThread != null) {
				readingThread.interrupt();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		skeleton.disconnected (skeleton.getClientName(socket), theReadException instanceof EOFException, theReadException.getMessage(), null);
		
	}
	@Override
	public void socketAccepted(ServerSocket serverSocket, Socket socket) {
		
	}
	@Override
	public void socketNotAccepted(ServerSocket socket, Exception e) {
		
	}
	
	void closeRequestChannel() {
		try {
			serverSocket.close();			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketacceptlistener.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.ServerSocket;
import java.net.Socket;

public interface SocketAcceptListener {
	public void socketAccepted(ServerSocket aServerSocket, Socket aSocket);	
	public void socketNotAccepted(ServerSocket aSocket, Exception e);

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketacceptingrunnable.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.Socket;

public interface SocketAcceptingRunnable extends Runnable {
	Thread getReadingThread(Socket socket);
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketclientinputdriver.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.datacomm.simplex.buffer.SimplexBufferClientInputPortDriver;

import java.net.Socket;


public interface SocketClientInputDriver extends SimplexBufferClientInputPortDriver<Socket>, SocketCloseListener {

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketclientinputportlauncher.java
package inputport.datacomm.simplex.buffer.socket;

public class SocketClientInputPortLauncher {
//	public static void main(String args[]) {
//		InputPortFactory<ByteBuffer> untypedInputPortFactory = new ASocketInputPortFactory();
//		BufferInputPortSelector.setInputPortFactory(untypedInputPortFactory);
//		AClientInputPortSimplexBufferLuancher.launch(args);
//	}

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketcloselistener.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.Socket;


public interface SocketCloseListener {
	void socketClosed(Socket aSocket, Exception theReadException);
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketconnectlistener.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.Socket;

public interface SocketConnectListener {
	public void connected(Socket aSocket);	
	public void notConnected(Socket aSocket, Exception e);
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketreadlistener.java
package inputport.datacomm.simplex.buffer.socket;

import java.net.Socket;
import java.nio.ByteBuffer;


public interface SocketReadListener {
	void socketRead(Socket aSocket, ByteBuffer aMessage);
	
}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketreadingrunnable.java
package inputport.datacomm.simplex.buffer.socket;

public interface SocketReadingRunnable extends Runnable {
//	void registerReadListener(
//			SocketReadListener aReadListener);
//	void registerCloseListener(	SocketCloseListener aCloseListener);

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketserverinputdriver.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.datacomm.simplex.buffer.SimplexBufferServerInputPortDriver;

import java.net.ServerSocket;
import java.net.Socket;


public interface SocketServerInputDriver extends SimplexBufferServerInputPortDriver<ServerSocket, Socket>, SocketReadListener, SocketCloseListener, 
SocketAcceptListener{

}
//END OF FILE
//START OF FILE: src/inputport/datacomm/simplex/buffer/socket/socketserverinputportlauncher.java
package inputport.datacomm.simplex.buffer.socket;

import inputport.datacomm.simplex.SimplexInputPortFactory;
import inputport.datacomm.simplex.buffer.SimplexBufferInputPortSelector;

import java.nio.ByteBuffer;

import extraip.BufferServerInputPortLauncher;


public class SocketServerInputPortLauncher {
	public static void main (String[] args) {
		SimplexInputPortFactory<ByteBuffer> untypedInputPortFactory = new ASocketInputPortFactory();
		SimplexBufferInputPortSelector.setSimplexBufferInputPortFactory(untypedInputPortFactory);
		BufferServerInputPortLauncher.launch(args);
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aduplexrpcclientinputportwithsyncreceive.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.rpc.duplex.ADuplexRPCClientInputPort;
import inputport.rpc.duplex.RPCReturnValue;

public class ADuplexRPCClientInputPortWithSyncReceive  extends ADuplexRPCClientInputPort  
									implements DuplexRPCClientInputPortWithSyncReceive {
	DuplexClientInputPortWithSyncReceive<Object> duplexClientInputPortWithSyncReceive;
	public ADuplexRPCClientInputPortWithSyncReceive(DuplexClientInputPortWithSyncReceive<Object> aDuplexObjectClientInputPort) {
		super(aDuplexObjectClientInputPort);
		duplexClientInputPortWithSyncReceive = aDuplexObjectClientInputPort;;
	}
	@Override
	public ReceiveReturnMessage<Object> receive() {
		return duplexClientInputPortWithSyncReceive.receive();
	}
	@Override
	public ReceiveReturnMessage<Object> receive(String source) {
		return  duplexClientInputPortWithSyncReceive.receive();
	}	

	/**
	 * RPC return values are no longer sent to the default GIPC code
	 */
	@Override
	public void messageReceived(String remoteClientName, Object message) {
		if (!(message instanceof RPCReturnValue)) {
//			rpcReturnValueReceiver.messageReceived(remoteClientName, (RPCReturnValue) message);
//		} else
			super.messageReceived(remoteClientName, message);
		}
			
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aduplexrpcinputportwithsyncreceivefactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.DuplexObjectInputPortWithSyncReceiveSelector;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.rpc.duplex.DuplexRPCClientInputPort;
import inputport.rpc.duplex.DuplexRPCInputPortFactory;
import inputport.rpc.duplex.DuplexRPCServerInputPort;

// just has sync receive, not provedure syncing
public class ADuplexRPCInputPortWithSyncReceiveFactory implements DuplexRPCInputPortWithSyncReceiveFactory, DuplexRPCInputPortFactory {
    
	@Override
	public DuplexRPCClientInputPortWithSyncReceive createDuplexRPCClientInputPortWithSyncReceive(String theServerHost, String theServerId,
			String theServerName, String theClientName) {
		// TODO Auto-generated method stub
		DuplexClientInputPortWithSyncReceive<Object> typedClientInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive (theServerHost, theServerId, theServerName, theClientName);
		DuplexRPCClientInputPortWithSyncReceive rpcClientInputPort =  new ADuplexRPCClientInputPortWithSyncReceive(typedClientInputPort);
		return rpcClientInputPort;
	}

	@Override
	public DuplexRPCServerInputPortWithSyncReceive createDuplexRPCServerInputPortWithSyncReceive(String theServerId,
			String theServerName) {
		DuplexServerInputPortWithSyncReceive<Object> typedServerInputPort = DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
		DuplexRPCServerInputPortWithSyncReceive rpcServerInputPort = new ADuplexRPCServerInputPortWithSyncReceive(typedServerInputPort);
		return rpcServerInputPort;
	}

	@Override
	public DuplexRPCServerInputPort createDuplexRPCServerInputPort(
			String theServerId, String theServerName) {
		return createDuplexRPCServerInputPortWithSyncReceive(theServerId, theServerName);
	}

	@Override
	public DuplexRPCClientInputPort createDuplexRPCClientInputPort(
			String theServerHost, String theServerId, String theServerName,
			String theClientName) {
		return createDuplexRPCClientInputPortWithSyncReceive(theServerHost, theServerId, theServerName, theClientName);
	}

	@Override
	public DuplexRPCClientInputPort createDuplexRPCClientInputPort(
			DuplexClientInputPort<Object> typedClientInputPort) {
		return new ADuplexRPCClientInputPortWithSyncReceive((DuplexClientInputPortWithSyncReceive<Object>) typedClientInputPort);
	}

	@Override
	public DuplexRPCServerInputPort createDuplexRPCServerInputPort(
			DuplexServerInputPort<Object> typedServerInputPort) {
		return new ADuplexRPCServerInputPortWithSyncReceive((DuplexServerInputPortWithSyncReceive<Object>) typedServerInputPort);
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aduplexrpcserverinputportwithsyncreceive.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.rpc.duplex.ADuplexRPCServerInputPort;
import inputport.rpc.duplex.RPCReturnValue;

public class ADuplexRPCServerInputPortWithSyncReceive extends ADuplexRPCServerInputPort implements DuplexRPCServerInputPortWithSyncReceive {
	DuplexServerInputPortWithSyncReceive<Object> duplexServerInputPortWithSyncReceive;
	public ADuplexRPCServerInputPortWithSyncReceive(DuplexServerInputPortWithSyncReceive<Object> aTypedServerInputPort) {		
		super(aTypedServerInputPort);
		duplexServerInputPortWithSyncReceive = aTypedServerInputPort;		
	}
	@Override
	public ReceiveReturnMessage<Object> receive() {
		return duplexServerInputPortWithSyncReceive.receive();
	}
	@Override
	public ReceiveReturnMessage<Object> receive(String source) {
		return duplexServerInputPortWithSyncReceive.receive(source);
	}
//	@Override
//	protected DuplexSentCallCompleter createReturningUniNamingRPCFunctionHandler(LocalRemoteReferenceTranslator aRemoteHandler) {
//		return new ASyncReceiveSentCallCompleter(this, aRemoteHandler);
//	}

	
	/**
	 * RPC return values are no longer sent to the default GIPC code. Now they are received
	 */
	@Override
	public void messageReceived(String remoteClientName, Object message) {
		if (!(message instanceof RPCReturnValue)) {
//			rpcReturnValueReceiver.messageReceived(remoteClientName, (RPCReturnValue) message);
//		} else
			super.messageReceived(remoteClientName, message);
		}
			
	}
	
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aproceduresyncingduplexreceivedcallinvoker.java
package inputport.rpc.duplex.syncreceive;


import inputport.datacomm.NamingSender;
import inputport.datacomm.duplex.DuplexInputPort;
import inputport.rpc.RPCRegistry;
import inputport.rpc.duplex.ADuplexReceivedCallInvoker;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

import java.io.Serializable;


public class AProcedureSyncingDuplexReceivedCallInvoker extends ADuplexReceivedCallInvoker  {
	
	public AProcedureSyncingDuplexReceivedCallInvoker(LocalRemoteReferenceTranslator aRemoteHandler, DuplexInputPort<Object> aReplier, RPCRegistry theRPCRegistry) {
		super(aRemoteHandler, aReplier, theRPCRegistry);

	}
	@Override
	protected void handleProcedureReturn(String sender, Exception e) {
		replyPossiblyTransformedMethodReturnValue(sender, null, Object.class, e);

	}
	
	
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aproceduresyncingduplexreceivedcallinvokerfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.NamingSender;
import inputport.datacomm.duplex.DuplexInputPort;
import inputport.rpc.RPCRegistry;
import inputport.rpc.DuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.DuplexReceivedCallInvoker;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

public class AProcedureSyncingDuplexReceivedCallInvokerFactory implements DuplexReceivedCallInvokerFactory{

	@Override
	public DuplexReceivedCallInvoker createDuplexReceivedCallInvoker(
			LocalRemoteReferenceTranslator aRemoteHandler,
			DuplexInputPort<Object> aReplier, RPCRegistry anRPCRegistry) {
		return new AProcedureSyncingDuplexReceivedCallInvoker(aRemoteHandler, aReplier, anRPCRegistry);
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aproceduresyncingsyncreceiveduplexrpcinputportfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexObjectInputPortWithSyncReceiveSelector;
import inputport.rpc.duplex.ADuplexRPCInputPortFactory;
import inputport.rpc.duplex.DuplexRPCInputPortFactory;
import inputport.rpc.duplex.DuplexReceivedCallInvokerSelector;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;
// add procedure sync receive
public class AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory extends ADuplexRPCInputPortFactory implements DuplexRPCInputPortFactory {
	public AProcedureSyncingSyncReceiveDuplexRPCInputPortFactory() {
		super();
		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(
				new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
//		DuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(new AProcedureSyncingDuplexReceivedCallInvokerFactory());

		
	}
	protected DuplexServerInputPort<Object> createDuplexServerInputPort(String theServerId,
			String theServerName) {
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
		
	}
	protected DuplexClientInputPort<Object> createDuplexClientInputPort(String theServerHost, String theServerId,
			String theServerName, String theClientName)  {
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive(theServerHost, theServerId, theServerName, theClientName);		
	}
	


}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aproceduresyncingsyncreceivesentcallcompleter.java
package inputport.rpc.duplex.syncreceive;

import inputport.rpc.duplex.DuplexRPCInputPort;
import inputport.rpc.duplex.DuplexSentCallCompleter;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

public class AProcedureSyncingSyncReceiveSentCallCompleter 
	extends ASyncReceiveSentCallCompleter
	implements 	DuplexSentCallCompleter{
	
	public AProcedureSyncingSyncReceiveSentCallCompleter(DuplexRPCInputPort aPort, LocalRemoteReferenceTranslator aRemoteHandler) {
		super(aPort, aRemoteHandler);
		
	}
	@Override
	protected Object returnValueOfRemoteProcedureCall(String aRemoteEndPoint, Object aMessage) {
		return getReturnValueOfRemoteFunctionCall(aRemoteEndPoint, aMessage);
	}
	protected Object getReturnValueOfRemoteProcedureCall(String aRemoteEndPoint, Object aMessage) {
		return getReturnValueOfRemoteFunctionCall(aRemoteEndPoint, aMessage);
	}
	
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/aproceduresyncingsyncreceivesentcallcompletercallfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.rpc.duplex.DuplexRPCInputPort;
import inputport.rpc.duplex.DuplexSentCallCompleter;
import inputport.rpc.duplex.DuplexSentCallCompleterFactory;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

public class AProcedureSyncingSyncReceiveSentCallCompleterCallFactory  
             implements DuplexSentCallCompleterFactory {

	@Override
	public DuplexSentCallCompleter 
	    createDuplexSentCallCompleter(DuplexRPCInputPort aPort, LocalRemoteReferenceTranslator aTranslator) {
		
 
		return new AProcedureSyncingSyncReceiveSentCallCompleter(aPort, aTranslator);
	}
}


//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/areceivingreturnvalueprocessor.java
package inputport.rpc.duplex.syncreceive;

import inputport.rpc.duplex.MaybeProcessReturnValue;
import inputport.rpc.duplex.RPCReturnValue;

public class AReceivingReturnValueProcessor implements MaybeProcessReturnValue {

	@Override
	public boolean maybeProcessReturnValue(String source, Object message) {
		return  message instanceof RPCReturnValue;
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/areceivinguniimplicitrpcfunctionhandler.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceive;
import inputport.rpc.RemoteCall;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;
import inputport.rpc.duplex.RPCReturnValue;
import extraip.ReturnerOfFunctionCall;

public class AReceivingUniImplicitRPCFunctionHandler 
	extends AReceivingReturnValueProcessor 
	implements ReturnerOfFunctionCall	{
	ExplicitReceive<Object> receiver;
	LocalRemoteReferenceTranslator remoteHandler;
	
	public AReceivingUniImplicitRPCFunctionHandler(ExplicitReceive<Object> aReceiver, LocalRemoteReferenceTranslator aRemoteHandler) {
		receiver = aReceiver;
		remoteHandler = aRemoteHandler;
	}
		
	@Override
	public Object returnValueOfRemoteMethodCall(String aRemoteEndPoint, RemoteCall aCall) {
		try {
			while (true) {
			ReceiveReturnMessage messageWithSource = receiver.receive();
			Object message = messageWithSource.getMessage();
			if (message instanceof RPCReturnValue ) {
				return remoteHandler.transformReceivedReference(((RPCReturnValue) message).getReturnValue());
			} 
			}
			
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		
	}

	

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/asyncreceiveduplexrpcinputportfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.DuplexServerInputPort;
import inputport.datacomm.duplex.object.explicitreceive.DuplexObjectInputPortWithSyncReceiveSelector;
import inputport.rpc.duplex.ADuplexRPCInputPortFactory;
import inputport.rpc.duplex.DuplexRPCInputPortFactory;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;

public class ASyncReceiveDuplexRPCInputPortFactory extends ADuplexRPCInputPortFactory implements DuplexRPCInputPortFactory {
	public ASyncReceiveDuplexRPCInputPortFactory() {
		super();
		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(
				new ASyncReceiveSentCallCompleterCallFactory());
	}
	protected DuplexServerInputPort<Object> createDuplexServerInputPort(String theServerId,
			String theServerName) {
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexServerInputPortWithSyncReceive(theServerId, theServerName);
		
	}
	protected DuplexClientInputPort<Object> createDuplexClientInputPort(String theServerHost, String theServerId,
			String theServerName, String theClientName)  {
		return DuplexObjectInputPortWithSyncReceiveSelector.createDuplexClientInputPortWithSyncReceive(theServerHost, theServerId, theServerName, theClientName);		
	}
	


}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/asyncreceivesentcallcompleter.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitSourceReceive;
import inputport.rpc.duplex.ADuplexSentCallCompleter;
import inputport.rpc.duplex.DuplexRPCInputPort;
import inputport.rpc.duplex.DuplexSentCallCompleter;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;
import inputport.rpc.duplex.RPCReturnValue;

public class ASyncReceiveSentCallCompleter 
	extends ADuplexSentCallCompleter
	implements 
	DuplexSentCallCompleter{
	protected ExplicitSourceReceive<Object>  receiver;
//	protected LocalRemoteReferenceTranslator localRemoteReferenceTranslator;
	
	public ASyncReceiveSentCallCompleter(DuplexRPCInputPort aPort, LocalRemoteReferenceTranslator aRemoteHandler) {
		super(aPort, aRemoteHandler);
		receiver = 
		(ExplicitSourceReceive<Object>)aPort.getDuplexInputPort();
//		localRemoteReferenceTranslator = aRemoteHandler;
	}
	/**
	 * Keep processing messages until a return value is received. 
	 * Other messages will also be received, focus only on received RPC
	 * values
	 * 
	 */
	protected Object receiveReturnValue(String aSource) {
		while (true) {
			ReceiveReturnMessage messageWithSource = receiver.receive(aSource);
			Object message = messageWithSource.getMessage();
			if (message instanceof RPCReturnValue) {
				return ((RPCReturnValue) message).getReturnValue();
			}
		}		
	}
	/**
	 * Do nothing when return value received in receiving thread
	 */
	@Override
	protected void returnValueReceived(String source, Object message) {
//		return  message instanceof RPCReturnValue;
	}
		
	/**
	 * Called by sending thread to receive return value
	 */
	@Override
	public Object getReturnValueOfRemoteFunctionCall(String aRemoteEndPoint, Object aMessage) {
//		if (isProcedure(aMessage))
//			return super.returnValueOfRemoteMethodCall(aRemoteEndPoint, aMessage);
		try {

			return localRemoteReferenceTranslator.transformReceivedReference(receiveReturnValue(aRemoteEndPoint));			
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/asyncreceivesentcallcompletercallfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.rpc.duplex.DuplexRPCInputPort;
import inputport.rpc.duplex.DuplexSentCallCompleter;
import inputport.rpc.duplex.DuplexSentCallCompleterFactory;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

public class ASyncReceiveSentCallCompleterCallFactory  
             implements DuplexSentCallCompleterFactory {

	@Override
	public DuplexSentCallCompleter 
	    createDuplexSentCallCompleter(DuplexRPCInputPort aPort, LocalRemoteReferenceTranslator aTranslator) {
		
 
		return new ASyncReceiveSentCallCompleter(aPort, aTranslator);
	}
}


//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/anasynchronousproceduresyncingduplexreceivedcallinvokerfactory.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.NamingSender;
import inputport.datacomm.duplex.DuplexInputPort;
import inputport.rpc.RPCRegistry;
import inputport.rpc.DuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.AnAsynchronousSingleThreadDuplexReceivedCallInvoker;
import inputport.rpc.duplex.DuplexReceivedCallInvoker;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;

public class AnAsynchronousProcedureSyncingDuplexReceivedCallInvokerFactory
    extends AProcedureSyncingDuplexReceivedCallInvokerFactory
    implements DuplexReceivedCallInvokerFactory{

	@Override
	public DuplexReceivedCallInvoker createDuplexReceivedCallInvoker(
			LocalRemoteReferenceTranslator aRemoteHandler,
			DuplexInputPort<Object> aReplier, RPCRegistry anRPCRegistry) {
//		return new AProcedureSyncingDuplexReceivedCallInvoker(aRemoteHandler, aReplier, anRPCRegistry);
		return new 
				AnAsynchronousSingleThreadDuplexReceivedCallInvoker(super.createDuplexReceivedCallInvoker(aRemoteHandler, aReplier, anRPCRegistry));
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/duplexrpcclientinputportwithsyncreceive.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceive;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitSourceReceive;
import inputport.rpc.duplex.DuplexRPCClientInputPort;

public interface DuplexRPCClientInputPortWithSyncReceive extends DuplexRPCClientInputPort, ExplicitReceive<Object>, ExplicitSourceReceive<Object> {

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/duplexrpcinputportwithsyncreceivefactory.java
package inputport.rpc.duplex.syncreceive;

public interface DuplexRPCInputPortWithSyncReceiveFactory {
	public DuplexRPCServerInputPortWithSyncReceive createDuplexRPCServerInputPortWithSyncReceive(String theServerId, String theServerName);
	public DuplexRPCClientInputPortWithSyncReceive createDuplexRPCClientInputPortWithSyncReceive (String theServerHost, String theServerId, String theServerName, String theClientName);

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/duplexrpcinputportwithsyncreceiveselector.java
package inputport.rpc.duplex.syncreceive;

public class DuplexRPCInputPortWithSyncReceiveSelector {
	static DuplexRPCInputPortWithSyncReceiveFactory inputPortFactory = new ADuplexRPCInputPortWithSyncReceiveFactory();
	public static void setInputPortFactory(DuplexRPCInputPortWithSyncReceiveFactory theInputPortFactory) {
		inputPortFactory = theInputPortFactory;
	}
	public static DuplexRPCInputPortWithSyncReceiveFactory getInputPortFactory() {
		return inputPortFactory;
	}	
	public static DuplexRPCServerInputPortWithSyncReceive createDuplexRPCServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return inputPortFactory.createDuplexRPCServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexRPCClientInputPortWithSyncReceive createDuplexRPCClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName){
		return inputPortFactory.createDuplexRPCClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/duplexrpcserverinputportwithsyncreceive.java
package inputport.rpc.duplex.syncreceive;

import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceive;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitSourceReceive;
import inputport.rpc.duplex.DuplexRPCServerInputPort;

public interface DuplexRPCServerInputPortWithSyncReceive extends DuplexRPCServerInputPort, ExplicitReceive<Object>, ExplicitSourceReceive<Object> {

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/syncrpc/test/asyncrpcsyncreceiveclient1launcher.java
package inputport.rpc.duplex.syncreceive.syncrpc.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient1Launcher;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.BLOCKING_RPC_CLIENT1})
public class ASyncRPCSyncReceiveClient1Launcher extends ACustomCounterClient1Launcher{
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new ASyncRPCSyncReceiveFactorySetter());
		ACustomCounterClient.launch(CLIENT1_NAME);
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/syncrpc/test/asyncrpcsyncreceiveclient2launcher.java
package inputport.rpc.duplex.syncreceive.syncrpc.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient2Launcher;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.BLOCKING_RPC_CLIENT2})
public class ASyncRPCSyncReceiveClient2Launcher extends ACustomCounterClient2Launcher{
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new ASyncRPCSyncReceiveFactorySetter());
		ACustomCounterClient.launch(CLIENT2_NAME);
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/syncrpc/test/asyncrpcsyncreceivefactorysetter.java
package inputport.rpc.duplex.syncreceive.syncrpc.test;

import examples.gipc.counter.customization.ACustomDuplexReceivedCallInvokerFactory;
import examples.gipc.counter.customization.ACustomSentCallCompleterFactory;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.test.ASyncReceiveFactorySetter;
import inputport.rpc.duplex.DuplexReceivedCallInvokerSelector;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingDuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingSyncReceiveSentCallCompleterCallFactory;
import inputport.rpc.duplex.syncreceive.ASyncReceiveSentCallCompleterCallFactory;
import inputport.rpc.duplex.syncreceive.AnAsynchronousProcedureSyncingDuplexReceivedCallInvokerFactory;

public class ASyncRPCSyncReceiveFactorySetter extends ASyncReceiveFactorySetter{
	@Override
	public void setFactories() {
		 super.setFactories();
			

		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(
					new AProcedureSyncingSyncReceiveSentCallCompleterCallFactory());
		DuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(
				new AnAsynchronousProcedureSyncingDuplexReceivedCallInvokerFactory());
		
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/syncrpc/test/asyncrpcsyncreceiveserverlauncher.java
package inputport.rpc.duplex.syncreceive.syncrpc.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterServer;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.BLOCKING_RPC_SERVER})
public class ASyncRPCSyncReceiveServerLauncher {
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new ASyncRPCSyncReceiveFactorySetter());
		ACustomCounterServer.launch();
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/syncrpc/test/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package inputport.rpc.duplex.syncreceive.syncrpc.test;
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/test/anrpcsyncreceiveclient1launcher.java
package inputport.rpc.duplex.syncreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient1Launcher;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.CUSTOM_RPC_CLIENT1})
public class AnRPCSyncReceiveClient1Launcher extends ACustomCounterClient1Launcher{
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new AnRPCSyncReceiveFactorySetter());
		ACustomCounterClient.launch(CLIENT1_NAME);
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/test/anrpcsyncreceiveclient2launcher.java
package inputport.rpc.duplex.syncreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterClient;
import examples.gipc.counter.customization.ACustomCounterClient2Launcher;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.CUSTOM_RPC_CLIENT2})
public class AnRPCSyncReceiveClient2Launcher extends ACustomCounterClient2Launcher{
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new AnRPCSyncReceiveFactorySetter());
		ACustomCounterClient.launch(CLIENT2_NAME);
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/test/anrpcsyncreceivefactorysetter.java
package inputport.rpc.duplex.syncreceive.test;

import examples.gipc.counter.customization.ACustomDuplexReceivedCallInvokerFactory;
import examples.gipc.counter.customization.ACustomSentCallCompleterFactory;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.duplex.object.explicitreceive.AnInheritingDuplexIObjectInputPortWithSyncReceiveFactory;
import inputport.datacomm.duplex.object.explicitreceive.test.ASyncReceiveFactorySetter;
import inputport.rpc.duplex.DuplexReceivedCallInvokerSelector;
import inputport.rpc.duplex.DuplexSentCallCompleterSelector;
import inputport.rpc.duplex.syncreceive.AProcedureSyncingDuplexReceivedCallInvokerFactory;
import inputport.rpc.duplex.syncreceive.ASyncReceiveSentCallCompleterCallFactory;

public class AnRPCSyncReceiveFactorySetter extends ASyncReceiveFactorySetter{
	@Override
	public void setFactories() {
		 super.setFactories();
			
//		DuplexReceivedCallInvokerSelector.setReceivedCallInvokerFactory(
//					new AProcedureSyncingDuplexReceivedCallInvokerFactory());	

		DuplexSentCallCompleterSelector.setDuplexSentCallCompleterFactory(
					new ASyncReceiveSentCallCompleterCallFactory());
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/test/anrpcsyncreceiveserverlauncher.java
package inputport.rpc.duplex.syncreceive.test;

import util.annotations.Comp533Tags;
import util.annotations.Tags;
import util.trace.port.objects.ObjectTraceUtility;
import util.trace.port.rpc.RPCTraceUtility;
import examples.gipc.counter.customization.ACustomCounterServer;
import examples.gipc.counter.customization.ATracingFactorySetter;
import examples.gipc.counter.customization.FactorySetterFactory;
@Tags({Comp533Tags.CUSTOM_RPC_SERVER})
public class AnRPCSyncReceiveServerLauncher {
	public static void main (String[] args) {
		ObjectTraceUtility.setTracing();
		RPCTraceUtility.setTracing();
		FactorySetterFactory.setSingleton(new AnRPCSyncReceiveFactorySetter());
		ACustomCounterServer.launch();
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/duplex/syncreceive/test/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package inputport.rpc.duplex.syncreceive.test;
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/agrouprpcserverinputportwithsyncreceive.java
package inputport.rpc.group.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;
import inputport.rpc.group.AGroupRPCServerInputPort;
import port.old.PrintingReplyingObjectReceiver;
import sessionport.rpc.duplex.relayed.example.Adder;
import sessionport.rpc.duplex.relayed.example.AnAdder;
import util.trace.Tracer;
import extraip.AGroupAdder;
import extraip.GroupAdder;





public class AGroupRPCServerInputPortWithSyncReceive extends AGroupRPCServerInputPort implements GroupRPCServerInputPortWithSyncReceive {
	GroupServerInputPortWithSyncReceive<Object> groupServerInputPortWithSyncReceive;
	public AGroupRPCServerInputPortWithSyncReceive(GroupServerInputPortWithSyncReceive<Object> aTypedGroupServerInputPort) {
		super(aTypedGroupServerInputPort);
		groupServerInputPortWithSyncReceive = aTypedGroupServerInputPort;
	}
//	@Override
//	protected GroupReturnerOfValueOfRemoteFunctionCall createWaitingGroupRPCFunctionHandler(LocalRemoteReferenceTranslator aRemoteHandler) {
//		return new AReceivingGroupRPCFunctionHandler(this, aRemoteHandler);
//	}	
	@Override
	public ReceiveReturnMessage<Object> receive(String source) {
		return groupServerInputPortWithSyncReceive.receive(source);
	}
	@Override
	public ReceiveReturnMessage<Object> receive() {
		return  groupServerInputPortWithSyncReceive.receive();
	}
	
	public static void main (String[] args) {
		Tracer.showInfo(true);
//		GroupRPCServerInputPort serverInputPort = new AGroupRPCServerInputPort("9090", "test server");
		GroupRPCServerInputPortWithSyncReceive serverInputPort = GroupRPCWithSyncReceiveInputPortSelector.createGroupRPCServerInputPortWithSyncReceive("9090", "test server");

		serverInputPort.connect();
		PrintingReplyingObjectReceiver messageReceiver = new PrintingReplyingObjectReceiver(serverInputPort);
//		RPCReceiver rpcServer = new RPCReceiver(serverInputPort);
		serverInputPort.addConnectionListener(messageReceiver);
//		serverInputPort.addDisconnectListener(messageReceiver);

//		serverInputPort.register(TypedReceiveListener.class, messageReceiver);
//		serverInputPort.register(RPCReceiver.class, rpcServer);
		Adder adder = new AnAdder();
		serverInputPort.register(Adder.class, adder);
		AGroupAdder groupAdder = new AGroupAdder(serverInputPort);
		serverInputPort.register(GroupAdder.class, groupAdder);
		//serverInputPort.addReceiveListener(echoingReceiveListener);	
		serverInputPort.addSendListener(messageReceiver);
	}
	
	
}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/agrouprpcwithsyncreceiveinputportfactory.java
package inputport.rpc.group.syncrcv;

import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;
import inputport.rpc.duplex.syncreceive.ADuplexRPCInputPortWithSyncReceiveFactory;
import sessionport.datacomm.group.object.syncrcv.ObjectGroupInputPortWithSyncReceiveSelector;

public class AGroupRPCWithSyncReceiveInputPortFactory  
      extends ADuplexRPCInputPortWithSyncReceiveFactory implements GroupRPCWithSyncReceiveInputPortFactory {



	@Override
	public GroupRPCServerInputPortWithSyncReceive createGroupRPCServerInputPortWithSyncReceive(String theServerId,
			String theServerName) {
		GroupServerInputPortWithSyncReceive<Object> typedServerInputPort = ObjectGroupInputPortWithSyncReceiveSelector.createGroupServerInputPortWithSyncReceive(theServerId, theServerName);
		GroupRPCServerInputPortWithSyncReceive rpcServerInputPort = new AGroupRPCServerInputPortWithSyncReceive(typedServerInputPort);
		return rpcServerInputPort;
	}
	

}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/areceivinggrouprpcfunctionhandler.java
package inputport.rpc.group.syncrcv;


import inputport.rpc.RemoteCall;
import inputport.rpc.duplex.DuplexRPCInputPort;
import inputport.rpc.duplex.LocalRemoteReferenceTranslator;
import inputport.rpc.duplex.syncreceive.ASyncReceiveSentCallCompleter;
import inputport.rpc.group.GroupArrayReturnerOfValueOfRemoteFunctionCall;

import java.io.Serializable;
import java.util.Set;


public class AReceivingGroupRPCFunctionHandler  extends ASyncReceiveSentCallCompleter
	implements GroupArrayReturnerOfValueOfRemoteFunctionCall {


	public AReceivingGroupRPCFunctionHandler(
			DuplexRPCInputPort  aReceiver, 
			LocalRemoteReferenceTranslator aRemoteHandler) {
		super(aReceiver, aRemoteHandler);
	
	}
	
	public Object[] returnValueOfRemoteFunctionCall(Set<String> clientNames, RemoteCall aSerializableCall) {
		Object[] retVal = new Serializable[clientNames.size()];
		if (clientNames.size() == 0) return  retVal;
		int i = 0;
		for (String clientName: clientNames) {
			try {
//				RPCReturnValue returnValue = receiveReturnValue(clientName);
				retVal[i] =  localRemoteReferenceTranslator.transformReceivedReference(receiveReturnValue(clientName));		
				i++;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}	
		return retVal;	
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/anrpcclientlauncher.java
package inputport.rpc.group.syncrcv;

import inputport.rpc.DirectedRPCProxyGenerator;
import inputport.rpc.duplex.syncreceive.DuplexRPCClientInputPortWithSyncReceive;
import inputport.rpc.duplex.syncreceive.DuplexRPCInputPortWithSyncReceiveSelector;
import port.old.PrintingTypedReceiveListener;
import sessionport.rpc.duplex.relayed.example.Adder;
import sessionport.rpc.duplex.relayed.example.AnAdder;
import util.trace.Tracer;
import extraip.GroupAdder;






public class AnRPCClientLauncher {
	public static void launchRPCClient(String clientName) {	
		Tracer.showInfo(true);
		DuplexRPCClientInputPortWithSyncReceive clientInputPort = DuplexRPCInputPortWithSyncReceiveSelector.createDuplexRPCClientInputPortWithSyncReceive("localhost", "9090", "Test Server", clientName);
		PrintingTypedReceiveListener messageReceiver = new PrintingTypedReceiveListener(clientInputPort);
		clientInputPort.addConnectionListener(messageReceiver);
//		clientInputPort.addDisconnectListener(messageReceiver);

		clientInputPort.register(messageReceiver.getClass(), messageReceiver);
		
		clientInputPort.addReceiveListener(messageReceiver);		
		clientInputPort.addSendListener(messageReceiver);
//		clientInputPort.register(TypedReceiveListener.class, messageReceiver);
		Adder adder = new AnAdder();
		clientInputPort.register(Adder.class, adder);

		clientInputPort.connect();
//		clientInputPort.send("hello server");
//		MessageWithSource receivedMessage = (MessageWithSource) clientInputPort.receive();
//		System.out.println(receivedMessage.getMessage());
		
//		ByteBuffer message =  ByteBuffer.wrap("hello server".getBytes());
//		System.out.println("String with padding:" + new String(message.array()));		
//		clientInputPort.send(message);
//		clientInputPort.send("hello from" + clientName);
		try {
//		Class[] parameterTypes = {String.class, Serializable.class};
//		Method typedMethod = TypedReceiveListener.class.getMethod("messageReceived", parameterTypes);
//		Method rpcMethod = RPCReceiver.class.getMethod("messageReceived", parameterTypes);
//		Serializable[] args = {clientName, "hello from " + clientName};
//		clientInputPort.call(typedMethod, args);
//		clientInputPort.call(RPCReceiver.class, rpcMethod, args);
//		Method groupAddMethod = GroupAdder.class.getMethod("messageReceived", parameterTypes);
//		clientInputPort.call(GroupAdder.class, groupAddMethod, args);
//		Integer[] args2 = { 5, 6};
//		Class[] parameterTypes2 = {Integer.class, Integer.class};
//		Method intAddMethod = Adder.class.getMethod("add", parameterTypes2);
////		Object retVal = clientInputPort.call(Adder.class, intAddMethod, args2);
//		Integer[] args3 = { 5, 6};
//		Class[] parameterTypes3 = {Integer.TYPE, Integer.TYPE};
//		Method intAddMethod2 = Adder.class.getMethod("add", parameterTypes2);
//		Object retVal2 = clientInputPort.call(Adder.class, intAddMethod, args2);
//		System.out.println(retVal2);
		GroupAdder groupAdderProxy = (GroupAdder) DirectedRPCProxyGenerator.generateRPCProxy(clientInputPort, null, GroupAdder.class, null);
		groupAdderProxy.groupSum(5, 6);
		Adder adderProxy = (Adder) DirectedRPCProxyGenerator.generateRPCProxy(clientInputPort, null, Adder.class, null);
		Object result = adderProxy.sum(5, 6);
		System.out.println("Result of adding:" + result);		
		} catch (Exception e) {
			e.printStackTrace();
		}
	}	
	
	
	public static void main (String[] args) {
		launchRPCClient("test client");
	}

}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/anrpcwithsyncreceivealicelauncher.java
package inputport.rpc.group.syncrcv;

public class AnRPCWithSyncReceiveAliceLauncher {
	public static void main (String[] args) {
		AnRPCClientLauncher.launchRPCClient("alice");
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/anrpcwithsyncreceiveboblauncher.java
package inputport.rpc.group.syncrcv;

public class AnRPCWithSyncReceiveBobLauncher {
	public static void main (String[] args) {
		AnRPCClientLauncher.launchRPCClient("bob");
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/anrpcwithsyncreceivecathylauncher.java
package inputport.rpc.group.syncrcv;

public class AnRPCWithSyncReceiveCathyLauncher {
	public static void main (String[] args) {
		AnRPCClientLauncher.launchRPCClient("cathy");
	}
}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/grouprpcserverinputportwithsyncreceive.java
package inputport.rpc.group.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceive;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitSourceReceive;
import inputport.rpc.group.GroupRPCServerInputPort;

public interface GroupRPCServerInputPortWithSyncReceive 
	extends GroupRPCServerInputPort, 
	ExplicitSourceReceive<Object>,
	ExplicitReceive<Object>{

}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/grouprpcwithsyncreceiveinputportfactory.java
package inputport.rpc.group.syncrcv;

import inputport.rpc.duplex.syncreceive.DuplexRPCClientInputPortWithSyncReceive;

public interface GroupRPCWithSyncReceiveInputPortFactory {
	public GroupRPCServerInputPortWithSyncReceive createGroupRPCServerInputPortWithSyncReceive(String theServerId, String theServerName);
	public DuplexRPCClientInputPortWithSyncReceive createDuplexRPCClientInputPortWithSyncReceive(String theServerHost, String theServerId, String theServerName, String theClientName);

}
//END OF FILE
//START OF FILE: src/inputport/rpc/group/syncrcv/grouprpcwithsyncreceiveinputportselector.java
package inputport.rpc.group.syncrcv;

import inputport.rpc.duplex.syncreceive.DuplexRPCClientInputPortWithSyncReceive;

public class GroupRPCWithSyncReceiveInputPortSelector {
	static GroupRPCWithSyncReceiveInputPortFactory inputPortFactory = new AGroupRPCWithSyncReceiveInputPortFactory();
	public static void setGroupRPCWithSyncReceiveInputPortFactory(GroupRPCWithSyncReceiveInputPortFactory theInputPortFactory) {
		inputPortFactory = theInputPortFactory;
	}
	
	public static GroupRPCServerInputPortWithSyncReceive createGroupRPCServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return inputPortFactory.createGroupRPCServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexRPCClientInputPortWithSyncReceive createDuplexRPCClientInputPortWithSyncReceive(String theServerHost, String theServerId, String theServerName, String theClientName) {
		return inputPortFactory.createDuplexRPCClientInputPortWithSyncReceive(theServerHost, theServerId, theServerName, theClientName);
	}
	
}
//END OF FILE
//START OF FILE: src/nio/client/rsphandler.java
package nio.client;
public class RspHandler {
	private byte[] rsp = null;	
	public synchronized boolean handleResponse(byte[] rsp) {
		this.rsp = rsp;
//		this.notify();
		return true;
	}	
//	public synchronized void waitForResponse() {
//		while(this.rsp == null) {
//			try {
//				this.wait();
//			} catch (InterruptedException e) {
//			}
//		}
//		
////		System.out.println(new String(this.rsp));
//	}
}

//END OF FILE
//START OF FILE: src/nio/client/trickortreatnioclient.java
package nio.client;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

//import port.trace.buffer.nio.SocketChannelConnectFinished;
//import port.trace.buffer.nio.SocketChannelConnectInitiated;
//import port.trace.buffer.nio.SocketChannelInterestOp;
//import port.trace.buffer.nio.SocketChannelRead;
//import port.trace.buffer.nio.SocketChannelRegistered;
//import port.trace.buffer.nio.SocketChannelWritten;
import common.client.ClientParameters;
import common.controller.TrickOrTreatClientControllerFactory;

//import niotut.RspHandler;

import main.BeauAndersonFinalProject;
import nio.common.ChangeRequest;
import nio.couplers.AnNIOSimulationInCoupler;
import nio.couplers.AnNIOSimulationOutCoupler;
import nio.couplers.NIOSimulationInCoupler;
import stringProcessors.HalloweenCommandProcessor;
import util.remote.ClientControllerFactory;
import util.remote.RelayerClientControllerFactory;
import util.trace.port.nio.SocketChannelConnectInitiated;
import util.trace.port.nio.SocketChannelConnected;
import util.trace.port.nio.SocketChannelInterestOp;
import util.trace.port.nio.SocketChannelRead;
import util.trace.port.nio.SocketChannelRegistered;
import util.trace.port.nio.SocketChannelWritten;

public class TrickOrTreatNioClient implements Runnable, ClientParameters {
	// The host:port combination to connect to
	public static final String SIMULATION1_PREFIX = "1:";
	public static final String SIMULATION2_PREFIX = "2:";
	public static final int SIMULATION_2_X_OFFSET = 250;
	public static final int SIMULATION_3_X_OFFSET = 500;

	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
	public static int SIMULATION_WIDTH = 400;
	public static int SIMULATION_HEIGHT = 765;
	SocketChannel socket;
	boolean sendUsingNIO;

//	private InetAddress hostAddress;
	private String host;
	private int port;

	// The selector we'll be monitoring
	private Selector selector;

	// The buffer into which we'll read data when it's available
	private ByteBuffer readBuffer = ByteBuffer.allocate(8192);

	// A list of PendingChange instances
	private List pendingChanges = new LinkedList();

	// Maps a SocketChannel to a list of ByteBuffer instances
	private Map pendingData = new HashMap();

	// Maps a SocketChannel to a RspHandler
	// private Map rspHandlers = Collections.synchronizedMap(new HashMap());
	NIOSimulationInCoupler simulationInCoupler;

//	public TrickOrTreatNioClient(InetAddress hostAddress, int port,
//			boolean aSendUsingNIO) throws IOException {
//		sendUsingNIO = aSendUsingNIO;
//		this.hostAddress = hostAddress;
//		this.port = port;
//		this.selector = this.initSelector();
//		// ClientControllerFactory.getOrCreateSingleton().setServerId(hostAddress.toString()
//		// + ": " + port);
//		String aFullServerId = hostAddress.toString() + ": " + port;
//		RelayerClientControllerFactory.getOrCreateSingleton().setServerId(
//				"" + port);
//		RelayerClientControllerFactory.getOrCreateSingleton().setServerHost(
//				hostAddress.toString());
//		RelayerClientControllerFactory.getOrCreateSingleton().setRelayerId(
//				aFullServerId);
//
//	}
	public TrickOrTreatNioClient(String aHost, int port,
			boolean aSendUsingNIO) throws IOException {
		sendUsingNIO = aSendUsingNIO;
		this.host = aHost;
		this.port = port;
		this.selector = this.initSelector();
		// ClientControllerFactory.getOrCreateSingleton().setServerId(hostAddress.toString()
		// + ": " + port);
		String aFullServerId = host + ": " + port;
//		RelayerClientControllerFactory.getOrCreateSingleton().setServerId(
//				"" + port);
		RelayerClientControllerFactory.getOrCreateSingleton().setServerHost(
				aHost);
//		RelayerClientControllerFactory.getOrCreateSingleton().setRelayerId(
//				aFullServerId);

	}

	public void send(byte[] data) throws IOException {
		// Start a new connection
		// SocketChannel socket = this.initiateConnection();

		// Register the response handler
		// this.rspHandlers.put(socket, handler);

		// And queue the data we want written
		synchronized (this.pendingData) {
			List queue = (List) this.pendingData.get(socket);
			if (queue == null) {
				queue = new ArrayList();
				this.pendingData.put(socket, queue);
			}
			queue.add(ByteBuffer.wrap(data));
		}
		SelectionKey aKey = socket.keyFor(selector);
		aKey.interestOps(SelectionKey.OP_WRITE);
//		socket.keyFor(selector).interestOps(SelectionKey.OP_WRITE);

		SocketChannelInterestOp.newCase(this, aKey, SelectionKey.OP_WRITE);


		// Finally, wake up our selecting thread so it can make the required
		// changes
		this.selector.wakeup();
	}

	public void run() {
		while (true) {
			try {
				// Process any pending changes
				synchronized (this.pendingChanges) {
					Iterator changes = this.pendingChanges.iterator();
					while (changes.hasNext()) {
						ChangeRequest change = (ChangeRequest) changes.next();
						switch (change.type) {
						case ChangeRequest.CHANGEOPS:
							SelectionKey key = change.socket
									.keyFor(this.selector);
							key.interestOps(change.ops);
							SocketChannelInterestOp.newCase(this, key, change.ops);

							break;
						case ChangeRequest.REGISTER:
							change.socket.register(this.selector, change.ops);
							SocketChannelRegistered.newCase(this, 
									socket, selector, change.ops);

							break;
						}
					}
					this.pendingChanges.clear();
				}

				// Wait for an event one of the registered channels
				this.selector.select();

				// Iterate over the set of keys for which events are available
				Iterator selectedKeys = this.selector.selectedKeys().iterator();
				while (selectedKeys.hasNext()) {
					SelectionKey key = (SelectionKey) selectedKeys.next();
					selectedKeys.remove();

					if (!key.isValid()) {
						continue;
					}

					// Check what event is available and deal with it
					if (key.isConnectable()) {
						this.finishConnection(key);
					} else if (key.isReadable()) {
						this.read(key);
					} else if (key.isWritable()) {
						this.write(key);
						
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private void read(SelectionKey key) throws IOException {
		SocketChannel socketChannel = (SocketChannel) key.channel();

		// Clear out our read buffer so it's ready for new data
		this.readBuffer.clear();

		// Attempt to read off the channel
		int numRead;
		try {
			numRead = socketChannel.read(this.readBuffer);
			SocketChannelRead.newCase(this, socketChannel, readBuffer, numRead);
		} catch (IOException e) {
			// The remote forcibly closed the connection, cancel
			// the selection key and close the channel.
			key.cancel();
			socketChannel.close();
			return;
		}

		if (numRead == -1) {
			// Remote entity shut the socket down cleanly. Do the
			// same from our end and cancel the channel.
			key.channel().close();
			key.cancel();
			return;
		}

		// Handle the response
		this.handleResponse(socketChannel, this.readBuffer.array(), numRead);
	}

	private void handleResponse(SocketChannel socketChannel, byte[] data,
			int numRead) throws IOException {
		// Make a correctly sized copy of the data before handing it
		// to the client
		byte[] rspData = new byte[numRead];
		System.arraycopy(data, 0, rspData, 0, numRead);

		// Look up the handler for this channel
		// RspHandler handler = (RspHandler)
		// this.rspHandlers.get(socketChannel);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton()
				.getSendReceiveSettings().maybeDelayReceive();

		simulationInCoupler.handleResponse(rspData);
		// And pass the response to it
		// if (handler.handleResponse(rspData)) {
		// // The handler has seen enough, close the connection
		// socketChannel.close();
		// socketChannel.keyFor(this.selector).cancel();
		// }
	}

	private void write(SelectionKey key) throws IOException {
		TrickOrTreatClientControllerFactory.getOrCreateSingleton()
				.getSendReceiveSettings().maybeDelaySend();

		SocketChannel socketChannel = (SocketChannel) key.channel();

		synchronized (this.pendingData) {
			List queue = (List) this.pendingData.get(socketChannel);

			// Write until there's not more data ...
			while (!queue.isEmpty()) {
				ByteBuffer buf = (ByteBuffer) queue.get(0);
				socketChannel.write(buf);
				SocketChannelWritten.newCase(this, socketChannel, buf);
				if (buf.remaining() > 0) {
					// ... or the socket's buffer fills up
					break;
				}
				queue.remove(0);
			}

			if (queue.isEmpty()) {
				// We wrote away all data, so we're no longer interested
				// in writing on this socket. Switch back to waiting for
				// data.
				key.interestOps(SelectionKey.OP_READ);
				SocketChannelInterestOp.newCase(this, key, SelectionKey.OP_READ);
			}
		}
	}

	HalloweenCommandProcessor commandProcessor;

	void createOutCoupler() {
		if (sendUsingNIO)
			new AnNIOSimulationOutCoupler(commandProcessor, this);
	}

	public void createUI(String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset) {
		HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject
				.createSimulation(aPrefix, anXOffset, aYOffset, aWidth,
						aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
		createUI(aCommandProcessor);
		// try {
		// commandProcessor = BeauAndersonFinalProject.createSimulation(
		// aPrefix, anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
		// aCommandWindowYOffset);
		// simulationInCoupler = new ASimulationInCoupler(commandProcessor);
		// socket = initiateConnection();
		// } catch (Exception e) {
		// e.printStackTrace();
		// }
	}

	public void createUI(HalloweenCommandProcessor aCommandProcessor) {
		try {
			commandProcessor = aCommandProcessor;
			simulationInCoupler = new AnNIOSimulationInCoupler(commandProcessor);
			socket = initiateConnection();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
    
	private void finishConnection(SelectionKey key) throws IOException {
		SocketChannel socketChannel = (SocketChannel) key.channel();

		// Finish the connection. If the ion operation failed
		// this will raise an IOException.
		try {
			socketChannel.finishConnect();
			createOutCoupler();
			// key.interestOps(ops)
			key.interestOps(SelectionKey.OP_READ);
			SocketChannelConnected.newCase(this, socketChannel, null);
			SocketChannelInterestOp.newCase(this, key, SelectionKey.OP_READ);


		} catch (IOException e) {
			// Cancel the channel's registration with our selector
			System.out.println(e);
			key.cancel();
			return;
		}

		// Register an interest in writing on this channel
		// key.interestOps(SelectionKey.OP_WRITE);
	}

	public SocketChannel initiateConnection() throws IOException {
		// Create a non-blocking socket channel
		SocketChannel socketChannel = SocketChannel.open();
		socketChannel.configureBlocking(false);
		String aHost = ClientControllerFactory.getOrCreateSingleton().getServerHost();
//		InetAddress aHostAddress = InetAddress.getByName(aHost);
		SocketAddress aSocketAddress = new InetSocketAddress(InetAddress.getByName(aHost), this.port);
		// Kick off connection establishment
		socketChannel
				.connect(
						aSocketAddress);
		SocketChannelConnectInitiated.newCase(this, socketChannel, aSocketAddress);		
		String aFullServerId = host + ": " + port;
		RelayerClientControllerFactory.getOrCreateSingleton().setServerId(
				"" + port);	
		RelayerClientControllerFactory.getOrCreateSingleton().setRelayerId(
				aFullServerId);


		// Queue a channel registration since the caller is not the
		// selecting thread. As part of the registration we'll register
		// an interest in connection events. These are raised when a channel
		// is ready to complete connection establishment.
		synchronized (this.pendingChanges) {
			this.pendingChanges.add(new ChangeRequest(socketChannel,
					ChangeRequest.REGISTER, SelectionKey.OP_CONNECT));
		}
		selector.wakeup();

		return socketChannel;
	}

	private Selector initSelector() throws IOException {
		// Create a new selector
		return SelectorProvider.provider().openSelector();
	}

	// public static void main(String[] args) {
	// try {
	// NioClient client = new NioClient(InetAddress.getByName("www.google.com"),
	// 80);
	// //NioClient client = new NioClient(InetAddress.getByName("localhost"),
	// 9090);
	// Thread t = new Thread(client);
	// t.setDaemon(true);
	// t.start();
	// RspHandler handler = new RspHandler();
	// client.send("GET / HTTP/1.0\r\n\r\n".getBytes(), handler);
	// handler.waitForResponse();
	// } catch (Exception e) {
	// e.printStackTrace();
	// }
	// }

	public static void launchClient(boolean aSendUsingNIO, String aPrefix,
			int anXOffset, int aYOffset, int aWidth, int aHeight,
			int aCommandWindowXOffset, int aCommandWindowYOffset) {
		try {
			HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject
					.createSimulation(aPrefix, anXOffset, aYOffset, aWidth,
							aHeight, aCommandWindowXOffset,
							aCommandWindowYOffset);
			launchClient(aCommandProcessor, aSendUsingNIO);

			// // String currentDir = System.getProperty("user.dir");
			// // System.out.println("Current dir using System:" +currentDir);
			//
			// TrickOrTreatNioClient client = new
			// TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
			// Thread t = new Thread(client);
			// t.setDaemon(true);
			// t.start();
			// // HalloweenCommandProcessor aCommandProcessor =
			// BeauAndersonFinalProject.createSimulation(
			// // SIMULATION2_PREFIX, 0,
			// TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET,
			// SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
			// client.createUI(aCommandProcessor);
			// // client.initiateConnection();
			// // RspHandler handler = new RspHandler();
			// // client.send("Hello World".getBytes(), handler);
			// // handler.waitForResponse();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void launchClient(
			HalloweenCommandProcessor aCommandProcessor, boolean aSendUsingNIO) {
		try {

			// String currentDir = System.getProperty("user.dir");
			// System.out.println("Current dir using System:" +currentDir);

//			TrickOrTreatNioClient client = new TrickOrTreatNioClient(
//					InetAddress.getByName(SERVER_HOST), 9090, aSendUsingNIO);
			TrickOrTreatNioClient client = new TrickOrTreatNioClient(
					SERVER_HOST, 9090, aSendUsingNIO);
			Thread t = new Thread(client);
			t.setName("NIO Client Selector");
			t.setDaemon(true);
			t.start();
			// HalloweenCommandProcessor aCommandProcessor =
			// BeauAndersonFinalProject.createSimulation(
			// SIMULATION2_PREFIX, 0,
			// TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET,
			// SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
			client.createUI(aCommandProcessor);
			// client.initiateConnection();
			// RspHandler handler = new RspHandler();
			// client.send("Hello World".getBytes(), handler);
			// handler.waitForResponse();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void main(String[] args) {
		// commandProcessor = BeauAndersonFinalProject.createSimulation(
		// "SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET,
		// SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);

		try {

			TrickOrTreatNioClient client = new TrickOrTreatNioClient(
					SERVER_HOST, 9090, true);
			Thread clientThread = new Thread(client);
			clientThread.setDaemon(true);
			clientThread.setName("NIO Client");
			clientThread.start();
			client.createUI(SIMULATION1_PREFIX, 0, SIMULATION_COMMAND_Y_OFFSET,
					SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
			// client.initiateConnection();
			// RspHandler handler = new RspHandler();
			// client.send("Hello World".getBytes(), handler);
			// handler.waitForResponse();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
//END OF FILE
//START OF FILE: src/nio/common/changerequest.java
package nio.common;
import java.nio.channels.SocketChannel;

public class ChangeRequest {
	public static final int REGISTER = 1;
	public static final int CHANGEOPS = 2;
	
	public SocketChannel socket;
	public int type;
	public int ops;
	
	public ChangeRequest(SocketChannel socket, int type, int ops) {
		this.socket = socket;
		this.type = type;
		this.ops = ops;
	}
}


//END OF FILE
//START OF FILE: src/nio/couplers/anniosimulationincoupler.java
package nio.couplers;

import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;
import util.trace.port.nio.RemoteCommandExecuted;

public class AnNIOSimulationInCoupler implements NIOSimulationInCoupler{
	HalloweenCommandProcessor commandProcessor;
	int numReceivedCommands = 0;
	public AnNIOSimulationInCoupler(HalloweenCommandProcessor aCommandProcessor) {
		commandProcessor = aCommandProcessor;
	}

	public synchronized void handleResponse(byte[] rsp) {
		String aCommand = new String(rsp);
		Tracer.info(this, numReceivedCommands + " received command:" + aCommand);
		String[] aCommands = aCommand.split(COMMAND_SEPARATOR);
		for (String anActualCommand:aCommands) {
//			commandProcessor.processCommand(new String(rsp))			
			commandProcessor.processCommand(anActualCommand);
			RemoteCommandExecuted.newCase(this, anActualCommand);
		}
		numReceivedCommands++;
//		System.out.println(new String(rsp));
		
	}

}
//END OF FILE
//START OF FILE: src/nio/couplers/anniosimulationoutcoupler.java
package nio.couplers;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;

import common.controller.TrickOrTreatClientControllerFactory;
import nio.client.TrickOrTreatNioClient;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;
import util.trace.port.nio.LocalCommandObserved;

public class AnNIOSimulationOutCoupler implements PropertyChangeListener {
	HalloweenCommandProcessor observingSimulation;
	TrickOrTreatNioClient client;
	int numSentCommands = 0;
	
	public AnNIOSimulationOutCoupler (HalloweenCommandProcessor anObservedSimulaton, TrickOrTreatNioClient aClient) {
		anObservedSimulaton.addPropertyChangeListener(this);
		client = aClient;
	}

	@Override
	public void propertyChange(PropertyChangeEvent anEvent) {
		if (!anEvent.getPropertyName().equals("InputString")) return;
		String newCommand = (String) anEvent.getNewValue();
		LocalCommandObserved.newCase(this, newCommand);

		try {
			Tracer.info(this, numSentCommands + " Sending command:" + newCommand);
			String markedCommand = newCommand + NIOSimulationInCoupler.COMMAND_SEPARATOR;
			if (TrickOrTreatClientControllerFactory.getOrCreateSingleton().isMarkCommands())
			client.send(markedCommand.getBytes());
			else client.send(newCommand.getBytes());
			numSentCommands++;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		System.out.println("Received command:" + newCommand);
//		observingSimulation.processCommand(newCommand);
	}

	

}
//END OF FILE
//START OF FILE: src/nio/couplers/niosimulationincoupler.java
package nio.couplers;

public interface NIOSimulationInCoupler {
	String COMMAND_SEPARATOR = ",";
	public  void handleResponse(byte[] rsp);

}
//END OF FILE
//START OF FILE: src/nio/launcher/alicetrickortreatnioclient.java
package nio.launcher;

import java.nio.channels.SocketChannel;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import nio.client.TrickOrTreatNioClient;
import nio.couplers.AnNIOSimulationInCoupler;
import nio.couplers.AnNIOSimulationOutCoupler;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Traceable;
import util.trace.TraceableInfo;
import util.trace.Tracer;



public class AliceTrickOrTreatNioClient implements AliceUI {
	// The host:port combination to connect to
//	public static final String SIMULATION1_PREFIX = "1:";
//
//	public static final String ALICE_NAME = "Alice:";
//	public static final String SIMULATION2_PREFIX = "2:";
//	public static final int NUM_MOVES = 250;
//	public static  final int COUPLED_SIMULATION_X_OFFSET = 250;
//	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
//	public static int SIMULATION_WIDTH = 400;
//	public static int SIMULATION_HEIGHT = 765;
	SocketChannel socket; 



//	public static void main(String[] args) {
////		commandProcessor = BeauAndersonFinalProject.createSimulation(
////				"SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//		
//	    try {
////	    	String currentDir = System.getProperty("user.dir");
////	        System.out.println("Current dir using System:" +currentDir);
//	    	
//	      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//	      Thread t = new Thread(client);
//	      t.setDaemon(true);
//	      t.start();
//	      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//	    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	      client.createUI(aCommandProcessor);
////	      client.initiateConnection();
////	      RspHandler handler = new RspHandler();
////	      client.send("Hello World".getBytes(), handler);
////	      handler.waitForResponse();
//	    } catch (Exception e) {
//	      e.printStackTrace();
//	    }
//	  
//	  }
//}
public static void main(String[] args) {
	Tracer.showWarnings(false);
	Tracer.showInfo(true);
	Tracer.setDisplayThreadName(true);
	TraceableInfo.setPrintTraceable(true);
	Traceable.setPrintThread(true);
	TraceableInfo.setPrintTime(true);
	Tracer.setKeywordPrintStatus(TrickOrTreatNioClient.class, true);
	Tracer.setKeywordPrintStatus(AnNIOSimulationOutCoupler.class, true);
	Tracer.setKeywordPrintStatus(AnNIOSimulationInCoupler.class, true);
	

//	HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//			SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//	HalloweenCommandProcessor 
	OEFrame oeFrame = AliceControllerUI.createUI();

	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	TrickOrTreatNioClient.launchClient(aCommandProcessor, true);
//	ClearanceManager clearanceManager = ClearanceManagerFactory.getOrCreateClearanceManager();
//	
//	OEFrame clearanceFrame = ObjectEditor.edit(clearanceManager);
//	
//	clearanceFrame.setLocation(700, 500);
//	OEFrame settingsFrame = ObjectEditor.edit(SendReceiveSettingsFactory.getOrCreateSettings());
//	settingsFrame.setLocation(900,  500);
//	TrickOrTreatClientController aController = TrickOrTreatClientControllerFactory.getOrCreateSingleton();
//	OEFrame controllerFrame = ObjectEditor.edit(aController);
//	controllerFrame.setLocation(700, 500);	
//	Tracer.showWarnings(false);
//	Tracer.showInfo(true);
//	Tracer.setKeywordPrintStatus(AnNIOSimulationInCoupler.class, true);
//	Tracer.setKeywordPrintStatus(AnNIOSimulationOutCoupler.class, true);
//	Tracer.setKeywordPrintStatus(Tracer.ALL_KEYWORDS, true);

	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();

//	ClearanceManagerFactory.getOrCreateClearanceManager().waitForClearance();
	
	
//	long startTime = System.currentTimeMillis();
////	System.out.println("start time" + System.currentTimeMillis());
////	aCommandProcessor.processCommand("move 50 -50");
////	System.out.println("end time after one command" + System.currentTimeMillis());
//	for (int i=0; i < NUM_MOVES; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 1 0");
//
//
//	}
//	for (int i=0; i < NUM_MOVES; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 0 -1");
//
//
//	}
//	long endTime = System.currentTimeMillis();
//
//	System.out.println("Loop execution time:" + (endTime - startTime));



  }
}

//END OF FILE
//START OF FILE: src/nio/launcher/bobtrickortreatnioclient.java
package nio.launcher;

import java.nio.channels.SocketChannel;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import nio.client.TrickOrTreatNioClient;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobTrickOrTreatNioClient  implements BobUI{
	// The host:port combination to connect to
//	public static final String SIMULATION1_PREFIX = "1:";

//	public static final String ALICE_PREFIX = "Bob:";
//	public static final String SIMULATION2_PREFIX = "2:";
//	public static  final int COUPLED_SIMULATION_X_OFFSET = 250;
//	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
//	public static int SIMULATION_WIDTH = 400;
//	public static int SIMULATION_HEIGHT = 765;
	SocketChannel socket; 



	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(false);
		OEFrame oeFrame = BobControllerUI.createUI();
		HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
		TrickOrTreatNioClient.launchClient(aCommandProcessor, true);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();

//		Tracer.setKeywordPrintStatus(AnNIOSimulationInCoupler.class, true);
//		Tracer.setKeywordPrintStatus(AnNIOSimulationOutCoupler.class, true);
//		HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//				SIMULATION1_PREFIX, SIMULATION_COMMAND_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
//		TrickOrTreatNioClient.launchClient( SIMULATION1_PREFIX, TrickOrTreatNioClient.SIMULATION_2_X_OFFSET, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, TrickOrTreatNioClient.SIMULATION_2_X_OFFSET, 0);
//		TrickOrTreatNioClient.launchClient( aCommandProcessor, true);

////		commandProcessor = BeauAndersonFinalProject.createSimulation(
////				"SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//		
//	    try {
//	    		
//	    	
//	      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//	      Thread t = new Thread(client);
//	      t.setDaemon(true);
//	      t.start();
//	      client.createUI(SIMULATION1_PREFIX, TrickOrTreatNioClient.SIMULATION_2_X_OFFSET, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, TrickOrTreatNioClient.SIMULATION_2_X_OFFSET, 0);
////	      client.initiateConnection();
////	      RspHandler handler = new RspHandler();
////	      client.send("Hello World".getBytes(), handler);
////	      handler.waitForResponse();
//	    } catch (Exception e) {
//	      e.printStackTrace();
//	    }
//	  
	  }
}

//END OF FILE
//START OF FILE: src/nio/launcher/cathytrickortreatnioclient.java
package nio.launcher;

import java.nio.channels.SocketChannel;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import nio.client.TrickOrTreatNioClient;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathyTrickOrTreatNioClient  implements CathyUI {
	// The host:port combination to connect to
	public static final String SIMULATION1_PREFIX = "1:";
//
//	public static final String ALICE_PREFIX = "Cathy:";
//	public static final String SIMULATION2_PREFIX = "2:";
//	public static  final int COUPLED_SIMULATION_X_OFFSET = 350;
//	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
//	public static int SIMULATION_WIDTH = 400;
//	public static int SIMULATION_HEIGHT = 765;
	SocketChannel socket; 



	public static void main(String[] args) {
		Tracer.showWarnings(false);
		Tracer.showInfo(true);
		OEFrame oeFrame = CathyControllerUI.createUI();


		HalloweenCommandProcessor aCommandProcessor = CathyCommandProcessorFactory.getOrCreateSingleton();

		TrickOrTreatNioClient.launchClient( aCommandProcessor, true);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();



	  }
}

//END OF FILE
//START OF FILE: src/nio/launcher/interactivedemoerofniotrickortreat.java
package nio.launcher;


public class InteractiveDemoerOfNIOTrickOrTreat {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				TrickOrTreatNioRelayingServerLauncher.class,
				AliceTrickOrTreatNioClient.class,
				BobTrickOrTreatNioClient.class,
				CathyTrickOrTreatNioClient.class

				
		};
//		MainClassLaunchingUtility.interactiveLaunch(classes);
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/nio/launcher/trickortreatniorelayingserverlauncher.java
package nio.launcher;
import java.io.IOException;

import common.controller.ServerControllerUI;
import nio.server.ServerWorker;
import nio.server.SimulationNioRelayer;
import util.trace.Tracer;


public class TrickOrTreatNioRelayingServerLauncher  {
//	// The host:port combination to listen on
//	private InetAddress hostAddress;
//	private int port;
//
//	// The channel on which we'll accept connections
//	private ServerSocketChannel serverChannel;
//
//	// The selector we'll be monitoring
//	private Selector selector;
//
//	// The buffer into which we'll read data when it's available
//	private ByteBuffer readBuffer = ByteBuffer.allocate(8192);
//
//	private ServerWorker worker;
//
//	// A list of PendingChange instances
//	private List pendingChanges = new LinkedList();
//
//	// Maps a SocketChannel to a list of ByteBuffer instances
//	private Map pendingData = new HashMap();
//	
//	List<SocketChannel> allClients = new ArrayList();
//
//	public TrickOrTreatNioRelayingSerrverLauncher(InetAddress hostAddress, int port, ServerWorker worker) throws IOException {
//		this.hostAddress = hostAddress;
//		this.port = port;
//		this.selector = this.initSelector();
//		this.worker = worker;
//	}
//
//	public void send(SocketChannel socket, byte[] data) {
//		synchronized (this.pendingChanges) {
//			// Indicate we want the interest ops set changed
//			this.pendingChanges.add(new ChangeRequest(socket, ChangeRequest.CHANGEOPS, SelectionKey.OP_WRITE));
//
//			// And queue the data we want written
//			synchronized (this.pendingData) {
//				List queue = (List) this.pendingData.get(socket);
//				if (queue == null) {
//					queue = new ArrayList();
//					this.pendingData.put(socket, queue);
//				}
//				queue.add(ByteBuffer.wrap(data));
//			}
//		}
//
//		// Finally, wake up our selecting thread so it can make the required changes
//		this.selector.wakeup();
//	}
//
//	public void run() {
//		while (true) {
//			try {
//				// Process any pending changes
//				synchronized (this.pendingChanges) {
//					Iterator changes = this.pendingChanges.iterator();
//					while (changes.hasNext()) {
//						ChangeRequest change = (ChangeRequest) changes.next();
//						switch (change.type) {
//						case ChangeRequest.CHANGEOPS:
//							SelectionKey key = change.socket.keyFor(this.selector);
//							key.interestOps(change.ops);
//						}
//					}
//					this.pendingChanges.clear();
//				}
//
//				// Wait for an event one of the registered channels
//				this.selector.select();
//
//				// Iterate over the set of keys for which events are available
//				Iterator selectedKeys = this.selector.selectedKeys().iterator();
//				while (selectedKeys.hasNext()) {
//					SelectionKey key = (SelectionKey) selectedKeys.next();
//					selectedKeys.remove();
//
//					if (!key.isValid()) {
//						continue;
//					}
//
//					// Check what event is available and deal with it
//					if (key.isAcceptable()) {
//						this.accept(key);
//					} else if (key.isReadable()) {
//						this.read(key);
//					} else if (key.isWritable()) {
//						this.write(key);
//					}
//				}
//			} catch (Exception e) {
//				e.printStackTrace();
//			}
//		}
//	}
//
//	private void accept(SelectionKey key) throws IOException {
//		// For an accept to be pending the channel must be a server socket channel.
//		ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
//
//		// Accept the connection and make it non-blocking
//		SocketChannel socketChannel = serverSocketChannel.accept();
//		Socket socket = socketChannel.socket();
//		socketChannel.configureBlocking(false);
//		allClients.add(socketChannel);
//		RelayerControllerFactory.getOrCreateSingleton().setClients(allClients.toString());
//
//		// Register the new SocketChannel with our Selector, indicating
//		// we'd like to be notified when there's data waiting to be read
//		socketChannel.register(this.selector, SelectionKey.OP_READ);
//	}
//
//	private void read(SelectionKey key) throws IOException {
//		SocketChannel socketChannel = (SocketChannel) key.channel();
//
//		// Clear out our read buffer so it's ready for new data
//		this.readBuffer.clear();
//
//		// Attempt to read off the channel
//		int numRead;
//		try {
//			numRead = socketChannel.read(this.readBuffer);
//		} catch (IOException e) {
//			// The remote forcibly closed the connection, cancel
//			// the selection key and close the channel.
//			key.cancel();
//			socketChannel.close();
//			return;
//		}
//
//		if (numRead == -1) {
//			// Remote entity shut the socket down cleanly. Do the
//			// same from our end and cancel the channel.
//			key.channel().close();
//			key.cancel();
//			return;
//		}
//
//		// Hand the data off to our worker thread
//		this.worker.processData(this, socketChannel, this.readBuffer.array(), numRead);
//	}
//
//	public List<SocketChannel> getAllClients() {
//		return allClients;
//	}
//	private void write(SelectionKey key) throws IOException {
//		SocketChannel socketChannel = (SocketChannel) key.channel();
//		TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend();
//
//		synchronized (this.pendingData) {
//			List queue = (List) this.pendingData.get(socketChannel);
//
//			// Write until there's not more data ...
//			while (!queue.isEmpty()) {
//				ByteBuffer buf = (ByteBuffer) queue.get(0);
//				socketChannel.write(buf);
//				if (buf.remaining() > 0) {
//					// ... or the socket's buffer fills up
//					break;
//				}
//				queue.remove(0);
//			}
//
//			if (queue.isEmpty()) {
//				// We wrote away all data, so we're no longer interested
//				// in writing on this socket. Switch back to waiting for
//				// data.
//				key.interestOps(SelectionKey.OP_READ);
//			}
//		}
//	}
//
//	private Selector initSelector() throws IOException {
//		// Create a new selector
//		Selector socketSelector = SelectorProvider.provider().openSelector();
//
//		// Create a new non-blocking server socket channel
//		this.serverChannel = ServerSocketChannel.open();
//		serverChannel.configureBlocking(false);
//
//		// Bind the server socket to the specified address and port
//		InetSocketAddress isa = new InetSocketAddress(this.hostAddress, this.port);
//		serverChannel.socket().bind(isa);
//
//		// Register the server socket channel, indicating an interest in 
//		// accepting new connections
//		serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);
//
//		return socketSelector;
//	}

	public static void main(String[] args) {
		try {
			Tracer.showWarnings(false);
//			Tracer.setKeywordPrintStatus(ServerWorker.class, true);
			ServerWorker worker = new ServerWorker();
			Thread workerThread = new Thread(worker);
			workerThread.setName("Worker");
			workerThread.start();
			Thread serverThread = new Thread(new SimulationNioRelayer(null, 9090, worker));
			serverThread.setName("NIO Sever");
			serverThread.start();
//			OEFrame relayerControllerFrame = ObjectEditor.edit(RelayerControllerFactory.getOrCreateSingleton());
//			relayerControllerFrame.setLocation(900, 500);
			ServerControllerUI.createUI();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/aliceniomanagersimulationclient.java
package nio.manager.simulation;

import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION1_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import assignments.util.mainArgs.ServerPort;
import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import util.trace.port.nio.NIOTraceUtility;

public class AliceNIOManagerSimulationClient  {
	public static void main(String[] args) {
		NIOTraceUtility.setTracing();
//		MiscAssignmentUtils.setHeadless(true);
		AnNIOManagerSimulationClient.launchClient(ClientArgsProcessor.getServerHost(args), ServerPort.SERVER_PORT,
				"Alice", SIMULATION1_PREFIX, 0, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0 );
	}

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/bobniomanagersimulationclient.java
package nio.manager.simulation;

import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION2_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_2_X_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;

import assignments.util.mainArgs.ClientArgsProcessor;
import assignments.util.mainArgs.ServerPort;
import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import util.trace.port.nio.NIOTraceUtility;

public class BobNIOManagerSimulationClient  {
	public static void main(String[] args) {
		NIOTraceUtility.setTracing();
		AnNIOManagerSimulationClient.launchClient(ClientArgsProcessor.getServerHost(args), ServerPort.SERVER_PORT,
				"Bob", SIMULATION2_PREFIX, SIMULATION_2_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_2_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET );
	}

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/cathyniomanagersimulationclient.java
package nio.manager.simulation;

import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION3_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_3_X_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;

import assignments.util.mainArgs.ClientArgsProcessor;
import assignments.util.mainArgs.ServerPort;
import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import util.trace.port.nio.NIOTraceUtility;

public class CathyNIOManagerSimulationClient  {
	public static void main(String[] args) {
		NIOTraceUtility.setTracing();
		AnNIOManagerSimulationClient.launchClient(ClientArgsProcessor.getServerHost(args), ServerPort.SERVER_PORT,
				"Cathy", SIMULATION3_PREFIX, SIMULATION_3_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_3_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET );
	}

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/niomanagersimulationserverlauncher.java
package nio.manager.simulation;

import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
@Tags({DistributedTags.SERVER})
public class NIOManagerSimulationServerLauncher {
	public static void main(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		AnNIOManagerSimulationServer.launch(args);
	}

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/anniomanagerlocalsimulation.java
package nio.manager.simulation.client;

import main.BeauAndersonFinalProject;
import stringProcessors.HalloweenCommandProcessor;

public class AnNIOManagerLocalSimulation implements NIOManagerSimulationProcessor{
	public static final String SIMULATION1_PREFIX = "1:";
//	public static final String SIMULATION2_PREFIX = "2:";
//	public static final int SIMULATION_2_X_OFFSET = 250;
//	public static final int SIMULATION_3_X_OFFSET = 500;

	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
	public static int SIMULATION_WIDTH = 400;
	public static int SIMULATION_HEIGHT = 765;
	HalloweenCommandProcessor commandProcessor;
//	protected NIOSimulationInCoupler nioManagerSimulationInCoupler;
	@Override
	public void run() {
		
		createUI();
	}
	public void createUI(HalloweenCommandProcessor aCommandProcessor) {
		try {
			commandProcessor = aCommandProcessor;
//			nioManagerSimulationInCoupler = new AnNIOManagerSimulationInCoupler(commandProcessor);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public void createUI(String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset) {
		HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject
				.createSimulation(aPrefix, anXOffset, aYOffset, aWidth,
						aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
		createUI(aCommandProcessor);
	
	}
	public void createUI(){
		
	}
	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/anniomanagersimulationclient.java
package nio.manager.simulation.client;

import java.io.IOException;
import java.net.InetAddress;
import java.nio.channels.SocketChannel;

import assignments.util.MiscAssignmentUtils;
import assignments.util.inputParameters.AnAbstractSimulationParametersBean;
import assignments.util.mainArgs.ClientArgsProcessor;
import assignments.util.mainArgs.ServerPort;
import inputport.nio.manager.NIOManagerFactory;
import inputport.nio.manager.factories.classes.AReadingWritingConnectCommandFactory;
import inputport.nio.manager.factories.selectors.ConnectCommandFactorySelector;
import main.BeauAndersonFinalProject;
import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import stringProcessors.HalloweenCommandProcessor;
import util.annotations.Tags;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.PerformanceExperimentEnded;
import util.trace.port.PerformanceExperimentStarted;
import util.trace.port.nio.NIOTraceUtility;
@Tags({DistributedTags.CLIENT})
public class AnNIOManagerSimulationClient extends AnAbstractSimulationParametersBean implements NIOManagerSimulationClient {
	protected String clientName;
	public static final String SIMULATION1_PREFIX = "1:";
	public static final String SIMULATION2_PREFIX = "2:";
	public static final String SIMULATION3_PREFIX = "3:";
	public static final int SIMULATION_2_X_OFFSET = 250;
	public static final int SIMULATION_3_X_OFFSET = 500;
	public static int SIMULATION_COMMAND_Y_OFFSET = 0;
	public static int SIMULATION_WIDTH = 400;
	public static int SIMULATION_HEIGHT = 765;
	protected HalloweenCommandProcessor commandProcessor;
	protected NIOManagerSimulationInCoupler nioManagerSimulationInCoupler;
	protected NIOManagerSimulationOutCoupler nioSimulationOutCoupler;
	protected int NUM_EXPERIMENT_COMMANDS = 500;
	public static final String EXPERIMENT_COMMAND_1 = "move 1 -1";
	public static final String EXPERIMENT_COMMAND_2 = "undo";
	SocketChannel socketChannel;
//	boolean localProcessingOnly = false;

	public AnNIOManagerSimulationClient() {
		
//		clientName = aClientName;
		
	}

	protected void setFactories() {
		ConnectCommandFactorySelector
				.setFactory(new AReadingWritingConnectCommandFactory());

	}

	protected SocketChannel createSocketChannel() {
		try {
			SocketChannel retVal = SocketChannel.open();
			return retVal;

		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	public void connectToServer(String aServerHost, int aServerPort) {
		try {
			InetAddress aServerAddress = InetAddress.getByName(aServerHost);

			NIOManagerFactory.getSingleton().connect(socketChannel,
					aServerAddress, aServerPort, this);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// public void createUI(HalloweenCommandProcessor aCommandProcessor) {
	// try {
	// commandProcessor = aCommandProcessor;
	//
	// } catch (Exception e) {
	// e.printStackTrace();
	// }
	// }

	// public void createUI(String aPrefix, int anXOffset, int aYOffset,
	// int aWidth, int aHeight, int aCommandWindowXOffset,
	// int aCommandWindowYOffset) {
	// HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject
	// .createSimulation(aPrefix, anXOffset, aYOffset, aWidth,
	// aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
	// createUI(aCommandProcessor);
	// // try {
	// // commandProcessor = BeauAndersonFinalProject.createSimulation(
	// // aPrefix, anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
	// // aCommandWindowYOffset);
	// // simulationInCoupler = new ASimulationInCoupler(commandProcessor);
	// // socket = initiateConnection();
	// // } catch (Exception e) {
	// // e.printStackTrace();
	// // }
	// }
	protected void createCommunicationObjects(SocketChannel aSocketChannel) {
		nioSimulationOutCoupler = new AnNIOManagerSimulationClientOutCoupler(
				aSocketChannel);
		nioManagerSimulationInCoupler = new AnNIOManagerSimulationClientInCoupler(
				commandProcessor);
		Thread aThread = new Thread(nioManagerSimulationInCoupler);
		aThread.setName(AnNIOManagerSimulationServer.READ_THREAD_NAME);
		aThread.start();

	}

	protected void addListeners(SocketChannel aSocketChannel) {
		// nioSimulationOutCoupler = new
		// AnNIOManagerSimulationOutCoupler(aSocketChannel);
		commandProcessor.addPropertyChangeListener(nioSimulationOutCoupler);
		// nioManagerSimulationInCoupler = new AnNIOManagerSimulationInCoupler(
		// commandProcessor);
		NIOManagerFactory.getSingleton().addReadListener(aSocketChannel,
				nioManagerSimulationInCoupler);

//		addWriteBufferListener(aSocketChannel);
	}

	public void connected(SocketChannel aSocketChannel) {
		// createCommunicationObjects(aSocketChannel);
		// addListeners(aSocketChannel);
		//
		// nioSimulationOutCoupler = new
		// AnNIOManagerSimulationOutCoupler(aSocketChannel);
		// commandProcessor.addPropertyChangeListener(nioSimulationOutCoupler);
		//
		// NIOManagerFactory.getSingleton().addReadListener(aSocketChannel,
		// nioManagerSimulationInCoupler);
	}

	@Override
	public void notConnected(SocketChannel theSocketChannel, Exception e) {

	}

	@Override
	public void createModelAndUI(String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset) {
		commandProcessor = BeauAndersonFinalProject.createSimulation(aPrefix,
				anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
				aCommandWindowYOffset);
	}

	@Override
	public void initialize(String aServerHost, int aServerPort,
			String aClientName, String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset) {
		clientName = aClientName;
		setFactories();
		createModelAndUI(aPrefix, anXOffset, aYOffset, aWidth, aHeight,
				aCommandWindowXOffset, aCommandWindowYOffset);
		socketChannel = createSocketChannel();
		createCommunicationObjects(socketChannel);
		addListeners(socketChannel);
		connectToServer(aServerHost, aServerPort);
		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);
	}
	public void processCommands() {
		SimulationParametersControllerFactory.getSingleton().processCommands();		
	}

	protected void addWriteBufferListener(SocketChannel aSocketChannel) {
		NIOManagerFactory.getSingleton().addWriteBoundedBufferListener(
				aSocketChannel, this);
	}

	@Override
	public void writeBufferIsEmpty(SocketChannel aSocketChannel) {
		NIOManagerFactory.getSingleton().enableReads(aSocketChannel);
	}
	
//	public void setAtomicBroadcast(boolean newValue) {
//		super.setAtomicBroadcast(newValue)
//	}
	
	@Override
	public void atomicBroadcast(boolean newValue) {
		super.setAtomicBroadcast(newValue);
		commandProcessor.setConnectedToSimulation(!isAtomicBroadcast());
	}
//	@Override
//	public void setIPCMechanism(IPCMechanism newValue) {
//		ipcMechanism = newValue;
//	}
//
//	@Override
//	public void setAtomicBroadcast(boolean newValue) {
//		commandProcessor.setConnectedToSimulation(!newValue);
//
//		
//	}
//	
//	protected IPCMechanism ipcMechanism = IPCMechanism.NIO;
//	@Override
//	public IPCMechanism getIPCMechanism() {
//		return ipcMechanism;
//	}
//	@Override
//	public void ipcMechanism(IPCMechanism newValue) {
//		setIPCMechanism(newValue);
//	}

	@Override
	public void experimentInput() {
		Tracer.showInfo(false);
		long aStartTime = System.currentTimeMillis();
		PerformanceExperimentStarted.newCase(this, aStartTime, NUM_EXPERIMENT_COMMANDS);
		for (int i = 0; i < NUM_EXPERIMENT_COMMANDS; i++) {
			commandProcessor.setInputString(EXPERIMENT_COMMAND_1);
			commandProcessor.setInputString(EXPERIMENT_COMMAND_2);
		}
		Tracer.showInfo(true);
		long anEndTime = System.currentTimeMillis();
		PerformanceExperimentEnded.newCase(this, aStartTime, anEndTime, anEndTime - aStartTime, NUM_EXPERIMENT_COMMANDS);
//		System.out.println("Elapsed time:" + (System.currentTimeMillis() - aStartTime));

	}

//	@Override
//	public void broadcastBroadcastMode(boolean newValue) {
//		super.broadcastBroadcastMode(newValue);
//
//	}

//	@Override
//	public void waitForBroadcastConsensus(boolean newValue) {
//		super.waitForBroadcastConsensus(newValue);
//
//	}
//
//	@Override
//	public void broadcastIPCMechanism(boolean newValue) {
//		// TODO Auto-generated method stub
//
//	}
//
//	@Override
//	public void waitForIPCMechanismConsensus(boolean newValue) {
//		// TODO Auto-generated method stub
//
//	}

//	@Override
//	public void consensusAlgorithm(ConsensusAlgorithm newValue) {
//		// TODO Auto-generated method stub
//
//	}
//	protected boolean localProcessingOnly;
//	@Override
//	public boolean isLocalProcessingOnly() {
//		return localProcessingOnly;
//	}
////	@Override
//	public void localProcessingOnly(boolean newValue) {
//		localProcessingOnly = newValue;
//		nioSimulationOutCoupler.localProcessingOnly(newValue);
//		
//	}
//	@Override
//	public boolean isLocalProcessingOnly() {
//		return localProcessingOnly;
//	}
//	@Override
//	public void setLocalProcessingOnly(boolean localProcessingOnly) {
//		nioSimulationOutCoupler.localProcessingOnly(localProcessingOnly);
//	}
//	

	@Override
	public void quit(int aCode) {
		try {
			socketChannel.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.exit(aCode);
	}

	@Override
	public void simulationCommand(String aCommand) {
		commandProcessor.setInputString(aCommand);
	}
	
	protected static NIOManagerSimulationClient nioManagerClient;
	public static NIOManagerSimulationClient getNIOManagerSimulationClient() {
		return nioManagerClient;
	}
	public static void launchClient(String aServerHost, int aServerPort,
			String aClientName, String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset) {
		NIOManagerSimulationClient aClient = new AnNIOManagerSimulationClient();
		nioManagerClient = aClient;
		aClient.initialize(aServerHost, aServerPort, aClientName, aPrefix,
				anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
				aCommandWindowYOffset);
		aClient.processCommands();
		// aClient.createModelAndUI(aPrefix, anXOffset, aYOffset, aWidth,
		// aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
		// aClient.connectToServer(aServerHost, aServerPort);

	}
	
	public static void main(String[] args) {
//		NIOTraceUtility.setTracing();
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(true);
		args = ClientArgsProcessor.removeEmpty(args);
		launchClient(ClientArgsProcessor.getServerHost(args),
				ClientArgsProcessor.getServerPort(args),
				ClientArgsProcessor.getClientName(args), SIMULATION1_PREFIX, 0,
				SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH,
				SIMULATION_HEIGHT, 0, 0);
	}

	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/anniomanagersimulationclientincoupler.java
package nio.manager.simulation.client;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import nio.manager.simulation.common.AChannelByteBuffer;
import nio.manager.simulation.common.ChannelByteBuffer;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.port.nio.RemoteCommandExecuted;

public class AnNIOManagerSimulationClientInCoupler implements NIOManagerSimulationInCoupler{
	HalloweenCommandProcessor commandProcessor;
	int numReceivedCommands = 0;
	public static int MAX_QUEUE_SIZE = 2000;
	BlockingQueue<ChannelByteBuffer> messageQueue = new ArrayBlockingQueue<>(MAX_QUEUE_SIZE);
	public AnNIOManagerSimulationClientInCoupler(HalloweenCommandProcessor aCommandProcessor) {
		commandProcessor = aCommandProcessor;
	}


	@Override
	public void socketChannelRead(SocketChannel aSocketChannel,
			ByteBuffer aMessage, int aLength) {
		if (messageQueue.size() >= MAX_QUEUE_SIZE) {
			System.err.println("Message queue full, ignoring message");
			return;
		}
		messageQueue.add(new AChannelByteBuffer(aSocketChannel, aMessage));
//		doRead(aSocketChannel, aMessage);
//		 String aCommand = new String(aMessage.array(), aMessage.position(), aLength);
//		 RemoteCommandExecuted.newCase(this, aCommand);
//		 commandProcessor.processCommand(aCommand); // make this is a thread
	}
	
	protected void doRead(SocketChannel aSocketChannel,
			ByteBuffer aMessage) {
		String aCommand = new String(aMessage.array(), aMessage.position(), aMessage.remaining());
		 RemoteCommandExecuted.newCase(this, aCommand);
		 commandProcessor.processCommand(aCommand); // make this is a thread
	}
	
	@Override
	public void run() {
		while (true) {
			try {
			ChannelByteBuffer aMessage = messageQueue.take();
			doRead(aMessage.getSocketChannel(), aMessage.getByteBuffer());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
	}
	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/anniomanagersimulationclientoutcoupler.java
package nio.manager.simulation.client;

import java.beans.PropertyChangeEvent;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

import inputport.nio.manager.NIOManagerFactory;
import util.interactiveMethodInvocation.IPCMechanism;
import util.trace.Tracer;
import util.trace.port.nio.LocalCommandObserved;

public class AnNIOManagerSimulationClientOutCoupler implements NIOManagerSimulationOutCoupler {
	SocketChannel socketChannel;
//	boolean localProcessingOnly = false;
	
//	int numSentCommands = 0;
	
	public AnNIOManagerSimulationClientOutCoupler (SocketChannel aSocketChannel) {
		socketChannel = aSocketChannel;
	}

	@Override
	public void propertyChange(PropertyChangeEvent anEvent) {
		if (!anEvent.getPropertyName().equals("InputString")) return;
		if (AnNIOManagerSimulationClient.getNIOManagerSimulationClient().isLocalProcessingOnly() || 
				AnNIOManagerSimulationClient.getNIOManagerSimulationClient().getIPCMechanism() != IPCMechanism.NIO) {
			return;
		}
		String newCommand = (String) anEvent.getNewValue();
		LocalCommandObserved.newCase(this, newCommand);		
		Tracer.info(this, " Sending command:" + newCommand);
		ByteBuffer aByteBuffer = ByteBuffer.wrap(newCommand.getBytes());
		NIOManagerFactory.getSingleton().write(socketChannel, aByteBuffer);		

	}

//	@Override
//	public void localProcessingOnly(boolean newVal) {
//		localProcessingOnly = newVal;		
//	}

	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/niomanagersimulationclient.java
package nio.manager.simulation.client;

import util.interactiveMethodInvocation.IPCMechanism;
import assignments.util.inputParameters.SimulationParametersBean;
import assignments.util.inputParameters.SimulationParametersListener;
import assignments.util.mainArgs.ServerPort;
import inputport.nio.manager.listeners.SocketChannelConnectListener;
import inputport.nio.manager.listeners.WriteBoundedBufferListener;

public interface NIOManagerSimulationClient extends 
	SocketChannelConnectListener, 
	ServerPort, 
	WriteBoundedBufferListener,
	SimulationParametersBean{
	public static String SERVER_HOST = "localhost";
//	void createModelAndUI();
	void connectToServer(String aServerHost, int aServerPort);
	void createModelAndUI(String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset);
	void initialize(String aServerHost, int aServerPort, String aClientName,
			String aPrefix, int anXOffset, int aYOffset, int aWidth,
			int aHeight, int aCommandWindowXOffset, int aCommandWindowYOffset);
	void processCommands();
//	boolean isLocalProcessingOnly();
//	void setLocalProcessingOnly(boolean localProcessingOnly);
//	IPCMechanism getIPCMechanism();
//	boolean isLocalProcessingOnly();
//	void setIPCMechanism(IPCMechanism newVal);
//	void setAtomicBroadcast(boolean newVal);

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/niomanagersimulationincoupler.java
package nio.manager.simulation.client;

import inputport.nio.manager.listeners.SocketChannelReadListener;

public interface NIOManagerSimulationInCoupler extends SocketChannelReadListener, Runnable{

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/niomanagersimulationoutcoupler.java
package nio.manager.simulation.client;

import java.beans.PropertyChangeListener;

public interface NIOManagerSimulationOutCoupler extends PropertyChangeListener {
//	void localProcessingOnly(boolean newVal);
	
}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/niomanagersimulationprocessor.java
package nio.manager.simulation.client;

public interface NIOManagerSimulationProcessor extends Runnable {

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/client/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package nio.manager.simulation.client;
//END OF FILE
//START OF FILE: src/nio/manager/simulation/common/achannelbytebuffer.java
package nio.manager.simulation.common;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

import assignments.util.MiscAssignmentUtils;

public class AChannelByteBuffer implements ChannelByteBuffer {
	SocketChannel socketChannel;
	ByteBuffer byteBuffer;
	
	public AChannelByteBuffer(SocketChannel socketChannel,
			ByteBuffer aByteBuffer) {
		super();
		this.socketChannel = socketChannel;
		this.byteBuffer = MiscAssignmentUtils.deepDuplicate(aByteBuffer);
	}
	
	@Override
	public SocketChannel getSocketChannel() {
		return socketChannel;
	}
	
	@Override
	public void setSocketChannel(SocketChannel socketChannel) {
		this.socketChannel = socketChannel;
	}

	@Override
	public ByteBuffer getByteBuffer() {
		return byteBuffer;
	}
	
	@Override
	public void setByteBuffer(ByteBuffer byteBuffer) {
		this.byteBuffer = byteBuffer;
	}
	
	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/common/channelbytebuffer.java
package nio.manager.simulation.common;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public interface ChannelByteBuffer {

	public abstract SocketChannel getSocketChannel();

	public abstract void setSocketChannel(SocketChannel socketChannel);

	public abstract ByteBuffer getByteBuffer();

	public abstract void setByteBuffer(ByteBuffer byteBuffer);

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/common/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package nio.manager.simulation.common;
//END OF FILE
//START OF FILE: src/nio/manager/simulation/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package nio.manager.simulation;
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/anniomanagersimulationserver.java
package nio.manager.simulation.server;

import java.net.InetSocketAddress;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

import assignments.util.inputParameters.AnAbstractSimulationParametersBean;
import assignments.util.mainArgs.ClientArgsProcessor;
import assignments.util.mainArgs.ServerArgsProcessor;
import inputport.nio.manager.NIOManagerFactory;
import inputport.nio.manager.factories.classes.AReadingAcceptCommandFactory;
import inputport.nio.manager.factories.selectors.AcceptCommandFactorySelector;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.trace.Tracer;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.nio.SocketChannelBound;

public class AnNIOManagerSimulationServer extends AnAbstractSimulationParametersBean implements NIOManagerSimulationServer {
	// ObservableNIOManager nioManager;
	ServerSocketChannel serverSocketChannel;
	NIOManagerSimulationServerMulticaster multicaster;
	NIOManagerSimulationServerReceiver receiver;
	public static final String READ_THREAD_NAME = "Read Thread";

//	public AnNIOManagerSimulationServer(int aServerPort) {
////		AcceptCommandSelector.setFactory(new AReadingAcceptCommandFactory());
//		ServerSocketChannel aServerSocketChannel = createSocketChannel(aServerPort);
//		NIOManagerFactory.getSingleton().enableListenableAccepts(
//				aServerSocketChannel, this);
//
//	}

	protected void createMulticaster() {
		multicaster = new AnNIOManagerSimulationServerMulticaster();
		Thread aMultiCasterThread = new Thread(multicaster);
		aMultiCasterThread.setName(READ_THREAD_NAME);
		aMultiCasterThread.start();
	}

	protected void createReceiver() {
		receiver = new AnNIOManagerSimulationServerReceiver(multicaster);
	}

	protected void setFactories() {
		AcceptCommandFactorySelector.setFactory(new AReadingAcceptCommandFactory());
	}


	protected void createCommunicationObjects() {
		createMulticaster();
		createReceiver();
	}

	protected ServerSocketChannel createSocketChannel(int aServerPort) {
		try {
			ServerSocketChannel retVal = ServerSocketChannel.open();
			InetSocketAddress isa = new InetSocketAddress(aServerPort);
			retVal.socket().bind(isa);
			SocketChannelBound.newCase(this, retVal, isa);
			return retVal;

		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	protected void makeServerConnectable(int aServerPort) {
//		ServerSocketChannel aServerSocketChannel = createSocketChannel(aServerPort);
		NIOManagerFactory.getSingleton().enableListenableAccepts(
				serverSocketChannel, this);
	}
	@Override
	public void initialize(int aServerPort) {
		setFactories();
		serverSocketChannel = createSocketChannel(aServerPort);
		createCommunicationObjects();
		makeServerConnectable(aServerPort);
		SimulationParametersControllerFactory.getSingleton().addSimulationParameterListener(this);
//		SimulationParametersControllerFactory.getSingleton().processCommands();
	}

	protected void addListeners(SocketChannel aSocketChannel) {
		addReadListener(aSocketChannel);
//		addWriteBufferListener(aSocketChannel);
	}

	protected void addReadListener(SocketChannel aSocketChannel) {
		NIOManagerFactory.getSingleton().addReadListener(aSocketChannel,
				receiver);
	}

	protected void joinMulticast(SocketChannel aSocketChannel) {
		multicaster.join(aSocketChannel);
	}

	@Override
	public void socketChannelAccepted(ServerSocketChannel aServerSocketChannel,
			SocketChannel aSocketChannel) {
		joinMulticast(aSocketChannel);
		addListeners(aSocketChannel);
//		addReadListener(aSocketChannel);
//		addWriteBufferListener(aSocketChannel);
	}
	protected void addWriteBufferListener(SocketChannel aSocketChannel) {
		NIOManagerFactory.getSingleton().addWriteBoundedBufferListener(
				aSocketChannel, this);
	}
	@Override
	public void writeBufferIsEmpty(SocketChannel aSocketChannel) {
		NIOManagerFactory.getSingleton().enableReads(aSocketChannel);
	}
	
	protected static NIOManagerSimulationServer nioManagerSimulationServer;
	public static NIOManagerSimulationServer getNIOManagerSimulationServer() {
		return nioManagerSimulationServer;
	}
	public static void launch(String[] args) {
		args = ServerArgsProcessor.removeEmpty(args);
		NIOManagerSimulationServer anNIOManagerSimulationServer = 
				new AnNIOManagerSimulationServer();
		anNIOManagerSimulationServer.initialize(ServerArgsProcessor.getServerPort(args));
		nioManagerSimulationServer = anNIOManagerSimulationServer;
		SimulationParametersControllerFactory.getSingleton().processCommands();

	}

	

	@Override
	public void experimentInput() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void quit(int aCode) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void simulationCommand(String aCommand) {
		// TODO Auto-generated method stub
		
	}
	public static void main(String[] args) {
		NIOTraceUtility.setTracing();
//		Tracer.setBufferTracedMessages(true);
		NIOManagerSimulationServer anNIOManagerSimulationServer = 
				new AnNIOManagerSimulationServer();
		args = ServerArgsProcessor.removeEmpty(args);
		anNIOManagerSimulationServer.initialize(ServerArgsProcessor.getServerPort(args));
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("Buffered messages");
		System.out.println(Tracer.getBufferedTracedMessages());
	}
	

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/anniomanagersimulationservermulticaster.java
package nio.manager.simulation.server;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import inputport.nio.manager.NIOManagerFactory;
import nio.manager.simulation.common.AChannelByteBuffer;
import nio.manager.simulation.common.ChannelByteBuffer;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;

public class AnNIOManagerSimulationServerMulticaster implements NIOManagerSimulationServerMulticaster {
//	private List queue = new LinkedList();
	List<SocketChannel> allClients = new ArrayList();
	public static int MAX_QUEUE_SIZE = 100;
	BlockingQueue<ChannelByteBuffer> messageQueue = new ArrayBlockingQueue(MAX_QUEUE_SIZE);
//	protected boolean atomicBroadcast;
	
	
//	public void processData(SimulationNioRelayer server, SocketChannel socket, byte[] data, int count) {
//		TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelayReceive();
//
//		byte[] dataCopy = new byte[count];
//		System.arraycopy(data, 0, dataCopy, 0, count);
//		synchronized(queue) {
////			queue.add(new ServerDataEvent(server, socket, dataCopy));
//			List<SocketChannel> allClients = server.getAllClients();
//			for (SocketChannel client:allClients) {
//				if (client == socket && !RelayerControllerFactory.getOrCreateSingleton().isEchoBack()) {
//					Tracer.info(this, "Not Sending message to:" + client);
//
//					continue;
//				}
////				if (!TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend()) {
////					maybeWaitForRelay();
////				};
//				Tracer.info(this, "Sending message to:" + client);
//				queue.add(new ServerDataEvent(server, client, dataCopy));
//
//			}
//			queue.notify();
//		}
//	}
//	protected void maybeWaitForRelay() {
//		RelayerController aRelayerController =  RelayerControllerFactory.getOrCreateSingleton();
//		if (aRelayerController.isWaitForRelay()) {
//			ClearanceManagerFactory.getOrCreateClearanceManager().waitForClearance();
//		}
//
//	}
//	
//	public void run() {
//		ServerDataEvent dataEvent;
//		
//		while(true) {
//			// Wait for data to become available
//			synchronized(queue) {
//				while(queue.isEmpty()) {
//					try {
//						queue.wait();
//					} catch (InterruptedException e) {
//					}
//				}
//				dataEvent = (ServerDataEvent) queue.remove(0);
//			}
//			
//			// Return to sender
//			dataEvent.server.send(dataEvent.socket, dataEvent.data);
//		}
//	}
	@Override
	public void multicast(SocketChannel aWriter, ByteBuffer aByteBuffer) {
		if (messageQueue.size() >= MAX_QUEUE_SIZE) {
			System.err.println("Message queue full, ignoring message");
			return;
		}
		
		messageQueue.add(new AChannelByteBuffer(aWriter, aByteBuffer));
//		doMulticast(aWriter, aByteBuffer);
//		byte[] aBytes = new byte[aByteBuffer.limit() - aByteBuffer.position()];
//		System.arraycopy(aByteBuffer.array(), aByteBuffer.position(), aBytes, 0, aBytes.length);
//
////		aByteBuffer.get(aBytes, aByteBuffer.position(), aBytes.length);
//				
//
//		for (SocketChannel aSocketChannel: allClients) {
//			if (aSocketChannel == aWriter) {
//				continue;
//			}
//			NIOManagerFactory.getSingleton().write(aSocketChannel, ByteBuffer.wrap(aBytes));
//		}		
	}
	protected void doMulticast(SocketChannel aWriter, ByteBuffer aByteBuffer) {
		byte[] aBytes = new byte[aByteBuffer.limit() - aByteBuffer.position()];
		System.arraycopy(aByteBuffer.array(), aByteBuffer.position(), aBytes, 0, aBytes.length);

//		aByteBuffer.get(aBytes, aByteBuffer.position(), aBytes.length);
		if (AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast() == null) {
			return;
		}

		for (SocketChannel aSocketChannel: allClients) {
			if (aSocketChannel == aWriter && !AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast()) {
				continue;
			}
			NIOManagerFactory.getSingleton().write(aSocketChannel, ByteBuffer.wrap(aBytes));
		}		
	}
	@Override
	public void join(SocketChannel aSocketChannel) {
		allClients.add(aSocketChannel);		
	}
	@Override
	public void run() {
		while (true) {
			try {
			ChannelByteBuffer aMessage = messageQueue.take();
			doMulticast(aMessage.getSocketChannel(), aMessage.getByteBuffer());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
	}
//	@Override
//	public void atomicBroadcast(boolean newValue) {
//		atomicBroadcast = newValue;
//		
//	}
//	@Override
//	public void ipcMechanism(IPCMechanism newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void experimentInput() {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void broadcastBroadcastMode(boolean newValue) {
//		
//		
//	}
//	@Override
//	public void waitForBroadcastConsensus(boolean newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void broadcastIPCMechanism(boolean newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void waitForIPCMechanismConsensus(boolean newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void consensusAlgorithm(ConsensusAlgorithm newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void localProcessingOnly(boolean newValue) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void quit(int aCode) {
//		// TODO Auto-generated method stub
//		
//	}
//	@Override
//	public void simulationCommand(String aCommand) {
//		System.out.println("Server cannot play aComand:" + aCommand);
//		
//	}
}

//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/anniomanagersimulationserverreceiver.java
package nio.manager.simulation.server;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class AnNIOManagerSimulationServerReceiver implements NIOManagerSimulationServerReceiver{
	NIOManagerSimulationServerMulticaster multicaster;
	public AnNIOManagerSimulationServerReceiver(NIOManagerSimulationServerMulticaster aMulticaster) {
		multicaster = aMulticaster;
	}
	@Override
	public void socketChannelRead(SocketChannel aSocketChannel,
			ByteBuffer aMessage, int aLength) {
		multicaster.multicast(aSocketChannel, aMessage);
		
	}

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/niomanagersimulationserver.java
package nio.manager.simulation.server;

import assignments.util.inputParameters.SimulationParametersBean;
import assignments.util.inputParameters.SimulationParametersListener;
import assignments.util.mainArgs.ServerPort;
import inputport.nio.manager.listeners.SocketChannelAcceptListener;
import inputport.nio.manager.listeners.WriteBoundedBufferListener;


public interface NIOManagerSimulationServer extends 
ServerPort, SocketChannelAcceptListener, WriteBoundedBufferListener, SimulationParametersBean {
	void initialize(int aServerPort);
}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/niomanagersimulationservermulticaster.java
package nio.manager.simulation.server;

import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

import assignments.util.inputParameters.SimulationParametersListener;

public interface NIOManagerSimulationServerMulticaster extends Runnable{
	void multicast(SocketChannel aWriter, ByteBuffer aByteBuffer);
	void join(SocketChannel aSocketChannel);

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/niomanagersimulationserverreceiver.java
package nio.manager.simulation.server;

import inputport.nio.manager.listeners.SocketChannelReadListener;

public interface NIOManagerSimulationServerReceiver extends SocketChannelReadListener{

}
//END OF FILE
//START OF FILE: src/nio/manager/simulation/server/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package nio.manager.simulation.server;
//END OF FILE
//START OF FILE: src/nio/server/serverdataevent.java
package nio.server;

import java.nio.channels.SocketChannel;

public class ServerDataEvent {
	public SimulationNioRelayer server;
	public SocketChannel socket;
	public byte[] data;
	
	public ServerDataEvent(SimulationNioRelayer server, SocketChannel socket, byte[] data) {
		this.server = server;
		this.socket = socket;
		this.data = data;
	}
}
//END OF FILE
//START OF FILE: src/nio/server/serverworker.java
package nio.server;

import java.nio.channels.SocketChannel;
import java.util.LinkedList;
import java.util.List;

import common.controller.TrickOrTreatClientControllerFactory;
import util.misc.ClearanceManagerFactory;
import util.remote.RelayerController;
import util.remote.RelayerControllerFactory;
import util.trace.Tracer;

public class ServerWorker implements Runnable {
	private List queue = new LinkedList();
	
	public void processData(SimulationNioRelayer server, SocketChannel socket, byte[] data, int count) {
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelayReceive();

		byte[] dataCopy = new byte[count];
		System.arraycopy(data, 0, dataCopy, 0, count);
		synchronized(queue) {
//			queue.add(new ServerDataEvent(server, socket, dataCopy));
			List<SocketChannel> allClients = server.getAllClients();
			for (SocketChannel client:allClients) {
				if (client == socket && !RelayerControllerFactory.getOrCreateSingleton().isEchoBack()) {
					Tracer.info(this, "Not Sending message to:" + client);

					continue;
				}
//				if (!TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend()) {
//					maybeWaitForRelay();
//				};
				Tracer.info(this, "Sending message to:" + client);
				queue.add(new ServerDataEvent(server, client, dataCopy));

			}
			queue.notify();
		}
	}
	protected void maybeWaitForRelay() {
		RelayerController aRelayerController =  RelayerControllerFactory.getOrCreateSingleton();
		if (aRelayerController.isWaitForRelay()) {
			ClearanceManagerFactory.getOrCreateClearanceManager().waitForClearance();
		}

	}
	
	public void run() {
		ServerDataEvent dataEvent;
		
		while(true) {
			// Wait for data to become available
			synchronized(queue) {
				while(queue.isEmpty()) {
					try {
						queue.wait();
					} catch (InterruptedException e) {
					}
				}
				dataEvent = (ServerDataEvent) queue.remove(0);
			}
			
			// Return to sender
			dataEvent.server.send(dataEvent.socket, dataEvent.data);
		}
	}
}

//END OF FILE
//START OF FILE: src/nio/server/simulationniorelayer.java
package nio.server;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import common.controller.ServerControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import nio.common.ChangeRequest;
import util.remote.RelayerControllerFactory;
import util.trace.Tracer;


public class SimulationNioRelayer implements Runnable {
	// The host:port combination to listen on
	private InetAddress hostAddress;
	private int port;

	// The channel on which we'll accept connections
	private ServerSocketChannel serverChannel;

	// The selector we'll be monitoring
	private Selector selector;

	// The buffer into which we'll read data when it's available
	private ByteBuffer readBuffer = ByteBuffer.allocate(8192);

	private ServerWorker worker;

	// A list of PendingChange instances
	private List pendingChanges = new LinkedList();

	// Maps a SocketChannel to a list of ByteBuffer instances
	private Map pendingData = new HashMap();
	
	List<SocketChannel> allClients = new ArrayList();

	public SimulationNioRelayer(InetAddress hostAddress, int port, ServerWorker worker) throws IOException {
		this.hostAddress = hostAddress;
		this.port = port;
		this.selector = this.initSelector();
		this.worker = worker;
	}

	public void send(SocketChannel socket, byte[] data) {
		synchronized (this.pendingChanges) {
			// Indicate we want the interest ops set changed
			this.pendingChanges.add(new ChangeRequest(socket, ChangeRequest.CHANGEOPS, SelectionKey.OP_WRITE));

			// And queue the data we want written
			synchronized (this.pendingData) {
				List queue = (List) this.pendingData.get(socket);
				if (queue == null) {
					queue = new ArrayList();
					this.pendingData.put(socket, queue);
				}
				queue.add(ByteBuffer.wrap(data));
			}
		}

		// Finally, wake up our selecting thread so it can make the required changes
		this.selector.wakeup();
	}

	public void run() {
		while (true) {
			try {
				// Process any pending changes
				synchronized (this.pendingChanges) {
					Iterator changes = this.pendingChanges.iterator();
					while (changes.hasNext()) {
						ChangeRequest change = (ChangeRequest) changes.next();
						switch (change.type) {
						case ChangeRequest.CHANGEOPS:
							SelectionKey key = change.socket.keyFor(this.selector);
							key.interestOps(change.ops);
						}
					}
					this.pendingChanges.clear();
				}

				// Wait for an event one of the registered channels
				this.selector.select();

				// Iterate over the set of keys for which events are available
				Iterator selectedKeys = this.selector.selectedKeys().iterator();
				while (selectedKeys.hasNext()) {
					SelectionKey key = (SelectionKey) selectedKeys.next();
					selectedKeys.remove();

					if (!key.isValid()) {
						continue;
					}

					// Check what event is available and deal with it
					if (key.isAcceptable()) {
						this.accept(key);
					} else if (key.isReadable()) {
						this.read(key);
					} else if (key.isWritable()) {
						this.write(key);
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private void accept(SelectionKey key) throws IOException {
		// For an accept to be pending the channel must be a server socket channel.
		ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();

		// Accept the connection and make it non-blocking
		SocketChannel socketChannel = serverSocketChannel.accept();
		Socket socket = socketChannel.socket();
		socketChannel.configureBlocking(false);
		allClients.add(socketChannel);
		RelayerControllerFactory.getOrCreateSingleton().setRelayClients(allClients.toString());

		// Register the new SocketChannel with our Selector, indicating
		// we'd like to be notified when there's data waiting to be read
		socketChannel.register(this.selector, SelectionKey.OP_READ);
	}

	private void read(SelectionKey key) throws IOException {
		SocketChannel socketChannel = (SocketChannel) key.channel();

		// Clear out our read buffer so it's ready for new data
		this.readBuffer.clear();

		// Attempt to read off the channel
		int numRead;
		try {
			numRead = socketChannel.read(this.readBuffer);
		} catch (IOException e) {
			// The remote forcibly closed the connection, cancel
			// the selection key and close the channel.
			key.cancel();
			socketChannel.close();
			return;
		}

		if (numRead == -1) {
			// Remote entity shut the socket down cleanly. Do the
			// same from our end and cancel the channel.
			key.channel().close();
			key.cancel();
			return;
		}

		// Hand the data off to our worker thread
		this.worker.processData(this, socketChannel, this.readBuffer.array(), numRead);
	}

	public List<SocketChannel> getAllClients() {
		return allClients;
	}
	private void write(SelectionKey key) throws IOException {
		SocketChannel socketChannel = (SocketChannel) key.channel();
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend();

		synchronized (this.pendingData) {
			List queue = (List) this.pendingData.get(socketChannel);

			// Write until there's not more data ...
			while (!queue.isEmpty()) {
				ByteBuffer buf = (ByteBuffer) queue.get(0);
				socketChannel.write(buf);
				if (buf.remaining() > 0) {
					// ... or the socket's buffer fills up
					break;
				}
				queue.remove(0);
			}

			if (queue.isEmpty()) {
				// We wrote away all data, so we're no longer interested
				// in writing on this socket. Switch back to waiting for
				// data.
				key.interestOps(SelectionKey.OP_READ);
			}
		}
	}

	private Selector initSelector() throws IOException {
		// Create a new selector
		Selector socketSelector = SelectorProvider.provider().openSelector();

		// Create a new non-blocking server socket channel
		this.serverChannel = ServerSocketChannel.open();
		serverChannel.configureBlocking(false);

		// Bind the server socket to the specified address and port
		InetSocketAddress isa = new InetSocketAddress(this.hostAddress, this.port);
		serverChannel.socket().bind(isa);

		// Register the server socket channel, indicating an interest in 
		// accepting new connections
		serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);

		return socketSelector;
	}

	public static void main(String[] args) {
		try {
			Tracer.showWarnings(false);
//			Tracer.setKeywordPrintStatus(ServerWorker.class, true);
			ServerWorker worker = new ServerWorker();
			Thread workerThread = new Thread(worker);
			workerThread.setName("Worker");
			workerThread.start();
			Thread serverThread = new Thread(new SimulationNioRelayer(null, 9090, worker));
			serverThread.setName("NIO Server Selector");
			serverThread.start();
//			OEFrame relayerControllerFrame = ObjectEditor.edit(RelayerControllerFactory.getOrCreateSingleton());
//			relayerControllerFrame.setLocation(900, 500);
			ServerControllerUI.createUI();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}}
//END OF FILE
//START OF FILE: src/objectgspsyncrcv/anobjectgroupsessionportwithsyncreceivefactory.java
package objectgspsyncrcv;

import port.ParticipantChoice;
import sessionport.datacomm.group.GroupSessionPort;
import sessionport.datacomm.group.object.ObjectGroupSessionPortSelector;
import sessionport.datacomm.group.syncrcv.AGroupSessionPortWithSyncReceiveFactory;

public class AnObjectGroupSessionPortWithSyncReceiveFactory extends AGroupSessionPortWithSyncReceiveFactory<Object>  {

	@Override
	protected GroupSessionPort<Object> createGroupSessionPort(
			String aSessionsServerHost, String aSessionsServerId,
			String aSessionsServerName, String aSessionName, String anId,
			String aName, ParticipantChoice aChoice) {
		return ObjectGroupSessionPortSelector.createObjectGroupSessionPort(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, aChoice);
	}

	

}
//END OF FILE
//START OF FILE: src/objectgspsyncrcv/objectgroupsessionportwithsyncreceiveselector.java
package objectgspsyncrcv;


import port.ParticipantChoice;
import sessionport.datacomm.group.syncrcv.GroupSessionPortWithSyncReceive;
import sessionport.datacomm.group.syncrcv.GroupSessionPortWithSyncReceiveFactory;


public class ObjectGroupSessionPortWithSyncReceiveSelector  {
	static GroupSessionPortWithSyncReceiveFactory<Object> factory = new AnObjectGroupSessionPortWithSyncReceiveFactory();
	 
	public static void setBufferGroupSessionPortWithSyncReceiveFactory(GroupSessionPortWithSyncReceiveFactory<Object> theSessionPortFactory) {
		factory = theSessionPortFactory;
	}
	public static GroupSessionPortWithSyncReceive<Object> createBufferGroupSessionPortWithSyncReceive(
			String aSessionsServerHost, 
			String aSessionsServerId, 
			String aSessionsServerName, 
			String aSessionName, 
			String anId,
			String aName, ParticipantChoice aChoice) {
		return factory.createGroupSessionPortWithSyncReceive(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, aChoice);
	}
}
//END OF FILE
//START OF FILE: src/port/old/abuffergroupsessionportwithsyncreceive.java
package port.old;

import inputport.datacomm.ReceiveListener;
import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;
import inputport.datacomm.group.buffer.syncrcv.ABufferGroupServerInputPortWithSyncReceive;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Set;

import port.ParticipantChoice;
import port.sessionserver.SessionParticipantDescription;
import sessionport.datacomm.group.syncrcv.GroupSessionPortWithSyncReceive;


public class ABufferGroupSessionPortWithSyncReceive extends ABufferGroupServerInputPortWithSyncReceive implements GroupSessionPortWithSyncReceive<ByteBuffer>{

	public ABufferGroupSessionPortWithSyncReceive(
			DuplexServerInputPortWithSyncReceive<ByteBuffer> duplexServerInputPort) {
		super(duplexServerInputPort);
	}
	String physicalRemoteEndPoint;
	String logicalRemoteEndPoint;
	@Override
	public String getLogicalRemoteEndPoint() {
		return logicalRemoteEndPoint;
	}

	@Override
	public String getPhysicalRemoteEndPoint() {
		return physicalRemoteEndPoint;
	}

	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		physicalRemoteEndPoint = newVal;
	}

	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		logicalRemoteEndPoint = newVal;
	}

	

	@Override
	public List<SessionParticipantDescription> getServers() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<SessionParticipantDescription> getMembers() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<SessionParticipantDescription> getClients() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SessionParticipantDescription getServer(String aName) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SessionParticipantDescription getClient(String aName) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SessionParticipantDescription getMember(String aName) {
		// TODO Auto-generated method stub
		return null;
	}

	

	@Override
	public Set<String> getClientConnections() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Set<String> getServerConnections() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Set<String> getMemberConnections() {
		// TODO Auto-generated method stub
		return null;
	}

	

	@Override
	public void sendOtherClients(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void sendOtherServers(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void sendOtherMembers(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void sendAllClients(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void sendAllServers(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void sendAllMembers(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

	

	@Override
	public ParticipantChoice getParticipantChoice() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void sendAllRemoteMembers(ByteBuffer message) {
		// TODO Auto-generated method stub
		
	}

//	@Override
//	public void sendOtherClients(Object message) {
//		// TODO Auto-generated method stub
//		
//	}
//
//	@Override
//	public void sendOtherServers(Object message) {
//		// TODO Auto-generated method stub
//		
//	}
//
//	@Override
//	public void sendOtherMembers(Object message) {
//		// TODO Auto-generated method stub
//		
//	}

//	@Override
//	public void sendAllClients(Object message) {
//		// TODO Auto-generated method stub
//		
//	}
//
//	@Override
//	public void sendAllServers(Object message) {
//		// TODO Auto-generated method stub
//		
//	}
//
//	@Override
//	public void sendAllMembers(Object message) {
//		// TODO Auto-generated method stub
//		
//	}
//
//
//	@Override
//	public Set<String> getClientConnections() {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public Set<String> getServerConnections() {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public Set<String> getMemberConnections() {
//		// TODO Auto-generated method stub
//		return null;
//	}
}
//END OF FILE
//START OF FILE: src/port/old/socketduplexclientinputportlauncher.java
package port.old;

import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.buffer.socket.ASocketDuplexBufferInputPortFactory;

import java.nio.ByteBuffer;

public class SocketDuplexClientInputPortLauncher {
	public static void main(String args[]) {
		DuplexInputPortFactory<ByteBuffer> untypedInputPortFactory = new ASocketDuplexBufferInputPortFactory();
		DuplexBufferInputPortSelector.setDuplexBufferInputPortFactory(untypedInputPortFactory);
		BufferDuplexClientInputPortLauncher.launch(args);
	}

}
//END OF FILE
//START OF FILE: src/port/old/socketduplexserverinputportlauncher.java
package port.old;

import inputport.datacomm.duplex.DuplexInputPortFactory;
import inputport.datacomm.duplex.buffer.DuplexBufferInputPortSelector;
import inputport.datacomm.duplex.buffer.socket.ASocketDuplexBufferInputPortFactory;

import java.nio.ByteBuffer;



public class SocketDuplexServerInputPortLauncher {
	public static void main (String[] args) {
		DuplexInputPortFactory<ByteBuffer> untypedInputPortFactory = new ASocketDuplexBufferInputPortFactory();
		DuplexBufferInputPortSelector.setDuplexBufferInputPortFactory(untypedInputPortFactory);
		BufferDuplexServerInputPortLauncher.launch(args);
	
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/alicermiandnioclient.java
package rmi.simulation.client;

import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION1_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;
public class AliceRMIAndNIOClient {
	public static void launchAlice(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AnRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				SIMULATION1_PREFIX, 
				0, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args));
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/anrmiandniosimulationclient.java
package rmi.simulation.client;


import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION1_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;

import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import nio.manager.simulation.client.NIOManagerSimulationClient;
import common.client.ClientParameters;
import main.BeauAndersonFinalProject;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.server.RMIAndNIOSimulationServer;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.remote.RelayerClientControllerFactory;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.consensus.RemoteProposeRequestSent;
import util.trace.port.consensus.communication.CommunicationStateNames;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMIObjectLookedUp;
import util.trace.port.rpc.rmi.RMIRegistryLocated;



public class AnRMIAndNIOSimulationClient 
	extends AnNIOManagerSimulationClient
	implements RMIAndNIOSimulationClient{
	protected RMISimulationRelayer rmiServerProxy;
	public AnRMIAndNIOSimulationClient() {
	}
	protected RMISimulationInCoupler createRMIInCoupler() {
		return new AnRMISimulationInCoupler(commandProcessor);
	}
	@Override
	public void initialize(String aServerHost, int aServerPort,
			String aClientName,
			String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset, 
			String anRMIRegistryHost, 
			int anRMIRegistryPort) {
		super.initialize(aServerHost, aServerPort, aClientName, aPrefix, anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
		RMISimulationInCoupler inCoupler = createRMIInCoupler();

		Registry anRMIRegistry;

		try {
		
		
			// this is where we block if necessary
//			rmiRegistry = LocateRegistry.getRegistry();
			anRMIRegistry = LocateRegistry.getRegistry(anRMIRegistryHost, anRMIRegistryPort);
			RMIRegistryLocated.newCase(this, anRMIRegistryHost, anRMIRegistryPort, anRMIRegistry);

			UnicastRemoteObject.exportObject(inCoupler, 0);
			
			rmiServerProxy = (RMISimulationRelayer) anRMIRegistry.lookup(RMISimulationServerLauncher.SESSION_SERVER);
		   
			RMIObjectLookedUp.newCase(this, rmiServerProxy, RMISimulationServerLauncher.SESSION_SERVER, anRMIRegistry);
			rmiServerProxy.join(aClientName, inCoupler);
			
			new AnRMISimulationOutCoupler(commandProcessor, rmiServerProxy, aClientName, IPCMechanism.RMI);
			 
//				ClientControllerFactory.getOrCreateSingleton().setServerId(RMISimulationServerLauncher.SESSION_SERVER);
			

				   
		   } catch (Exception e) {
			
	      e.printStackTrace();
	    }
	  
	  }
	
	public void ipcMechanism(IPCMechanism newValue) {
		if (!isBroadcastBroadcastMode()) {
		     super.ipcMechanism(newValue);
		} else {
			try {
//				if (!isAtomicBroadcast()) {
//					super.ipcMechanism(newValue);
//				}
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
				rmiServerProxy.broadcastIPCMechanism(clientName, newValue);
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
		
	}
	public void atomicBroadcast(boolean newValue) {
		if (!isBroadcastBroadcastMode()) {
		     super.atomicBroadcast(newValue);
		} else {
			try {
//				if (!isAtomicBroadcast()) {
//					super.atomicBroadcast(newValue);
//				}
				RemoteProposeRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
				rmiServerProxy.broadcastBroadcastMode(clientName, newValue);
				
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
		
	}
	
	protected static RMIAndNIOSimulationClient rmiAndNIOClient;
	public static RMIAndNIOSimulationClient getRMIAndNIOSimulationClient() {
		return rmiAndNIOClient;
	}
	public static void launchClient(String aServerHost, int aServerPort,
			String aClientName, String aPrefix, int anXOffset, int aYOffset,
			int aWidth, int aHeight, int aCommandWindowXOffset,
			int aCommandWindowYOffset,
			String anRMIHost,
			int anRMIPort) {
		RMIAndNIOSimulationClient aClient = new AnRMIAndNIOSimulationClient();
		rmiAndNIOClient = aClient;
		nioManagerClient = aClient;
		aClient.initialize(aServerHost, aServerPort, aClientName, aPrefix,
				anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset,
				aCommandWindowYOffset, anRMIHost, anRMIPort);
		aClient.processCommands();

	}
	public static void main(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AnRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				SIMULATION1_PREFIX, 
				0, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args));
	}	

	
}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/anrmisimulationclientlauncher.java
package rmi.simulation.client;


import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import common.client.ClientParameters;
import main.BeauAndersonFinalProject;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.common.RMISimulationRelayer;
import stringProcessors.HalloweenCommandProcessor;
import util.annotations.Tags;
import util.interactiveMethodInvocation.IPCMechanism;
import util.remote.RelayerClientControllerFactory;
import util.tags.DistributedTags;
import util.trace.port.rpc.rmi.RMIRegistryLocated;


@Tags({DistributedTags.CLIENT, DistributedTags.RMI})
public class AnRMISimulationClientLauncher implements ClientParameters{
	public static void  launchClient(String aMyName, boolean aBroadcastData, String aPrefix, int anXOffset, int aYOffset, int aWidth, int aHeight, int aCommandWindowXOffset, int aCommandWindowYOffset) {
		   try {
		HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
				aPrefix, anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
		launchClient(aMyName, aCommandProcessor, aBroadcastData);
	 
////	    	String currentDir = System.getProperty("user.dir");
////	        System.out.println("Current dir using System:" +currentDir);
//	    	
//	      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//	      Thread t = new Thread(client);
//	      t.setDaemon(true);
//	      t.start();
////	      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
////	    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	      client.createUI(aCommandProcessor);
////	      client.initiateConnection();
////	      RspHandler handler = new RspHandler();
////	      client.send("Hello World".getBytes(), handler);
////	      handler.waitForResponse();
	    } catch (Exception e) {
	      e.printStackTrace();
	    }
	  
	  }
	public static void  launchClient(String aMyName, HalloweenCommandProcessor aCommandProcessor, boolean aBroadcast) {
		   RMISimulationInCoupler inCoupler = new AnRMISimulationInCoupler(aCommandProcessor);
		   Registry rmiRegistry;
		try {
			String aFullServerId = SERVER_HOST + ":" + RMISimulationServerLauncher.SESSION_SERVER;
			RelayerClientControllerFactory.getOrCreateSingleton().setServerHost(SERVER_HOST);
		
			// this is where we block if necessary
//			rmiRegistry = LocateRegistry.getRegistry();
			rmiRegistry = LocateRegistry.getRegistry(RelayerClientControllerFactory.getOrCreateSingleton().getServerHost());
			UnicastRemoteObject.exportObject(inCoupler, 0);

			
			RMISimulationRelayer server = (RMISimulationRelayer) rmiRegistry.lookup(RMISimulationServerLauncher.SESSION_SERVER);
		   
			server.join(aMyName, inCoupler);
			RelayerClientControllerFactory.getOrCreateSingleton().setServerId(RMISimulationServerLauncher.SESSION_SERVER);
			RelayerClientControllerFactory.getOrCreateSingleton().setRelayerId(RMISimulationServerLauncher.SESSION_SERVER);
		   
			   if (aBroadcast) {
				   new AnRMISimulationOutCoupler(aCommandProcessor, server, aMyName, IPCMechanism.RMI);
			   }
//				ClientControllerFactory.getOrCreateSingleton().setServerId(RMISimulationServerLauncher.SESSION_SERVER);
			

				   
		   } catch (Exception e) {
			
	      e.printStackTrace();
	    }
	  
	  }

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/anrmisimulationincoupler.java
package rmi.simulation.client;

import java.rmi.RemoteException;

import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import common.controller.TrickOrTreatClientControllerFactory;
import rmi.simulation.common.RMISimulationInCoupler;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;
import util.trace.port.consensus.ProposalLearnedNotificationReceived;
import util.trace.port.consensus.communication.CommunicationStateNames;

public class AnRMISimulationInCoupler implements RMISimulationInCoupler {
	HalloweenCommandProcessor commandProcessor;
	public AnRMISimulationInCoupler(HalloweenCommandProcessor aCommandProcessor) {
		commandProcessor = aCommandProcessor;
	}

	@Override
	public void processCommand(String aCommand)  {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, aCommand);
		TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelayReceive();
		commandProcessor.processCommand(aCommand);		
	}

	@Override
	public void newRemoteBroadcastMode(boolean newValue) throws RemoteException {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
		AnNIOManagerSimulationClient.getNIOManagerSimulationClient().setAtomicBroadcast(newValue);

	}

	@Override
	public void newRemoteIPCMechanism(IPCMechanism newValue) throws RemoteException {
		ProposalLearnedNotificationReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
		AnNIOManagerSimulationClient.getNIOManagerSimulationClient().setIPCMechanism(newValue);

		
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/anrmisimulationoutcoupler.java
package rmi.simulation.client;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import common.controller.TrickOrTreatClientControllerFactory;
import rmi.simulation.common.RMISimulationRelayer;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;
import util.trace.port.consensus.ActionWhileEnablingProposalIsPending;
import util.trace.port.consensus.RemoteProposeRequestSent;
import util.trace.port.consensus.communication.CommunicationStateNames;

public class AnRMISimulationOutCoupler implements PropertyChangeListener {
	HalloweenCommandProcessor observingSimulation;
	RMISimulationRelayer sessionServer;
	IPCMechanism myIPCMechanism;
	

	String myName;
	
	public AnRMISimulationOutCoupler (HalloweenCommandProcessor anObservedSimulaton, RMISimulationRelayer aSessionServer, String aName, IPCMechanism aMyIPCMechanism) {
		anObservedSimulaton.addPropertyChangeListener(this);
		sessionServer = aSessionServer;
		myName = aName;
		myIPCMechanism = aMyIPCMechanism;
	}

	@Override
	public void propertyChange(PropertyChangeEvent anEvent) {
		if (!anEvent.getPropertyName().equals("InputString")) return;
		if (AnRMIAndNIOSimulationClient.getRMIAndNIOSimulationClient().isAtomicBroadcast() == null) {
			ActionWhileEnablingProposalIsPending.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, anEvent);
			return;
		}
		if (AnRMIAndNIOSimulationClient.getRMIAndNIOSimulationClient().getIPCMechanism() == null) {
			ActionWhileEnablingProposalIsPending.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, anEvent);
			return;
		}
		if (AnRMIAndNIOSimulationClient.getRMIAndNIOSimulationClient().isLocalProcessingOnly() || 
				AnRMIAndNIOSimulationClient.getNIOManagerSimulationClient().getIPCMechanism() != myIPCMechanism) {
			return;
		}
		String newCommand = (String) anEvent.getNewValue();
		try {
//			if (Settingsfactory.getOrCreateSettings().isWaitForSend()) {
//				ClearanceManagerFactory.getOrCreateClearanceManager().waitForClearance();
//			} else if (Settingsfactory.getOrCreateSettings().isDelaySend()) {
//				ThreadSupport.sleep((Settingsfactory.getOrCreateSettings().getSendDelay()));
//			}
//			TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend();
			RemoteProposeRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, newCommand);
			getSessionServer().broadcast(myName, newCommand);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		System.out.println("Received command:" + newCommand);
//		observingSimulation.processCommand(newCommand);
	}

	
	public RMISimulationRelayer getSessionServer() {
		return sessionServer;
	}

	public void setSessionServer(RMISimulationRelayer sessionServer) {
		this.sessionServer = sessionServer;
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/bobrmiandnioclient.java
package rmi.simulation.client;

import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION2_PREFIX;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_2_X_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_COMMAND_Y_OFFSET;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_HEIGHT;
import static nio.manager.simulation.client.AnNIOManagerSimulationClient.SIMULATION_WIDTH;
public class BobRMIAndNIOClient {
	public static void launchBob(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AnRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				SIMULATION2_PREFIX, 
				SIMULATION_2_X_OFFSET, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_2_X_OFFSET, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args));
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/rmiandniosimulationclient.java
package rmi.simulation.client;

import nio.manager.simulation.client.NIOManagerSimulationClient;

public interface RMIAndNIOSimulationClient extends NIOManagerSimulationClient{

	void initialize(String aServerHost, int aServerPort, String aClientName,
			String aPrefix, int anXOffset, int aYOffset, int aWidth,
			int aHeight, int aCommandWindowXOffset, int aCommandWindowYOffset,
			String anRMIRegistryHost, int anRMIRegistryPort);
	
}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/rmisimulationoutcoupler.java
package rmi.simulation.client;

import java.beans.PropertyChangeListener;

import rmi.simulation.common.RMISimulationRelayer;

public interface RMISimulationOutCoupler extends PropertyChangeListener{
	public RMISimulationRelayer getSessionServer() ;

	public void setSessionServer(RMISimulationRelayer sessionServer);

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/twophase/atwophasermiandniosimulationclient.java
package rmi.simulation.client.twophase;

import rmi.simulation.client.AnRMIAndNIOSimulationClient;
import rmi.simulation.client.AnRMISimulationInCoupler;
import rmi.simulation.common.RMISimulationInCoupler;

public class ATwoPhaseRMIAndNIOSimulationClient extends AnRMIAndNIOSimulationClient{
	@Override
	protected RMISimulationInCoupler createRMIInCoupler() {
		return new ATwoPhaseRMISimulationInCoupler(commandProcessor);
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/twophase/atwophasermisimulationincoupler.java
package rmi.simulation.client.twophase;

import java.rmi.RemoteException;

import nio.manager.simulation.client.AnNIOManagerSimulationClient;
import assignments.util.MiscAssignmentUtils;
import rmi.simulation.client.AnRMISimulationInCoupler;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationInCoupler;
import stringProcessors.HalloweenCommandProcessor;
import util.interactiveMethodInvocation.IPCMechanism;
import util.trace.port.consensus.ProposalAcceptRequestReceived;
import util.trace.port.consensus.ProposalAcceptedNotificationSent;
import util.trace.port.consensus.communication.CommunicationStateNames;

public class ATwoPhaseRMISimulationInCoupler extends AnRMISimulationInCoupler
		implements TwoPhaseRMISimulationInCoupler {

	public ATwoPhaseRMISimulationInCoupler(
			HalloweenCommandProcessor aCommandProcessor) {
		super(aCommandProcessor);
	}

	@Override
	public boolean acceptRemoteBroadcastMode(boolean newValue)
			throws RemoteException {
		ProposalAcceptRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
		boolean retVal = !AnNIOManagerSimulationClient.getNIOManagerSimulationClient().isRejectMetaStateChange();
		ProposalAcceptedNotificationSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue, MiscAssignmentUtils.toProposalFeedbackKind(retVal));
		return retVal;
	}

	@Override
	public boolean acceptRemoteIPCMechanism(IPCMechanism newValue)
			throws RemoteException {
		ProposalAcceptRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
		boolean retVal = !AnNIOManagerSimulationClient.getNIOManagerSimulationClient().isRejectMetaStateChange();
		ProposalAcceptedNotificationSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue, MiscAssignmentUtils.toProposalFeedbackKind(retVal));

		return retVal;
	}

	@Override
	public boolean acceptNewCommand(String newValue) throws RemoteException {
		ProposalAcceptRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, newValue);
		boolean retVal = !AnNIOManagerSimulationClient.getNIOManagerSimulationClient().isRejectMetaStateChange();
		ProposalAcceptedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, newValue, MiscAssignmentUtils.toProposalFeedbackKind(retVal));
		return retVal;
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/client/twophase/package-info.java
/**
 * 
 */
/**
 * @author dewan
 *
 */
package rmi.simulation.client.twophase;
//END OF FILE
//START OF FILE: src/rmi/simulation/common/rmisimulationincoupler.java
package rmi.simulation.common;

import java.rmi.Remote;
import java.rmi.RemoteException;

import util.interactiveMethodInvocation.IPCMechanism;

public interface RMISimulationInCoupler extends Remote {
	public void processCommand(String aCommand) throws RemoteException;
	public void newRemoteBroadcastMode(boolean newValue) throws RemoteException;
	public void newRemoteIPCMechanism(IPCMechanism newValue) throws RemoteException;

}
//END OF FILE
//START OF FILE: src/rmi/simulation/common/rmisimulationrelayer.java
package rmi.simulation.common;

import java.rmi.Remote;
import java.rmi.RemoteException;

import util.interactiveMethodInvocation.IPCMechanism;


public interface RMISimulationRelayer extends Remote {
	void join (String aName, RMISimulationInCoupler aClient) throws RemoteException ;
	void leave (String aName) throws RemoteException;
	void broadcast (String aSource, String aCommand) throws RemoteException;
	void broadcastBroadcastMode(String aSource, boolean newValue)
			throws RemoteException;
	void broadcastIPCMechanism(String aSource, IPCMechanism newValue)
			throws RemoteException;

}
//END OF FILE
//START OF FILE: src/rmi/simulation/common/rmisimulationserverlauncher.java
package rmi.simulation.common;

public interface RMISimulationServerLauncher {
	public static String SESSION_SERVER = "session server";


}
//END OF FILE
//START OF FILE: src/rmi/simulation/common/twophase/twophasermisimulationincoupler.java
package rmi.simulation.common.twophase;

import java.rmi.RemoteException;

import rmi.simulation.common.RMISimulationInCoupler;
import util.interactiveMethodInvocation.IPCMechanism;

public interface TwoPhaseRMISimulationInCoupler extends RMISimulationInCoupler{
	public boolean acceptRemoteBroadcastMode(boolean newValue) throws RemoteException;
	public boolean acceptRemoteIPCMechanism(IPCMechanism newValue) throws RemoteException;
	public boolean acceptNewCommand(String newValue) throws RemoteException;

}
//END OF FILE
//START OF FILE: src/rmi/simulation/common/twophase/twophasermisimulationrelayer.java
package rmi.simulation.common.twophase;

import java.rmi.RemoteException;

import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationRelayer;

public interface TwoPhaseRMISimulationRelayer extends RMISimulationRelayer {
	void join (String aName, TwoPhaseRMISimulationInCoupler aClient) throws RemoteException ;

}
//END OF FILE
//START OF FILE: src/rmi/simulation/common/twophase/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package rmi.simulation.common.twophase;
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/alicermiandniosimulationlauncher.java
package rmi.simulation.launcher;

import rmi.simulation.client.AliceRMIAndNIOClient;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
public class AliceRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		
		String[] myArgs = {
				"localhost", 
				RMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Alice",
				"false",
				"localhost",
				RMIRegistryLauncher.RMI_PORT};
		
		AliceRMIAndNIOClient.launchAlice(myArgs);
		
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/alicesimulationrmiclient.java
package rmi.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.AliceCommandProcessorFactory;
import common.controller.AliceControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.AliceUI;
import rmi.simulation.client.AnRMISimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class AliceSimulationRMIClient implements AliceUI {
	public static String SERVER_HOST = "localhost";

public static void main(String[] args) {
	Tracer.showWarnings(false);
	OEFrame oeFrame = AliceControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = AliceCommandProcessorFactory.getOrCreateSingleton();
	AnRMISimulationClientLauncher.launchClient( NAME, aCommandProcessor, true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();
  }
}

//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/bobrmiandniosimulationlauncher.java
package rmi.simulation.launcher;

import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.client.BobRMIAndNIOClient;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;

public class BobRMIAndNIOSimulationLauncher {
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		
		String[] myArgs = {
				"localhost", 
				RMIAndNIOServerLauncher.NIO_SERVER_PORT,
				"Bob",
				"false",
				"localhost",
				RMIRegistryLauncher.RMI_PORT};
		
		BobRMIAndNIOClient.launchBob(myArgs);
		
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/bobsimulationrmiclient.java
package rmi.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.BobCommandProcessorFactory;
import common.controller.BobControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.BobUI;
import rmi.simulation.client.AnRMISimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class BobSimulationRMIClient implements BobUI {


	
public static void main(String[] args) {
	Tracer.showWarnings(false);
	OEFrame oeFrame = BobControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor = BobCommandProcessorFactory.getOrCreateSingleton();
	AnRMISimulationClientLauncher.launchClient(NAME, aCommandProcessor, true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();



  }
}

//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/cathysimulationrmiclient.java
package rmi.simulation.launcher;

import bus.uigen.OEFrame;
import common.commandprocessor.CathyCommandProcessorFactory;
import common.controller.CathyControllerUI;
import common.controller.TrickOrTreatClientControllerFactory;
import common.ui.CathyUI;
import rmi.simulation.client.AnRMISimulationClientLauncher;
import stringProcessors.HalloweenCommandProcessor;
import util.trace.Tracer;



public class CathySimulationRMIClient implements CathyUI {

	
public static void main(String[] args) {
	Tracer.showWarnings(false);
	OEFrame oeFrame = CathyControllerUI.createUI();
	HalloweenCommandProcessor aCommandProcessor =CathyCommandProcessorFactory.getOrCreateSingleton();
	AnRMISimulationClientLauncher.launchClient(NAME, aCommandProcessor, true);
	TrickOrTreatClientControllerFactory.getOrCreateSingleton().executeCommandLoop();
  }
}

//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/clientrmiandniosimulationlauncher.java
package rmi.simulation.launcher;

import common.ui.AliceUI;
import assignments.util.MiscAssignmentUtils;
import assignments.util.mainArgs.ClientArgsProcessor;
import rmi.simulation.client.AliceRMIAndNIOClient;
import rmi.simulation.client.AnRMIAndNIOSimulationClient;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
@Tags({DistributedTags.CLIENT, DistributedTags.RMI})
public class ClientRMIAndNIOSimulationLauncher implements AliceUI   {
	public static void main(String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		MiscAssignmentUtils.setHeadless(ClientArgsProcessor.getHeadless(args));
		AnRMIAndNIOSimulationClient.launchClient(
				ClientArgsProcessor.getServerHost(args), 
				ClientArgsProcessor.getServerPort(args), 
				ClientArgsProcessor.getClientName(args), 
				"1:", 
				0, SIMULATION_COMMAND_Y_OFFSET,
				SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0,
				ClientArgsProcessor.getRegistryHost(args),
				ClientArgsProcessor.getRegistryPort(args));
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/interactivedemoerofrmisimulation.java
package rmi.simulation.launcher;

import rmi.simulation.registry.ADistributedRMIRegistryStarter;
import rmi.simulation.server.AnRMISimulationServerLauncher;

public class InteractiveDemoerOfRMISimulation {
	public static void main(String args[]) {
		demo();
	}
	
	public static void demo() {
//		String currentDir = System.getProperty("user.dir");
//        System.out.println("Current dir using System:" +currentDir);
		
		Class[] classes = {
				ADistributedRMIRegistryStarter.class,
				AnRMISimulationServerLauncher.class,
				AliceSimulationRMIClient.class,
				BobSimulationRMIClient.class,
				CathySimulationRMIClient.class

				
		};
//		MainClassLaunchingUtility.interactiveLaunch(classes);
		bus.uigen.pipe.MainClassLaunchingUtility.createInteractiveLauncher(classes);
	}
	
	

}
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/rmiandnioserverlauncher.java
package rmi.simulation.launcher;

import rmi.simulation.server.AnRMIAndNIOSimulationServer;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
public class RMIAndNIOServerLauncher {
	public static final String NIO_SERVER_PORT = "2090";
	public static void main (String[] args) {
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();
		
		String[] myArgs = {NIO_SERVER_PORT, "localhost", RMIRegistryLauncher.RMI_PORT};
		AnRMIAndNIOSimulationServer.launch(myArgs);
	}

}
//END OF FILE
//START OF FILE: src/rmi/simulation/launcher/rmiregistrylauncher.java
package rmi.simulation.launcher;

import java.rmi.registry.LocateRegistry;
import java.util.Scanner;

import rmi.simulation.registry.ADistributedRMIRegistryStarter;

import assignments.util.mainArgs.ServerArgsProcessor;
import assignments.util.mainArgs.ServerPort;
import util.annotations.Tags;
import util.tags.DistributedTags;
import util.trace.bean.BeanTraceUtility;
import util.trace.factories.FactoryTraceUtility;
import util.trace.misc.ThreadDelayed;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMITraceUtility;
public class RMIRegistryLauncher {
	public static final String RMI_PORT = "2099";
	public static void main (String[] args) {
		String[] myArgs = {RMI_PORT};
		
		FactoryTraceUtility.setTracing();
		BeanTraceUtility.setTracing();
		NIOTraceUtility.setTracing();
		RMITraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		ThreadDelayed.enablePrint();

		ADistributedRMIRegistryStarter.launch(args);
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/registry/adistributedrmiregistrystarter.java
package rmi.simulation.registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Scanner;

import util.annotations.DisplayToString;
import util.annotations.Tags;
import util.tags.DistributedTags;
import assignments.util.mainArgs.RegistryArgsProcessor;
import assignments.util.mainArgs.ServerArgsProcessor;

@Tags({DistributedTags.REGISTRY, DistributedTags.RMI})
public class ADistributedRMIRegistryStarter {
	public static void launch (String[] args) {
		try {
			Registry aRegistry = LocateRegistry.createRegistry(RegistryArgsProcessor.getRegistryPort(args));
			// Keep server alive, wait indefinitely			
			synchronized(aRegistry) {
				aRegistry.wait();				
			}
//			Scanner scanner = new Scanner(System.in);
//			scanner.nextLine();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/anrmiandniosimulationserver.java
package rmi.simulation.server;


import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import assignments.util.mainArgs.ServerArgsProcessor;
import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import nio.manager.simulation.server.NIOManagerSimulationServer;
import common.controller.ServerControllerUI;
import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.launcher.RMIRegistryLauncher;
import util.annotations.DisplayToString;
import util.annotations.Tags;
import util.interactiveMethodInvocation.IPCMechanism;
import util.interactiveMethodInvocation.SimulationParametersControllerFactory;
import util.tags.DistributedTags;
import util.trace.Tracer;
import util.trace.port.consensus.ConsensusTraceUtility;
import util.trace.port.nio.NIOTraceUtility;
import util.trace.port.rpc.rmi.RMIObjectRegistered;
import util.trace.port.rpc.rmi.RMIRegistryLocated;

@Tags({DistributedTags.SERVER, DistributedTags.RMI, DistributedTags.NIO})
public class AnRMIAndNIOSimulationServer 
		extends AnNIOManagerSimulationServer 
		implements RMIAndNIOSimulationServer
{
	protected RMISimulationRelayer createRMIRelayer() {
		return new AnRMISimulationRelayer();
	}
	protected void registerRelayer(int aServerPort, String aRegistryHost, int aRegistryPort) {
		try {
			Registry rmiRegistry = LocateRegistry.getRegistry(aRegistryHost, aRegistryPort);
			RMIRegistryLocated.newCase(this, aRegistryHost, aRegistryPort, rmiRegistry);
			RMISimulationRelayer aRelayer = createRMIRelayer();
			UnicastRemoteObject.exportObject(aRelayer, 0);
			rmiRegistry.rebind(SESSION_SERVER, aRelayer);
			RMIObjectRegistered.newCase(this, SESSION_SERVER, aRelayer, rmiRegistry);
			
		} catch (Exception e) {
			e.printStackTrace();
		}		
	}
	public void initialize(int aServerPort, String aRegistryHost, int aRegistryPort) {
		super.initialize(aServerPort);
		registerRelayer(aServerPort, aRegistryHost, aRegistryPort);
//		try {
//			Registry rmiRegistry = LocateRegistry.getRegistry(aRegistryHost, aRegistryPort);
//			RMIRegistryLocated.newCase(this, aRegistryHost, aRegistryPort, rmiRegistry);
//			RMISimulationSessionServer aRelayer = new AnRMISimulationRelayer();
//			UnicastRemoteObject.exportObject(aRelayer, 0);
//			rmiRegistry.rebind(SESSION_SERVER, aRelayer);
//			RMIObjectRegistered.newCase(this, SESSION_SERVER, aRelayer, rmiRegistry);
//			
//		} catch (Exception e) {
//			e.printStackTrace();
//		}		
	}
	
	public static void launch(String[] args) {
		args = ServerArgsProcessor.removeEmpty(args);
		RMIAndNIOSimulationServer aServer = 
				new AnRMIAndNIOSimulationServer();
		nioManagerSimulationServer = aServer;
		aServer.initialize(
				ServerArgsProcessor.getServerPort(args),
				ServerArgsProcessor.getRegistryHost(args),
				ServerArgsProcessor.getRegistryPort(args));
		SimulationParametersControllerFactory.getSingleton().processCommands();
	}
	
	

	
	public static void main (String[] args) {
		NIOTraceUtility.setTracing();
		ConsensusTraceUtility.setTracing();
		AnRMIAndNIOSimulationServer.launch(args);
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/anrmisimulationrelayer.java
package rmi.simulation.server;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import common.controller.TrickOrTreatClientControllerFactory;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationRelayer;
import util.interactiveMethodInvocation.IPCMechanism;
import util.misc.ClearanceManagerFactory;
import util.remote.RelayerController;
import util.remote.RelayerControllerFactory;
import util.trace.port.consensus.ProposalLearnedNotificationSent;
import util.trace.port.consensus.RemoteProposeRequestReceived;
import util.trace.port.consensus.communication.CommunicationStateNames;

public class AnRMISimulationRelayer implements RMISimulationRelayer {
	protected Map<String, RMISimulationInCoupler> clients = new HashMap();
//	List<String> clientNames = new ArrayList();

	@Override
	public void join(String aName, RMISimulationInCoupler aClient)
			throws RemoteException {
		clients.put(aName, aClient);
//		clientNames.add(aName);
		RelayerControllerFactory.getOrCreateSingleton().setRelayClients(clients.keySet().toString());

		
	}

	@Override
	public void leave(String aName) throws RemoteException {
		clients.remove(aName);
//		clientNames.remove(aName);
		RelayerControllerFactory.getOrCreateSingleton().setRelayClients(clients.keySet().toString());

		
	}
	
	protected void maybeWaitForRelay() {
		RelayerController aRelayerController =  RelayerControllerFactory.getOrCreateSingleton();
		if (aRelayerController.isWaitForRelay()) {
			ClearanceManagerFactory.getOrCreateClearanceManager().waitForClearance();
		}

	}
	@Override
	public void broadcast(String aSource, String aCommand) throws RemoteException {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);
		doBroadcast(aSource, aCommand);
	}

	protected void doBroadcast(String aSource, String aCommand) throws RemoteException {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		for (String clientName:sortedClientNames) {
			if (aSource.equals(clientName) && !AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast())
				continue;
//			if (!TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend()) {
//				maybeWaitForRelay();
//			};
			ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);

			clients.get(clientName).processCommand(aCommand);
		}		
	}
	@Override
	public void broadcastBroadcastMode(String aSource, boolean newValue) throws RemoteException {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
		doBroadcastBroadcastMode(aSource, newValue);

	}
	
	protected void doBroadcastBroadcastMode(String aSource, boolean newValue) throws RemoteException {
//		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		for (String clientName:sortedClientNames) {
//			if (aSource.equals(clientName) && !AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast())
//				continue;
////			if (!TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend()) {
////				maybeWaitForRelay();
////			};
			ProposalLearnedNotificationSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
			clients.get(clientName).newRemoteBroadcastMode(newValue);
		}	
		AnNIOManagerSimulationServer.getNIOManagerSimulationServer().setAtomicBroadcast(newValue);
		
	}
	@Override
	public void broadcastIPCMechanism(String aSource, IPCMechanism newValue) throws RemoteException {
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
		doBroadcastIPCMechanism(aSource, newValue);
	}
//	@Override
	protected void doBroadcastIPCMechanism(String aSource, IPCMechanism newValue) throws RemoteException {
//		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		for (String clientName:sortedClientNames) {
//			if (aSource.equals(clientName) && !AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast())
//				continue;
////			if (!TrickOrTreatClientControllerFactory.getOrCreateSingleton().getSendReceiveSettings().maybeDelaySend()) {
////				maybeWaitForRelay();
////			};
			
			clients.get(clientName).newRemoteIPCMechanism(newValue);
		}		
	}
	

}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/anrmisimulationserverlauncher.java
package rmi.simulation.server;


import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import common.controller.ServerControllerUI;
import rmi.simulation.common.RMISimulationServerLauncher;
import rmi.simulation.common.RMISimulationRelayer;



public class AnRMISimulationServerLauncher implements RMISimulationServerLauncher {	
	public static void main (String[] args) {
		try {
			ServerControllerUI.createUI();
			Registry rmiRegistry = LocateRegistry.getRegistry();
			RMISimulationRelayer session = new AnRMISimulationRelayer();
			UnicastRemoteObject.exportObject(session, 0);
//			UnicastRemoteObject.exportObject(counterRepository, 0);
			rmiRegistry.rebind(SESSION_SERVER, session);
			
		} catch (Exception e) {
			e.printStackTrace();
		}		
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/rmiandniosimulationserver.java
package rmi.simulation.server;

import rmi.simulation.common.RMISimulationServerLauncher;
import nio.manager.simulation.server.NIOManagerSimulationServer;

public interface RMIAndNIOSimulationServer extends NIOManagerSimulationServer, RMISimulationServerLauncher {
	void initialize(int aServerPort, String aRegistryHost, int aRegistryPort);

}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/twophase/atwophasermiandniosimulationserver.java
package rmi.simulation.server.twophase;

import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationRelayer;
import rmi.simulation.server.AnRMIAndNIOSimulationServer;
import rmi.simulation.server.AnRMISimulationRelayer;

public class ATwoPhaseRMIAndNIOSimulationServer extends AnRMIAndNIOSimulationServer  {
	@Override
	protected TwoPhaseRMISimulationRelayer createRMIRelayer() {
		return new ATwoPhaseRMISimulationRelayer();
	}
}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/twophase/atwophasermisimulationrelayer.java
package rmi.simulation.server.twophase;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import nio.manager.simulation.server.AnNIOManagerSimulationServer;
import common.controller.TrickOrTreatClientControllerFactory;
import consensus.ProposalFeedbackKind;
import rmi.simulation.common.RMISimulationInCoupler;
import rmi.simulation.common.RMISimulationRelayer;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationInCoupler;
import rmi.simulation.common.twophase.TwoPhaseRMISimulationRelayer;
import rmi.simulation.server.AnRMISimulationRelayer;
import util.interactiveMethodInvocation.ConsensusAlgorithm;
import util.interactiveMethodInvocation.IPCMechanism;
import util.misc.ClearanceManagerFactory;
import util.remote.RelayerController;
import util.remote.RelayerControllerFactory;
import util.trace.port.consensus.ProposalAcceptRequestReceived;
import util.trace.port.consensus.ProposalAcceptRequestSent;
import util.trace.port.consensus.ProposalAcceptedNotificationReceived;
import util.trace.port.consensus.ProposalAcceptedNotificationSent;
import util.trace.port.consensus.ProposalLearnedNotificationSent;
import util.trace.port.consensus.RemoteProposeRequestReceived;
import util.trace.port.consensus.communication.CommunicationStateNames;

public class ATwoPhaseRMISimulationRelayer extends AnRMISimulationRelayer implements  TwoPhaseRMISimulationRelayer  {
//	Map<String, RMISimulationInCoupler> clients = new HashMap();
//	List<String> clientNames = new ArrayList();

	@Override
	public void join(String aName, TwoPhaseRMISimulationInCoupler aClient)
			throws RemoteException {
		super.join(aName, aClient);

		
	}
	@Override
	public void broadcast(String aSource, String aCommand) throws RemoteException {
		if (!AnNIOManagerSimulationServer.getNIOManagerSimulationServer().isAtomicBroadcast() ||
				AnNIOManagerSimulationServer.getNIOManagerSimulationServer().getConsensusAlgorithm() == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {
			super.broadcast(aSource, aCommand);
			return;
		}
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		boolean anAllAccept = true;
		for (String clientName:sortedClientNames) {
			ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand);
			boolean anAccept = ((TwoPhaseRMISimulationInCoupler) (clients.get(clientName))).acceptNewCommand(aCommand);
			ProposalFeedbackKind aProposalFeedbackKind = anAccept?ProposalFeedbackKind.SUCCESS:ProposalFeedbackKind.SERVICE_DENIAL;
			ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.COMMAND, -1, aCommand, aProposalFeedbackKind);
			anAllAccept = anAccept && anAllAccept;
		}
		if (!anAllAccept) {
			return;
		}
		super.doBroadcast(aSource, aCommand);
	}
	@Override
	public void broadcastBroadcastMode(String aSource, boolean newValue) throws RemoteException {
		if (AnNIOManagerSimulationServer.getNIOManagerSimulationServer().getConsensusAlgorithm() == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {
			super.broadcastBroadcastMode(aSource, newValue);
			return;
		}
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		boolean anAllAccept = true;
		for (String clientName:sortedClientNames) {
			ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue);
			boolean anAccept = ((TwoPhaseRMISimulationInCoupler) (clients.get(clientName))).acceptRemoteBroadcastMode(newValue);
			ProposalFeedbackKind aProposalFeedbackKind = anAccept?ProposalFeedbackKind.SUCCESS:ProposalFeedbackKind.SERVICE_DENIAL;
			ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.BROADCAST_MODE, -1, newValue, aProposalFeedbackKind);
			anAllAccept = anAccept;
		}	
		if (!anAllAccept) {
			return;
		}
		super.doBroadcastBroadcastMode(aSource, newValue);		
	}
	@Override
	public void broadcastIPCMechanism(String aSource, IPCMechanism newValue) throws RemoteException {
		if (AnNIOManagerSimulationServer.getNIOManagerSimulationServer().getConsensusAlgorithm() == ConsensusAlgorithm.CENTRALIZED_ASYNCHRONOUS) {
			super.broadcastIPCMechanism(aSource, newValue);
			return;
		}
		RemoteProposeRequestReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
		Set<String> clientNames = clients.keySet();
		List<String> sortedClientNames = new ArrayList(clientNames);
		Collections.sort(sortedClientNames);
		boolean anAllAccept = true;
		for (String clientName:sortedClientNames) {
			ProposalAcceptRequestSent.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue);
			boolean anAccept = ((TwoPhaseRMISimulationInCoupler) (clients.get(clientName))).acceptRemoteIPCMechanism(newValue);
			ProposalFeedbackKind aProposalFeedbackKind = anAccept?ProposalFeedbackKind.SUCCESS:ProposalFeedbackKind.SERVICE_DENIAL;
			ProposalAcceptedNotificationReceived.newCase(this, CommunicationStateNames.IPC_MECHANISM, -1, newValue, aProposalFeedbackKind);
			anAllAccept = anAccept;
		}	
		if (!anAllAccept) {
			return;
		}
		super.doBroadcastIPCMechanism(aSource, newValue);	
	}
	

}
//END OF FILE
//START OF FILE: src/rmi/simulation/server/twophase/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package rmi.simulation.server.twophase;
//END OF FILE
//START OF FILE: src/serialization/logical/abeanserializer.java
package serialization.logical;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.NotSerializableException;
import java.io.Serializable;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;

import util.misc.RemoteReflectionUtility;
import util.misc.Transient;
import util.trace.Tracer;


public class ABeanSerializer extends AnAbstractSerializer implements ValueSerializer {
	Object[] nullArgs = {};
	protected final String[] ignoreProperties = {"Class", "class"};
	protected final List<String> ignorePropertiesList = Arrays.asList(ignoreProperties);

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		Class aClass = anObject.getClass();	
		if (!(anObject instanceof Serializable))
			throw new NotSerializableException(anObject + " is not Serializable");

		visitedObjects.add(anObject);
		Tracer.info(this, "Added  serialized object " + anObject + " at index: " + (visitedObjects.size() - 1));

		
		try  {
			BeanInfo beanInfo = Introspector.getBeanInfo(aClass);
			PropertyDescriptor[] properties = beanInfo.getPropertyDescriptors();
			for (int i = 0; i < properties.length; i++) {
				PropertyDescriptor property = properties[i];
				if (ignoreProperty(property))
					continue;
				if (property.getReadMethod() == null || RemoteReflectionUtility.isTransient(property.getReadMethod()) ||
						property.getWriteMethod() == null) {
					Tracer.warning("Unserializable property " + property.getName() + " of " + anObject + " as it does not have both getter and setter");
					continue;
				}
				Object component = property.getReadMethod().invoke(anObject, nullArgs);
				ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, component, visitedObjects);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new NotSerializableException(e.getMessage());
		}		

	}
//	@Override
//	void objectToBuffer (ByteBuffer anOutputBuffer, Object anObject, Class aClass, List visitedObjects)  {
//		try {
//			List<Object> visitedObjects = new ArrayList();
//			objectToBuffer(anOutputBuffer, anObject, aClass, visitedObjects);
//		} catch (Exception e) {
//			e.printStackTrace();
//		}		
//	}
//	@Override
//	public Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
//		try {
//			String typeName = stringFromBuffer(anInputBuffer);
////			List visitedObjects = new ArrayList();
//			Class type;
//			if (typeName.equals(NUll_TYPE_NAME)) {
//				String nullValue = stringFromBuffer(anInputBuffer);
//				if (nullValue.equals(NULL_REPRESENTATION))
//					return null;
//				else
//					throw new StreamCorruptedException("Illegal null representation:" + nullValue);
//				
//			} else {
//				type = ReflectionUtility.forName(typeName);
//				Serializer serializer;
//				if (type.isArray()) {
//					
//				}
//				return objectFromBuffer(anInputBuffer, type, retrievedObjects);
//			}
//			
//			
//		} catch (Exception e) {
//			StreamCorruptedException streamCorruptedException = new StreamCorruptedException( e.getMessage());
//			throw streamCorruptedException;	
//		}		
//	}
//	@Override
//	void objectToBuffer (ByteBuffer anOutputBuffer, Object anObject, Class aClass, List aVisitedObjects) throws NotSerializableException {
//		Serializer serializer = ABufferCustomSerializationSupport.getLeafSerializer(aClass);
//		if (serializer != null)
//			serializer.objectToBuffer(anOutputBuffer, anObject, aVisitedObjects);
//		else if (aClass.isArray()) {
//			serializer = ABufferCustomSerializationSupport.getArraySerializer();
//			serializer.objectToBuffer(anOutputBuffer, anObject, aVisitedObjects);
//		} else {
//			beanToBuffer(anOutputBuffer, anObject, aClass, aVisitedObjects);
//		}
//		
//	}
//	void beanToBuffer(ByteBuffer anOutputBuffer, Object anObject, Class aClass, 
//			List visitedObjects) throws NotSerializableException {
//		if (visitedObjects.contains(visitedObjects)) {
//			throw new NotSerializableException(anObject + " has multiple parents");
//		}
//		if (!(Serializable.class.isAssignableFrom(aClass)))
//				throw new NotSerializableException(aClass + " is not Serializable");
//		try  {
//			BeanInfo beanInfo = Introspector.getBeanInfo(aClass);
//			PropertyDescriptor[] properties = beanInfo.getPropertyDescriptors();
//			for (int i = 0; i < properties.length; i++) {
//				PropertyDescriptor property = properties[i];
//				if (property.getReadMethod() == null || 
//						property.getWriteMethod() == null)
//					continue;
//				Object component = property.getReadMethod().invoke(anObject, nullArgs);
////				stringToBuffer(anOutputBuffer, property.getName());
//				ABufferCustomSerializationSupport.getTopSerializer().objectToBuffer(anOutputBuffer, component, visitedObjects);
//			}
//		} catch (Exception e) {
//			throw new NotSerializableException(e.getMessage());
//		}		
//	}
	
//	@Override
//	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass) throws StreamCorruptedException {
//		try {
//			Serializer serializer = ABufferCustomSerializationSupport.getLeafSerializer(aClass);
//			if (serializer != null) {
//				return serializer.objectFromBuffer(anInputBuffer, aClass);
//			} else if (aClass.isArray()) {
//				serializer = ABufferCustomSerializationSupport.getArraySerializer();
//				return serializer.objectFromBuffer(anInputBuffer, aClass);				
//			} else {
//				return beanFromBuffer(anInputBuffer, aClass);
//			}		
//			
//		} catch (Exception e) {
//			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
//			throw streamCorruptedException;	
//		}		
//	}
	
	static PropertyDescriptor getProperty(PropertyDescriptor[] properties, String name) {
		for (int i = 0; i < properties.length; i++) {
			PropertyDescriptor property = properties[i];
			if (property.getName().equals(name)) {
				return property;
			}
		}
		return null;
	}
	
	protected boolean ignoreProperty(PropertyDescriptor aProperty) {
		return 
				ignorePropertiesList.contains(aProperty.getName()) ||
				aProperty.getReadMethod() == null ||				
				aProperty.getReadMethod().getAnnotation(Transient.class) != null;
				
				}
	
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException {
		Object retVal;
		Class serializedClass = ALogicalStructureSerializer.getDeserializingClass(aClass);

		try {

			Tracer.info(this, "Creating new instanceof class:" + aClass);
			 retVal = serializedClass.newInstance();
			 retrievedObjects.add(retVal);
			 Tracer.info(this, "Added deserialized object " + retVal + " at index: " + (retrievedObjects.size()-1));

		} catch (Exception e) {
//			e.printStackTrace();
			throw new StreamCorruptedException("Cannot deserialize class " + aClass + " as it has  no null constructor or an erroneous one or an invalid toString");
		}
		try  {
			BeanInfo beanInfo = Introspector.getBeanInfo(serializedClass);
			PropertyDescriptor[] properties = beanInfo.getPropertyDescriptors();
//			String propertyName = stringFromBuffer(anInputBuffer);
			for (int i = 0; i < properties.length; i++) {
				PropertyDescriptor property = properties[i];
				if (ignoreProperty(property))
					continue;
				if (property.getReadMethod() == null || 
						property.getWriteMethod() == null) {
					Tracer.warning("Unserializable property " + property.getName() + " of " + retVal + " as it does not have both getter and setter");
					continue;
				}
				Object component = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				Object[] args = {component};
				property.getWriteMethod().invoke(retVal, args);
			}		
			
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
		RemoteReflectionUtility.invokeInitSerializedObject(retVal);
		return retVal;
		
	}


}
//END OF FILE
//START OF FILE: src/serialization/logical/abooleanserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;


public class ABooleanSerializer extends AnAbstractSerializer {

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
		try {
			Integer retVal = anInputBuffer.getInt();	
			boolean boolVal = retVal == 0? false:true;
			retrievedObjects.add(boolVal);
			Tracer.info(this, "Added deserialized boolean " + retVal + " at index: " + (retrievedObjects.size()-1));
			return boolVal;
		} catch (Exception e) {
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
			throw streamCorruptedException;	
		}
		
	}
	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object value, List visitedObjects) {
		Boolean boolVal = (Boolean) value;	
		int intVal = boolVal?1:0;
		visitedObjects.add(intVal);
		Tracer.info(this, "Added  serialized boolean " + value + " at index: " + (visitedObjects.size()-1));
		anOutputBuffer.putInt(intVal);
	}

	
	


}
//END OF FILE
//START OF FILE: src/serialization/logical/acollectionserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.List;

import util.trace.Tracer;


public class ACollectionSerializer extends AnAbstractSerializer implements ValueSerializer {
	
	
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			Tracer.info(this, "Deserializing object from:" + anInputBuffer);			
			int size = anInputBuffer.getInt();
//			int size = anInputBuffer.getInt();
			Class deserializedClass = ALogicalStructureSerializer.getDeserializingClass(aClass);
			Collection collection = (Collection) deserializedClass.newInstance();
			retrievedObjects.add(collection);
			for (int i = 0; i < size; i++)  {
				Object element = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				collection.add(element);
			}			
			return collection;
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		Tracer.info(this, "Serializing object:" + anObject);
		visitedObjects.add(anObject);
		Collection collection = (Collection) anObject;
		int size = collection.size();
		anOutputBuffer.putInt(size);
		for (Object element:collection) {
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, element, visitedObjects);
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/adispatchingserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import port.common.DistMisc;
import util.misc.RemoteReflectionUtility;
import util.trace.Tracer;


public class ADispatchingSerializer implements DispatchingSerializer {
	Object[] nullArgs = {};
	static String NUll_TYPE_NAME = "Null Class";
	static String NULL_REPRESENTATION = "null";
	static String REFERENCE_TYPE = "R T";
	@Override
	public void objectToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		if (anObject == null) {
			AnAbstractSerializer.stringToBuffer(anOutputBuffer, NUll_TYPE_NAME);
			AnAbstractSerializer.stringToBuffer(anOutputBuffer, NULL_REPRESENTATION);
		}   else {
			int index = DistMisc.indexOfReference(visitedObjects, anObject);
			if (index != -1) {
				Tracer.info(this, "Serializing: Object" + anObject + " duplicate of object: " + visitedObjects.get(index) + " at index: " + index);
				AnAbstractSerializer.stringToBuffer(anOutputBuffer, REFERENCE_TYPE);
				Tracer.info(this, "Putting int:" + index + " in buffer:" + anOutputBuffer);
				anOutputBuffer.putInt(index);
			} else {			
				Class aClass = anObject.getClass();
				ValueSerializer serializer = getSerializer(aClass);
				serializer.objectToBuffer(anOutputBuffer, anObject,  visitedObjects);
			}
		}
	}
	ValueSerializer getSerializer(Class type) {
		ValueSerializer serializer;
		if (type.isArray()) {
			return ALogicalStructureSerializer.getArraySerializer();
		} else  {
			serializer = ALogicalStructureSerializer.getValueSerializer(type);
			if (serializer != null) return serializer;
			if (type.isEnum()) 
				return ALogicalStructureSerializer.getEnumSerializer();
			if (RemoteReflectionUtility.isList(type))
					return ALogicalStructureSerializer.getListPatternSerializer();			
			return ALogicalStructureSerializer.getBeanSerializer();			
		}		
	}
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
		try {
			String typeName = AnAbstractSerializer.stringFromBuffer(anInputBuffer);
//			List visitedObjects = new ArrayList();
			Class type;
			if (typeName.equals(NUll_TYPE_NAME)) {
				String nullValue = AnAbstractSerializer.stringFromBuffer(anInputBuffer);
				if (nullValue.equals(NULL_REPRESENTATION))
					return null;
				else
					throw new StreamCorruptedException("Illegal null representation:" + nullValue);
				
			} else if (typeName.equals(REFERENCE_TYPE)) {
				int index = anInputBuffer.getInt();
				Tracer.info(this, "Deserializing: found reference at index: " + index + " of object "  + retrievedObjects.get(index));
				return retrievedObjects.get(index);
			} else 	{
				type = RemoteReflectionUtility.forName(typeName);
				ValueSerializer serializer = getSerializer(type);
				Object newObject = serializer.objectFromBuffer(anInputBuffer, type, retrievedObjects);
				return newObject;
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException( e.getMessage());
			throw streamCorruptedException;	
		}		
	}

	
	


}
//END OF FILE
//START OF FILE: src/serialization/logical/adoubleserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;


public class ADoubleSerializer extends AnAbstractSerializer {

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
		try {
			Object retVal = anInputBuffer.getDouble();	
			retrievedObjects.add(retVal);
			Tracer.info(this, "Added deserialized object " + retVal + " at index: " + (retrievedObjects.size()-1));
			return retVal;
		} catch (Exception e) {
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
			throw streamCorruptedException;	
		}
		
	}
	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object value, List visitedObjects) {
		visitedObjects.add(value);
		Tracer.info(this, "Added  serialized object " + value + " at index: " + (visitedObjects.size()-1));
		anOutputBuffer.putDouble((Double) value);
	}

	
	


}
//END OF FILE
//START OF FILE: src/serialization/logical/alistpatternserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.Serializable;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.misc.RemoteReflectionUtility;


public class AListPatternSerializer extends AnAbstractSerializer implements ValueSerializer {
	
	
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			if (!(Serializable.class.isAssignableFrom(aClass)))
				throw new NotSerializableException(aClass + " is not Serializable");
			int size = anInputBuffer.getInt();
			Class deserializedClass = ALogicalStructureSerializer.getDeserializingClass(aClass);
			Object list = deserializedClass.newInstance();
			retrievedObjects.add(list);
			for (int i = 0; i < size; i++)  {
				Object element = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				RemoteReflectionUtility.listAdd(list, element);
//				list.add(element);
			}			
			return list;
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		if (!(anObject instanceof Serializable))
			throw new NotSerializableException(anObject + " is not Serializable");
		visitedObjects.add(anObject);
//		List list = (List) anObject;
//		int size = list.size();
		int size = RemoteReflectionUtility.listSize(anObject);
		anOutputBuffer.putInt(size);
		for (int i = 0; i <  size; i++) {
//			ABufferCustomSerializationSupport.getTopSerializer().objectToBuffer(anOutputBuffer, list.get(i), visitedObjects);
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, RemoteReflectionUtility.listGet(anObject, i), visitedObjects);
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/alistserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

public class AListSerializer extends AnAbstractSerializer implements ValueSerializer {
	
	
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			int size = anInputBuffer.getInt();
			Class deserializedClass = ALogicalStructureSerializer.getDeserializingClass(aClass);
			List list = (List) deserializedClass.newInstance();
			retrievedObjects.add(list);
			for (int i = 0; i < size; i++)  {
				Object element = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				list.add(element);
			}			
			return list;
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		visitedObjects.add(anObject);
		List list = (List) anObject;
		int size = list.size();
		anOutputBuffer.putInt(size);
		for (int i = 0; i <  size; i++) {
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, list.get(i), visitedObjects);
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/alogicalstructureserializer.java
package serialization.logical;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import examples.serialization.AStringHistory;
import examples.serialization.AnotherStringHistory;
import serialization.Serializer;
import util.annotations.Tags;
import util.trace.Tracer;

@Tags("Type-Serializer Selector")
public class ALogicalStructureSerializer  implements Serializer {
	public static int OUTPUT_BUFFER_SIZE = 40960;
	static Map<Class, ValueSerializer> classToLeafSerializer = new HashMap();
	static Map<Class, Class> classToDeserializedClass = new HashMap();
	static ValueSerializer enumSerializer = new AnEnumSerializer();
	static DispatchingSerializer topSerializer = new ADispatchingSerializer();
	static ValueSerializer arraySerializer = new AnArraySerializer() ;
	static ValueSerializer beanSerializer = new ABeanSerializer();
	static ValueSerializer listPatternSerializer = new AListPatternSerializer();
//	public static int BYTES_IN_CHAR = Character.SIZE/Byte.SIZE;
	ByteBuffer outputBuffer = ByteBuffer.allocate(OUTPUT_BUFFER_SIZE);
//	ByteBuffer inputBuffer = ByteBuffer.allocate(BUFFER_SIZE);
	
	public static void registerValueSerializer(Class aClass, ValueSerializer anExternalSerializer) {
		classToLeafSerializer.put(aClass, anExternalSerializer);
	}
	public static void registerDeserializingClass(Class aClass, Class aDeserializedClass) {
		classToDeserializedClass.put(aClass, aDeserializedClass);
	}
	public static Class getDeserializingClass(Class aClass) {
		Class alternateClass = classToDeserializedClass.get(aClass);
		if (alternateClass == null) return aClass;
		return alternateClass;
	}
	public static ValueSerializer getValueSerializer(Class aClass) {
		return classToLeafSerializer.get(aClass);
	}
//	
//	public static boolean isLeaforPrimitive(Class aClass) {
//		return classToLeafSerializer.values().contains(aClass);
//	}
	
	public static DispatchingSerializer getDispatchingSerializer() {
		return topSerializer;
	}
	
	public static void  registerDispatchingSerializer(DispatchingSerializer newVal) {
		 topSerializer = newVal;
	}
	public static ValueSerializer getEnumSerializer() {
		return enumSerializer;
	}
	
	public static void  registerEnumSerializer(ValueSerializer newVal) {
		 enumSerializer = newVal;
	}
	
	public static ValueSerializer getArraySerializer() {
		return arraySerializer;
	}
	
	public static void  registerArraySerializer(ValueSerializer newVal) {
		 arraySerializer = newVal;
	}
	
	public static ValueSerializer getBeanSerializer() {
		return beanSerializer;
	}
	
	public static void  registerBeanSerializer(ValueSerializer newVal) {
		 beanSerializer = newVal;
	}
	
	public static ValueSerializer getListPatternSerializer() {
		return listPatternSerializer;
	}
	
	public static void  registerListPatternSerializer(ValueSerializer newVal) {
		listPatternSerializer = newVal;
	}

	@Override
	public Object objectFromInputBuffer(ByteBuffer anInputBuffer) {
		try {
			Tracer.info(this, "De serializing inputBuffer " + anInputBuffer);
			List retrievedObjects = new ArrayList();
			DispatchingSerializer objectSerializer = getDispatchingSerializer();
			return objectSerializer.objectFromBuffer(anInputBuffer, retrievedObjects);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	@Override
	public ByteBuffer outputBufferFromObject(Object object) {
		try {
		Tracer.info(this, "Serializing object " + object);
		DispatchingSerializer objectSerializer = getDispatchingSerializer();
		outputBuffer.position(0);
		outputBuffer.limit(outputBuffer.capacity());
		List visitedObjects = new ArrayList();
		objectSerializer.objectToBuffer(outputBuffer, object, visitedObjects);
		outputBuffer.flip();
		Tracer.info(this, "Finished Serializing object " + object + " outputBuffer:" + outputBuffer);

		return outputBuffer;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}	
	

	static {
		ALogicalStructureSerializer.registerValueSerializer(Integer.class, new AnIntegerSerializer());
		ALogicalStructureSerializer.registerValueSerializer(Boolean.class, new ABooleanSerializer());
		ALogicalStructureSerializer.registerValueSerializer(Double.class, new ADoubleSerializer());
		ALogicalStructureSerializer.registerValueSerializer(String.class, new AStringSerializer());
		ALogicalStructureSerializer.registerValueSerializer(HashSet.class, new ACollectionSerializer());
		ALogicalStructureSerializer.registerValueSerializer(ArrayList.class, new ACollectionSerializer());
		ALogicalStructureSerializer.registerValueSerializer(Vector.class, new ACollectionSerializer());
		ALogicalStructureSerializer.registerValueSerializer(HashMap.class, new AMapSerializer());
		ALogicalStructureSerializer.registerValueSerializer(Hashtable.class, new AMapSerializer());
		ALogicalStructureSerializer.registerArraySerializer(new AnArraySerializer());
		ALogicalStructureSerializer.registerBeanSerializer(new ABeanSerializer());
		ALogicalStructureSerializer.registerListPatternSerializer(new AListPatternSerializer());
		ALogicalStructureSerializer.registerDeserializingClass(ArrayList.class, Vector.class);
//		ACustomSerializer.registerDeserializingClass(ABMISpreadsheet.class, AnotherBMISpreadsheet.class);
//		ACustomSerializer.registerDeserializingClass(AnotherBMISpreadsheet.class, ABMISpreadsheet.class);
		ALogicalStructureSerializer.registerDeserializingClass(AStringHistory.class, AnotherStringHistory.class);
	}
	
}
//END OF FILE
//START OF FILE: src/serialization/logical/alogicalstructureserializerfactory.java
package serialization.logical;

import serialization.Serializer;
import serialization.SerializerFactory;

public class ALogicalStructureSerializerFactory implements SerializerFactory {
	public Serializer createSerializer() {
		return new ALogicalStructureSerializer();
//		return new ANonCopyingBufferSerializationSupport();
	}
}
//END OF FILE
//START OF FILE: src/serialization/logical/amapserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class AMapSerializer extends AnAbstractSerializer implements ValueSerializer {
	
	
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			int size = anInputBuffer.getInt();
			Map map = (Map) aClass.newInstance();
			retrievedObjects.add(map);
			for (int i = 0; i < size; i++)  {
				Object key = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				Object value = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				map.put(key, value);
			}			
			return map;
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		visitedObjects.add(anObject);
		Map map = (Map) anObject;
		int size = map.size();
		anOutputBuffer.putInt(size);
		Set keySet = map.keySet();
		for (Object key:keySet) {
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, key, visitedObjects);
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, map.get(key), visitedObjects);			
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/asetserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Set;

public class ASetSerializer extends AnAbstractSerializer implements ValueSerializer {
	
	
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			int size = anInputBuffer.getInt();
			Set list = (Set) aClass.newInstance();
			retrievedObjects.add(list);
			for (int i = 0; i < size; i++)  {
				Object element = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				list.add(element);
			}			
			return list;
		} catch (Exception e) {
			e.printStackTrace();
			throw new StreamCorruptedException(e.getMessage());
		}
	}
	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		visitedObjects.add(anObject);
		Set list = (Set) anObject;
		int size = list.size();
		anOutputBuffer.putInt(size);
		for (Object element:list) {
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, element, visitedObjects);
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/astringserializer.java
package serialization.logical;

import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;


public class AStringSerializer extends AnAbstractSerializer {

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException {
		try {
//			String representationString = representationFromBuffer(anInputBuffer);
			Object retVal = stringFromBuffer(anInputBuffer);
			retrievedObjects.add(retVal);
			Tracer.info(this, "Added deserialized object " + retVal + " at index: " + (retrievedObjects.size()-1));
			return retVal;
		} catch (Exception e) {
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
			throw streamCorruptedException;	
		}
		
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object value, List visitedObjects) {
		visitedObjects.add(value);
		Tracer.info(this, "Added  serialized object " + value + " at index: " + (visitedObjects.size()-1));
		String string = (String) value;
		stringToBuffer(anOutputBuffer, string);		
	}
	
	

}
//END OF FILE
//START OF FILE: src/serialization/logical/atopserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import port.common.DistMisc;
import util.misc.RemoteReflectionUtility;
import util.trace.Tracer;


public class ATopSerializer implements TopSerializer {
	Object[] nullArgs = {};
	static String NUll_TYPE_NAME = "Null Class";
	static String NULL_REPRESENTATION = "null";
	static String REFERENCE_TYPE = "R T";
	@Override
	public void objectToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
		if (anObject == null) {
			AnAbstractSerializer.stringToBuffer(anOutputBuffer, NUll_TYPE_NAME);
			AnAbstractSerializer.stringToBuffer(anOutputBuffer, NULL_REPRESENTATION);
		}   else {
			int index = DistMisc.indexOfReference(visitedObjects, anObject);
			if (index != -1) {
				Tracer.info(this, "Serializing: Object" + anObject + " duplicate of object: " + visitedObjects.get(index) + " at index: " + index);
				AnAbstractSerializer.stringToBuffer(anOutputBuffer, REFERENCE_TYPE);
				Tracer.info(this, "Putting int:" + index + " in buffer:" + anOutputBuffer);
				anOutputBuffer.putInt(index);
			} else {			
				Class aClass = anObject.getClass();
				ValueSerializer serializer = getSerializer(aClass);
				serializer.objectToBuffer(anOutputBuffer, anObject,  visitedObjects);
			}
		}
	}
	ValueSerializer getSerializer(Class type) {
		ValueSerializer serializer;
		if (type.isArray()) {
			return ALogicalStructureSerializer.getArraySerializer();
		} else  {
			// changed this from getLeafSerializer(type)
			serializer = ALogicalStructureSerializer.getValueSerializer(type);
			if (serializer != null) return serializer;
			if (type.isEnum()) 
				return ALogicalStructureSerializer.getEnumSerializer();
			if (RemoteReflectionUtility.isList(type))
					return ALogicalStructureSerializer.getListPatternSerializer();			
			return ALogicalStructureSerializer.getBeanSerializer();			
		}		
	}
	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
		try {
			String typeName = AnAbstractSerializer.stringFromBuffer(anInputBuffer);
//			List visitedObjects = new ArrayList();
			Class type;
			if (typeName.equals(NUll_TYPE_NAME)) {
				String nullValue = AnAbstractSerializer.stringFromBuffer(anInputBuffer);
				if (nullValue.equals(NULL_REPRESENTATION))
					return null;
				else
					throw new StreamCorruptedException("Illegal null representation:" + nullValue);
				
			} else if (typeName.equals(REFERENCE_TYPE)) {
				int index = anInputBuffer.getInt();
				Tracer.info(this, "Deserializing: found reference at index: " + index + " of object "  + retrievedObjects.get(index));
				return retrievedObjects.get(index);
			} else 	{
				type = RemoteReflectionUtility.forName(typeName);
				ValueSerializer serializer = getSerializer(type);
				Object newObject = serializer.objectFromBuffer(anInputBuffer, type, retrievedObjects);
				return newObject;
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException( e.getMessage());
			throw streamCorruptedException;	
		}		
	}

	
	


}
//END OF FILE
//START OF FILE: src/serialization/logical/anabstractserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;

public abstract class AnAbstractSerializer implements ValueSerializer {

	void objectToBuffer (ByteBuffer anOutputBuffer, Object object, String typeName, List visitedObjects) throws NotSerializableException {		
		stringToBuffer(anOutputBuffer, typeName);

		representationToBuffer(anOutputBuffer, object, visitedObjects);	
		
	}
	
	void objectToBuffer (ByteBuffer anOutputBuffer, Object object, Class aClass, List visitedObjects) throws NotSerializableException {
		objectToBuffer(anOutputBuffer, object, object.getClass().getName(), visitedObjects);
	}
	
//	void objectToBuffer (ByteBuffer anOutputBuffer, String aTypeName, String aRepresentation) {
//		stringToBuffer(anOutputBuffer, aTypeName);
//		stringToBuffer(anOutputBuffer, aRepresentation);		
//	}
//	
	abstract void representationToBuffer(ByteBuffer anOutputBuffer, 
			Object aValue, List visitedObjects) throws NotSerializableException;
	
	public static void stringToBuffer (ByteBuffer anOutputBuffer, String aString) {
		Tracer.info(AnAbstractSerializer.class, "will put string:"  + aString + " in buffer:" + anOutputBuffer);

		byte[] aStringBytes = aString.getBytes();
		anOutputBuffer.putInt(aStringBytes.length);
		anOutputBuffer.put(aStringBytes);
	}
	
	public static String stringFromBuffer(ByteBuffer anInputBuffer) throws StreamCorruptedException, NotSerializableException {
		try {
			int length = anInputBuffer.getInt();
//			Message.info("Creating byte array of length " + length);
			byte[] stringBytes = new byte[length];
			anInputBuffer.get(stringBytes);
			String retVal = new String(stringBytes);
			Tracer.info(AnAbstractSerializer.class, "Deserialized string:" + retVal + " from buffer:" + anInputBuffer);
			return retVal;
//			return new String(stringBytes);
		} catch (Exception e) {
			e.printStackTrace();
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException( e.getMessage());
			throw streamCorruptedException;			
		}		
	}
	
	@Override
	public void objectToBuffer(ByteBuffer anOutputBuffer, Object anObject, List visitedObjects) throws NotSerializableException{
//		if (anObject == null) {
//			objectToBuffer(anOutputBuffer, NUll_TYPE_NAME, NULL_REPRESENTATION, visitedObjects);
//		} else
			objectToBuffer(anOutputBuffer, anObject, anObject.getClass(), visitedObjects);
	}
	

	
//	String representationFromBuffer(ByteBuffer anInputBuffer) throws StreamCorruptedException {
//		try {
//			String typeString = stringFromBuffer(anInputBuffer);
//			Class typeClass = ReflectionUtility.forName(typeString);
//			String representationString = stringFromBuffer(anInputBuffer);
//			return representationString;
//		} catch (Exception e) {
//			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
//			throw streamCorruptedException;		
//		}		
//			
//	}
//	@Override
//	public Object objectFromBuffer(ByteBuffer anInputBuffer) throws StreamCorruptedException {
//		try {
//			String typeName = stringFromBuffer(anInputBuffer);
//			String objectRepresentation = stringFromBuffer(anInputBuffer);
//			
//			
//			
//		} catch (Exception e) {
//			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
//			throw streamCorruptedException;	
//		}		
//	}
	
//	public Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
//		try {
//			String typeName = stringFromBuffer(anInputBuffer);
////			List visitedObjects = new ArrayList();
//			Class type;
//			if (typeName.equals(NUll_TYPE_NAME)) {
//				String nullValue = stringFromBuffer(anInputBuffer);
//				if (nullValue.equals(NULL_REPRESENTATION))
//					return null;
//				else
//					throw new StreamCorruptedException("Illegal null representation:" + nullValue);
//				
//			} else {
//				type = ReflectionUtility.forName(typeName);				
//				return objectFromBuffer(anInputBuffer, type, retrievedObjects);
//			}
//			
//			
//		} catch (Exception e) {
//			StreamCorruptedException streamCorruptedException = new StreamCorruptedException( e.getMessage());
//			throw streamCorruptedException;	
//		}		
//	}
	
//	abstract Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass)  throws StreamCorruptedException;

}
//END OF FILE
//START OF FILE: src/serialization/logical/anarrayserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;


public class AnArraySerializer extends AnAbstractSerializer implements ValueSerializer {

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects)
			throws StreamCorruptedException, NotSerializableException {
		try {
			String componentClassName = stringFromBuffer(anInputBuffer);
			Class componentClass = Class.forName(componentClassName);
			int size = anInputBuffer.getInt();
			Object array = Array.newInstance(componentClass, size);
			retrievedObjects.add(array);
			Tracer.info(this, "Added deserialized object " + array + " at index: " + (retrievedObjects.size()-1));
			for (int i = 0; i < size; i++)  {
				Object element = ALogicalStructureSerializer.getDispatchingSerializer().objectFromBuffer(anInputBuffer, retrievedObjects);
				Array.set(array, i, element);
			}			
			return array;
		} catch (Exception e) {
			throw new StreamCorruptedException(e.getMessage());
		}
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object array, List visitedObjects) throws NotSerializableException{
		visitedObjects.add(array);
		Tracer.info(this, "Added  serialized object " + array + " at index: " + (visitedObjects.size()-1));
		Class componentClass = array.getClass().getComponentType();
		stringToBuffer(anOutputBuffer,  componentClass.getName());
		int size = Array.getLength(array);
		anOutputBuffer.putInt(size);
		for (int i = 0; i <  size; i++) {
			ALogicalStructureSerializer.getDispatchingSerializer().objectToBuffer(anOutputBuffer, Array.get(array, i), visitedObjects);
		}		
	}
	
	

	

	

}
//END OF FILE
//START OF FILE: src/serialization/logical/anenumserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;

public class AnEnumSerializer extends AnAbstractSerializer{

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException {
		try {
			Object[] anEnumConstants = aClass.getEnumConstants();			
//			String representationString = representationFromBuffer(anInputBuffer);
			Object enumString = stringFromBuffer(anInputBuffer);
			Object retVal = null;
			for (Object anEnumConstant:anEnumConstants) {
				if (anEnumConstant.toString().equals(enumString)) {
					retVal = anEnumConstant;
					break;
				}
			}
			if (retVal == null) {
				Tracer.error("Enum deserialized to null:" + enumString);
			}
			retrievedObjects.add(retVal);
			Tracer.info(this, "Added deserialized object " + retVal + " at index: " + (retrievedObjects.size()-1));
			return retVal;
		} catch (Exception e) {
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Enum Representation from Buffer Falied. Cause: " + e.getMessage());
			throw streamCorruptedException;	
		}
		
	}

	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object value, List visitedObjects) {
		visitedObjects.add(value);
		Tracer.info(this, "Added  serialized enum " + value + " at index: " + (visitedObjects.size()-1));
		Class enumClass = value.getClass();
		String string = value.toString();
		stringToBuffer(anOutputBuffer, string);		
	}

}
//END OF FILE
//START OF FILE: src/serialization/logical/anintegerserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.trace.Tracer;


public class AnIntegerSerializer extends AnAbstractSerializer {

	@Override
	public Object objectFromBuffer(ByteBuffer anInputBuffer, Class aClass, List retrievedObjects) throws StreamCorruptedException, NotSerializableException {
		try {
			Object retVal = anInputBuffer.getInt();	
			retrievedObjects.add(retVal);
			Tracer.info(this, "Added deserialized object " + retVal + " at index: " + (retrievedObjects.size()-1));
			return retVal;
		} catch (Exception e) {
			StreamCorruptedException streamCorruptedException = new StreamCorruptedException("Leaf Representation from Buffer Falied. Cause: " + e.getMessage());
			throw streamCorruptedException;	
		}
		
	}
	@Override
	void representationToBuffer(ByteBuffer anOutputBuffer, Object value, List visitedObjects) {
		visitedObjects.add(value);
		Tracer.info(this, "Added  serialized object " + value + " at index: " + (visitedObjects.size()-1));
		anOutputBuffer.putInt((Integer) value);
	}

	
	


}
//END OF FILE
//START OF FILE: src/serialization/logical/dispatchingserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.annotations.Tags;
@Tags({util.annotations.Comp533Tags.DISPATCHING_SERIALIZER})
public interface DispatchingSerializer {

	void objectToBuffer (ByteBuffer anOutputBuffer,  Object anObject, List visitedObjects) throws NotSerializableException;
	Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException;



}
//END OF FILE
//START OF FILE: src/serialization/logical/testlogicalstructureserialization.java
package serialization.logical;


import examples.serialization.SerializationTester;
import serialization.SerializerSelector;
import util.trace.Tracer;

public class TestLogicalStructureSerialization {
	public static void main (String[] args) {
		Tracer.showInfo(true);
		Tracer.setKeywordPrintStatus( Tracer.ALL_KEYWORDS, false);

		Tracer.setKeywordPrintStatus( SerializerSelector.class, true);
		SerializerSelector.setSerializerFactory(new ALogicalStructureSerializerFactory());
		SerializationTester.testSerialization();
		
	}

}
//END OF FILE
//START OF FILE: src/serialization/logical/testserializationold.java
package serialization.logical;

import inputport.rpc.ASerializableCall;
import inputport.rpc.ASerializableMethod;
import inputport.rpc.AnRPCProxyInvocationHandler;
import inputport.rpc.SerializableCall;
import inputport.rpc.SerializableMethod;
import inputport.rpc.duplex.AnRPCReturnValue;
import inputport.rpc.duplex.RPCReturnValue;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import examples.mvc.rmi.duplex.DistributedRMICounter;
import examples.serialization.AStringHistory;
import examples.serialization.AnotherBMISpreadsheet;
import examples.serialization.BMISpreadsheet;
import examples.serialization.StringHistory;
import serialization.Serializer;
import serialization.simple.ASimpleSerializer;
import util.trace.Tracer;


public class TestSerializationOld {
	public static void main(String args[]) {
		Tracer.showInfo(true);
		
		

//		Serializer support = new ACustomSerializer();
		Serializer support = new ASimpleSerializer();
		InvocationHandler invocationHandler = new AnRPCProxyInvocationHandler(null, null, DistributedRMICounter.class, null);
		DistributedRMICounter counter = (DistributedRMICounter)  
        Proxy.newProxyInstance(
           DistributedRMICounter.class.getClassLoader(), 
           new Class [] {DistributedRMICounter.class}, 
           invocationHandler );


		try {
			Method[] methods = List.class.getMethods();
			Method method = methods[0];
			SerializableMethod serializableMethod = new ASerializableMethod(
					method);
			// translate(support, serializableMethod);
			Object[] actualArgs = { "arg1", 65 };
			SerializableCall serializableCall = new ASerializableCall(
					"test object", method, actualArgs);
			translate(support, counter);
			translate(support, method);
			translate(support, serializableCall);
		} catch (Exception e) {
			e.printStackTrace();
		}
		try {
			Method[] methods = List.class.getMethods();
			SerializableMethod[] serializableMethods = new SerializableMethod[methods.length];
			for (int i = 0; i < methods.length; i++) {
				serializableMethods[i] = new ASerializableMethod(methods[i]);
			}
			translate(support, serializableMethods);
		} catch (Exception e) {
			e.printStackTrace();
		}
		Class argsClass = args.getClass();
		Class componentClass = args.getClass().getComponentType();
		String[] strings = { "Hello World", "Goodbye World" };
		List<String> list = new ArrayList();
		list.add("Hello world");
		list.add("Goodbye world");
		translate(support, list);
		Map map = new HashMap();
		map.put("greeting", "ni hao");
		map.put("farewell", "sayonara");
		BMISpreadsheet bmi = new AnotherBMISpreadsheet();
		bmi.setHeight(1.77);
		bmi.setWeight(75);
		map.put("myBMI", bmi);
		translate(support, map);
		// translate(support, list);
	
		RPCReturnValue rpcReturnValue = new AnRPCReturnValue(strings);
		translate(support, rpcReturnValue);
		List recursive = new ArrayList();
		recursive.add(null);
		recursive.add(strings);
		recursive.add(recursive);
		recursive.add(list);
		translate(support, recursive);
		StringHistory stringHistory = new AStringHistory();
		stringHistory.add("James Dean");
		stringHistory.add("Joe Doe");
		stringHistory.add("Jane Smith");
		stringHistory.add("John Smith");
		translate(support, stringHistory);
	}

	static void translate(Serializer support, Object object) {
		System.out.println("Serializing " + object);
		ByteBuffer buffer;
		try {
			buffer = support.outputBufferFromObject(object);

			Object readVal;
			try {
				readVal = support.objectFromInputBuffer(buffer);
				System.out.println("Deserialized " + readVal);

			} catch (StreamCorruptedException e) {
				e.printStackTrace();
			}
		} catch (NotSerializableException e1) {
			e1.printStackTrace();
		}
	}

}
//END OF FILE
//START OF FILE: src/serialization/logical/topserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

public interface TopSerializer {

	void objectToBuffer (ByteBuffer anOutputBuffer,  Object anObject, List visitedObjects) throws NotSerializableException;
	Object objectFromBuffer(ByteBuffer anInputBuffer, List retrievedObjects) throws StreamCorruptedException, NotSerializableException;



}
//END OF FILE
//START OF FILE: src/serialization/logical/valueserializer.java
package serialization.logical;

import java.io.NotSerializableException;
import java.io.StreamCorruptedException;
import java.nio.ByteBuffer;
import java.util.List;

import util.annotations.Tags;
@Tags({"Type-Specific Value Serializer"})
public interface ValueSerializer {
	void objectToBuffer (ByteBuffer anOutputBuffer,  Object anObject, List visitedObjects) throws NotSerializableException;
	Object objectFromBuffer(ByteBuffer anInputBuffer, 
			Class aClass, List retrievedObjects) throws StreamCorruptedException, NotSerializableException;
}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/duplex/buffer/syncrcv/abufferduplexsessionportwithsyncreceivefactory.java
package sessionport.datacomm.duplex.buffer.syncrcv;

import inputport.rpc.duplex.DuplexRPCClientInputPort;

import java.nio.ByteBuffer;

import port.ParticipantChoice;

import sessionport.datacomm.duplex.DuplexSessionPort;
import sessionport.datacomm.duplex.buffer.BufferDuplexSessionPortSelector;
import sessionport.duplex.syncrcv.ADuplexSessionPortWithSyncReceiveFactory;


public class ABufferDuplexSessionPortWithSyncReceiveFactory extends ADuplexSessionPortWithSyncReceiveFactory<ByteBuffer> {

	@Override
	public DuplexSessionPort<ByteBuffer> createDuplexSessionPort(
			String sessionsServerHost, String sessionsServerId,
			String sessionsServerName, String sessionName, String anId,
			String name, ParticipantChoice aJoinChoice) {
		return BufferDuplexSessionPortSelector.createBufferDuplexSessionPort(sessionsServerHost, sessionsServerId, sessionsServerName, sessionName, anId, name, aJoinChoice);
	}
//
//	@Override
//	public DuplexSessionPort<ByteBuffer> createDuplexSessionPort(
//			SessionsServer aSessionsServer, String aSessionName, String anId,
//			String aName) {
//		return BufferDuplexSessionPortSelector.createDuplexSessionPort(aSessionsServer, aSessionName, anId, aName);
//	}

	@Override
	public DuplexSessionPort<ByteBuffer> createDuplexSessionPort(
			DuplexRPCClientInputPort aSessionsServerClienPort,
			String aSessionName, String anId, String aName, ParticipantChoice aChoice) {
		return BufferDuplexSessionPortSelector.createDuplexSessionPort(aSessionsServerClienPort, aSessionName, anId, aName, aChoice);
	}

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/duplex/buffer/syncrcv/bufferduplexsessionportwithsyncreceiveselector.java
package sessionport.datacomm.duplex.buffer.syncrcv;

import java.nio.ByteBuffer;

import port.ParticipantChoice;

import sessionport.duplex.syncrcv.DuplexSessionPortWithSyncReceive;
import sessionport.duplex.syncrcv.DuplexSessionPortWithSyncReceiveFactory;



public class BufferDuplexSessionPortWithSyncReceiveSelector  {
	static DuplexSessionPortWithSyncReceiveFactory<ByteBuffer> factory = new ABufferDuplexSessionPortWithSyncReceiveFactory();
	public static void setBufferDuplexSessionPortWithSyncReceiveFactory(DuplexSessionPortWithSyncReceiveFactory<ByteBuffer> aFactory) {
		factory = aFactory;
	}
	
	public static DuplexSessionPortWithSyncReceive<ByteBuffer> createBufferDuplexSessionPortWithSyncReceive (
			String aSessionsServerHost, 
			String aSessionsServerId, 
			String aSessionsServerName, 
			String aSessionName, 
			String anId,
			String aName, ParticipantChoice aJoinChoice){
		return factory.createDuplexSessionPortWithSyncReceive(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, aJoinChoice);
	}	
}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/duplex/object/syncrcv/anobjectduplexsessionportwithsyncreceivefactory.java
package sessionport.datacomm.duplex.object.syncrcv;

import port.ParticipantChoice;
import inputport.rpc.duplex.DuplexRPCClientInputPort;
import sessionport.datacomm.duplex.DuplexSessionPort;
import sessionport.datacomm.duplex.object.ObjectDuplexSessionPortSelector;
import sessionport.duplex.syncrcv.ADuplexSessionPortWithSyncReceiveFactory;


public class AnObjectDuplexSessionPortWithSyncReceiveFactory extends ADuplexSessionPortWithSyncReceiveFactory<Object> {

	@Override
	public DuplexSessionPort<Object> createDuplexSessionPort(
			String sessionsServerHost, String sessionsServerId,
			String sessionsServerName, String sessionName, String anId,
			String name, ParticipantChoice aJoinChoice) {
		return ObjectDuplexSessionPortSelector.createObjectDuplexSessionPort(sessionsServerHost, sessionsServerId, sessionsServerName, sessionName, anId, name, aJoinChoice);
	}

	@Override
	public DuplexSessionPort<Object> createDuplexSessionPort(
			DuplexRPCClientInputPort aSessionsManagerClienPort,
			String aSessionName, String anId, String aName, ParticipantChoice aJoinChoice) {
		return ObjectDuplexSessionPortSelector.createDuplexSessionPort(aSessionsManagerClienPort, aSessionName, anId, aName, aJoinChoice);
	}

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/duplex/object/syncrcv/objectduplexsessionportwithsyncreceiveselector.java
package sessionport.datacomm.duplex.object.syncrcv;

import port.ParticipantChoice;
import sessionport.duplex.syncrcv.DuplexSessionPortWithSyncReceive;
import sessionport.duplex.syncrcv.DuplexSessionPortWithSyncReceiveFactory;


public class ObjectDuplexSessionPortWithSyncReceiveSelector  {
	static DuplexSessionPortWithSyncReceiveFactory<Object> factory = new AnObjectDuplexSessionPortWithSyncReceiveFactory();
	public static void setObjectDuplexSessionPortWithSyncReceiveFactory(DuplexSessionPortWithSyncReceiveFactory<Object> aFactory) {
		factory = aFactory;
	}
	
	public static DuplexSessionPortWithSyncReceive<Object> 
	     createObjectDuplexSessionPortWithSyncReceive (
			String aSessionsServerHost, 
			String aSessionsServerId, 
			String aSessionsServerName, 
			String aSessionName, 
			String anId,
			String aName, ParticipantChoice aJoinChoice){
		return factory.createDuplexSessionPortWithSyncReceive(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, aJoinChoice);
	}	
}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/buffer/syncrcv/abuffergroupsessionportwithsyncreceivefactory.java
package sessionport.datacomm.group.buffer.syncrcv;


import java.nio.ByteBuffer;

import port.ParticipantChoice;

import sessionport.datacomm.group.GroupSessionPort;
import sessionport.datacomm.group.buffer.BufferGroupSessionPortSelector;
import sessionport.datacomm.group.syncrcv.AGroupSessionPortWithSyncReceiveFactory;

public class ABufferGroupSessionPortWithSyncReceiveFactory extends AGroupSessionPortWithSyncReceiveFactory<ByteBuffer>  {

	@Override
	protected GroupSessionPort<ByteBuffer> createGroupSessionPort(
			String aSessionsServerHost, String aSessionsServerId,
			String aSessionsServerName, String aSessionName, String anId,
			String aName, ParticipantChoice aChoice) {
		return BufferGroupSessionPortSelector.createBufferGroupSessionPort(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, aChoice);
	}

	

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/buffer/syncrcv/buffergroupsessionportwithsyncreceiveselector.java
package sessionport.datacomm.group.buffer.syncrcv;



import java.nio.ByteBuffer;

import port.ParticipantChoice;

import sessionport.datacomm.group.syncrcv.GroupSessionPortWithSyncReceive;
import sessionport.datacomm.group.syncrcv.GroupSessionPortWithSyncReceiveFactory;


public class BufferGroupSessionPortWithSyncReceiveSelector  {
	static GroupSessionPortWithSyncReceiveFactory<ByteBuffer> factory = new ABufferGroupSessionPortWithSyncReceiveFactory();
	public static GroupSessionPortWithSyncReceiveFactory<ByteBuffer> 
		sessionPortFactory = new ABufferGroupSessionPortWithSyncReceiveFactory();
	public static void setBufferGroupSessionPortWithSyncReceiveFactory(GroupSessionPortWithSyncReceiveFactory<ByteBuffer> theSessionPortFactory) {
		sessionPortFactory = theSessionPortFactory;
	}
	public static GroupSessionPortWithSyncReceive<ByteBuffer> createBufferGroupSessionPortWithSyncReceive(
			String aSessionsServerHost, 
			String aSessionsServerId, 
			String aSessionsServerName, 
			String aSessionName, 
			String anId,
			String aName) {
		return factory.createGroupSessionPortWithSyncReceive(aSessionsServerHost, aSessionsServerId, aSessionsServerName, aSessionName, anId, aName, ParticipantChoice.MEMBER);
	}
}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/object/syncrcv/anobjectgroupinputportwithsyncreceivefactory.java
package sessionport.datacomm.group.object.syncrcv;

import inputport.datacomm.duplex.DuplexClientInputPort;
import inputport.datacomm.duplex.object.DuplexObjectInputPortSelector;
import inputport.datacomm.group.GroupServerInputPort;
import inputport.datacomm.group.object.GroupObjectInputPortSelector;
import inputport.datacomm.group.syncrcv.AGroupInputPortWithSyncReceiveFactory;
import inputport.datacomm.group.syncrcv.GroupInputPortWithSyncReceiveFactory;

public class AnObjectGroupInputPortWithSyncReceiveFactory 
	extends AGroupInputPortWithSyncReceiveFactory<Object> 
	implements GroupInputPortWithSyncReceiveFactory<Object>{

	@Override
	protected DuplexClientInputPort<Object> createDuplexClientInputPort(
			String theHost, String theServerId, String aServerName,
			String theClientName) {
		return DuplexObjectInputPortSelector.createDuplexClientInputPort(theHost, theServerId, aServerName, theClientName);
	}

	@Override
	protected GroupServerInputPort<Object> createGroupServerInputPort(
			String theServerId, String theServerName) {
		return GroupObjectInputPortSelector.createGroupServerInputPort(theServerId, theServerName);
	}

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/object/syncrcv/objectgroupinputportwithsyncreceiveselector.java
package sessionport.datacomm.group.object.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexClientInputPortWithSyncReceive;
import inputport.datacomm.group.syncrcv.GroupInputPortWithSyncReceiveFactory;
import inputport.datacomm.group.syncrcv.GroupServerInputPortWithSyncReceive;

public class ObjectGroupInputPortWithSyncReceiveSelector {
	static GroupInputPortWithSyncReceiveFactory<Object> factory = new AnObjectGroupInputPortWithSyncReceiveFactory();
	public static void setGroupInputPortWithSyncReceiveFactor(GroupInputPortWithSyncReceiveFactory<Object> aFactory) {
		factory = aFactory;
	}
	public static GroupServerInputPortWithSyncReceive<Object> createGroupServerInputPortWithSyncReceive(String theServerId, String theServerName) {
		return factory.createGroupServerInputPortWithSyncReceive(theServerId, theServerName);
	}
	public static DuplexClientInputPortWithSyncReceive<Object> createDuplexClientInputPortWithSyncReceive(String theHost, String theServerId, String aServerName, String theClientName) {
		 return factory.createDuplexClientInputPortWithSyncReceive(theHost, theServerId, aServerName, theClientName);
		 
	 }


}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/syncrcv/agroupsessionportwithsyncreceive.java
package sessionport.datacomm.group.syncrcv;

import inputport.ConnectionListener;
import inputport.ConnectionType;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.ReceiveTrapper;
import inputport.datacomm.SendTrapper;
import inputport.datacomm.duplex.object.explicitreceive.ASyncReceiveListener;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;
import inputport.datacomm.group.GroupSendTrapper;
import inputport.datacomm.group.GroupToUniSendTrapper;
import inputport.datacomm.simplex.buffer.ByteBufferSendListener;

import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import port.ParticipantChoice;
import port.sessionserver.SessionParticipantDescription;
import sessionport.datacomm.group.GroupSessionPort;


public class AGroupSessionPortWithSyncReceive<MessageType>  implements GroupSessionPortWithSyncReceive<MessageType>{
	GroupSessionPort<MessageType> groupSessionPort;
	Map<String, ExplicitReceiveListener<MessageType>> nameToSyncReceiveListener = new HashMap();

	public AGroupSessionPortWithSyncReceive (GroupSessionPort<MessageType> aGroupSessionPort) {
		groupSessionPort = aGroupSessionPort;
	}
	protected ExplicitReceiveListener<MessageType>  createSyncReceiveListener(String aClientName) {
		return new ASyncReceiveListener(aClientName);
	}
	protected ExplicitReceiveListener<MessageType> getAndMaybeCreateSyncReceiveListener(String clientName) {
		ExplicitReceiveListener<MessageType> syncReceiveListener = nameToSyncReceiveListener.get(clientName);
		if (syncReceiveListener == null) {
			syncReceiveListener = createSyncReceiveListener(clientName);
			nameToSyncReceiveListener.put(clientName, syncReceiveListener);
			groupSessionPort.addReceiveListener(syncReceiveListener);	
		}
		return syncReceiveListener;
	}

	@Override
	public ReceiveReturnMessage<MessageType> receive() {
		return receive(getSender());		
	}	
	@Override
	public ReceiveReturnMessage<MessageType> receive(String aSource) {
		return getAndMaybeCreateSyncReceiveListener(aSource).getReceivedMessage();		
	}
	public void addConnectionListener(ConnectionListener portConnectListener) {
		groupSessionPort.addConnectionListener(portConnectListener);
	}
	public void addReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		groupSessionPort.addReceiveListener(portReceiveListener);
	}
	public void addSendListener(ByteBufferSendListener portSendListener) {
		groupSessionPort.addSendListener(portSendListener);
	}
	public void connect() {
		groupSessionPort.connect();
	}
	public void disconnect() {
		groupSessionPort.disconnect();
	}
	public String getSender() {
		return groupSessionPort.getSender();
	}
	public String getLocalName() {
		return groupSessionPort.getLocalName();
	}
	public Set<String> getConnections() {
		return groupSessionPort.getConnections();
	}
	public void notifyConnect(String remoteEnd, ConnectionType aConnectionType) {
		groupSessionPort.notifyConnect(remoteEnd, aConnectionType);
	}
	public void notifyConnectFailure(String remoteEnd, String message, ConnectionType aConnectionType) {
		groupSessionPort.notifyConnectFailure(remoteEnd, message, aConnectionType);
	}
	public void notifyDisconnect(String remoteEnd, boolean eof,
			String closeReason, ConnectionType aConnectionType) {
		groupSessionPort.notifyDisconnect(remoteEnd, eof, closeReason, null);
	}
	public void notifyPortReceive(String remoteEnd, MessageType message) {
		groupSessionPort.notifyPortReceive(remoteEnd, message);
	}
	public void notifyPortSend(String aRemoteEnd, ByteBuffer message, int sendId) {
		groupSessionPort.notifyPortSend(aRemoteEnd, message, sendId);
	}
	public void removeConnectionListener(ConnectionListener portConnectListener) {
		groupSessionPort.removeConnectionListener(portConnectListener);
	}
	public void removeReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		groupSessionPort.removeReceiveListener(portReceiveListener);
	}
	public void removeSendListener(ByteBufferSendListener portSendListener) {
		groupSessionPort.removeSendListener(portSendListener);
	}
	public void reply(MessageType message) {
		groupSessionPort.reply(message);
	}
	@Override
	public void reply(String aRemoteEnd, MessageType aMessage) {
		send(aRemoteEnd, aMessage);
	}
	public void send(MessageType message) {
		groupSessionPort.send(message);
	}
	public void send(Collection<String> clientNames, MessageType message) {
		groupSessionPort.send(clientNames, message);
	}
	public void send(String remoteName, MessageType message) {
		groupSessionPort.send(remoteName, message);
	}
	public void sendAll(MessageType message) {
		groupSessionPort.sendAll(message);
	}
	public void sendOthers(MessageType message) {
		groupSessionPort.sendOthers(message);
	}
	public void setSender(String newVal) {
		groupSessionPort.setSender(newVal);
	}
	@Override
	public String getServerId() {
		return groupSessionPort.getServerId();
	}
	@Override
	public GroupSendTrapper<MessageType, MessageType> getGroupSendTrapper() {
		return groupSessionPort.getGroupSendTrapper();
	}
	@Override
	public GroupToUniSendTrapper<MessageType, MessageType> getGroupToUniSendTrapper() {
		return groupSessionPort.getGroupToUniSendTrapper();
	}
	@Override
	public void setGroupSendTrapper(
			GroupSendTrapper<MessageType, MessageType> groupSendTrapper) {
		groupSessionPort.setGroupSendTrapper(groupSendTrapper);
	}
	@Override
	public void setGroupToUniSendTrapper(
			GroupToUniSendTrapper<MessageType, MessageType> groupToUniSendTrapper) {
		groupSessionPort.setGroupToUniSendTrapper(groupToUniSendTrapper);		
	}
	@Override
	public ReceiveTrapper<MessageType, MessageType> getReceiveTrapper() {
		return groupSessionPort.getReceiveTrapper();
	}
	@Override
	public void setReceiveTrapper(
			ReceiveTrapper<MessageType, MessageType> newVal) {
		groupSessionPort.setReceiveTrapper(newVal);
		
	}
	@Override
	public SendTrapper<MessageType, MessageType> getSendTrapper() {
		return groupSessionPort.getSendTrapper();
	}
	@Override
	public void setSendTrapper(SendTrapper<MessageType, MessageType> newVal) {
		groupSessionPort.setSendTrapper(newVal);
	}
	@Override
	public boolean isConnected(String remoteName) {
		// TODO Auto-generated method stub
		return groupSessionPort.isConnected(remoteName);
	}
	@Override
	public List<ReceiveListener<MessageType>> getReceiveListeners() {
		// TODO Auto-generated method stub
		return groupSessionPort.getReceiveListeners();
	}
	
	String physicalRemoteEndPoint;
	String logicalRemoteEndPoint;
	@Override
	public String getLogicalRemoteEndPoint() {
		return logicalRemoteEndPoint;
	}

	@Override
	public String getPhysicalRemoteEndPoint() {
		return physicalRemoteEndPoint;
	}

	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		physicalRemoteEndPoint = newVal;
	}

	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		logicalRemoteEndPoint = newVal;
	}
	@Override
	public Set<String> getClientConnections() {
		return groupSessionPort.getClientConnections();
	}
	@Override
	public Set<String> getServerConnections() {
		// TODO Auto-generated method stub
		return  groupSessionPort.getServerConnections();
	}
	@Override
	public Set<String> getMemberConnections() {
		return groupSessionPort.getMemberConnections();
	}
	@Override
	public List<SessionParticipantDescription> getServers() {
		return groupSessionPort.getServers();
	}
	@Override
	public List<SessionParticipantDescription> getMembers() {
		return groupSessionPort.getServers();
	}
	@Override
	public List<SessionParticipantDescription> getClients() {
		return groupSessionPort.getClients();
	}
	@Override
	public SessionParticipantDescription getServer(String aName) {
		return groupSessionPort.getServer(aName);
	}
	@Override
	public SessionParticipantDescription getClient(String aName) {
		return groupSessionPort.getClient(aName);
	}
	@Override
	public SessionParticipantDescription getMember(String aName) {
		return groupSessionPort.getMember(aName);
	}
	@Override
	public void sendOtherClients(MessageType message) {
		groupSessionPort.sendOtherClients(message);
	}
	@Override
	public void sendOtherServers(MessageType message) {
		groupSessionPort.sendOtherServers(message);
		
	}
	@Override
	public void sendOtherMembers(MessageType message) {
		groupSessionPort.sendOtherMembers(message);
	}
	@Override
	public void sendAllClients(MessageType message) {
		groupSessionPort.sendAllClients(message);
	}
	@Override
	public void sendAllServers(MessageType message) {
		groupSessionPort.sendAllServers(message);
	}
	@Override
	public void sendAllMembers(MessageType message) {
		groupSessionPort.sendAllMembers(message);
	}
	@Override
	public ParticipantChoice getParticipantChoice() {
		// TODO Auto-generated method stub
		return groupSessionPort.getParticipantChoice();
	}
	@Override
	public void sendAllRemoteMembers(MessageType message) {
		groupSessionPort.sendAllRemoteMembers(message);
		
	}

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/syncrcv/agroupsessionportwithsyncreceivefactory.java
package sessionport.datacomm.group.syncrcv;
import port.ParticipantChoice;
import sessionport.datacomm.group.GroupSessionPort;

public abstract class AGroupSessionPortWithSyncReceiveFactory<MessageType> implements GroupSessionPortWithSyncReceiveFactory<MessageType> {

	@Override
	public GroupSessionPortWithSyncReceive<MessageType> createGroupSessionPortWithSyncReceive(
			String sessionsServerHost, String sessionsServerId,
			String sessionsServerName, String sessionName, String anId,
			String name, ParticipantChoice aChoice) {
		GroupSessionPort<MessageType> groupSessionPort = createGroupSessionPort(sessionsServerHost, sessionsServerId, sessionsServerName, sessionName, anId, name, aChoice);
		return new AGroupSessionPortWithSyncReceive<MessageType>(groupSessionPort);
	}	
	abstract protected GroupSessionPort<MessageType> createGroupSessionPort(
			String sessionsServerHost, String sessionsServerId,
			String sessionsServerName, String sessionName, String anId,
			String name, ParticipantChoice aChoice);

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/syncrcv/groupsessionportwithsyncreceive.java
package sessionport.datacomm.group.syncrcv;

import sessionport.datacomm.group.GroupSessionPort;
import sessionport.duplex.syncrcv.DuplexSessionPortWithSyncReceive;

public interface GroupSessionPortWithSyncReceive<MessageType> extends  GroupSessionPort<MessageType>, 
DuplexSessionPortWithSyncReceive<MessageType> { 

}
//END OF FILE
//START OF FILE: src/sessionport/datacomm/group/syncrcv/groupsessionportwithsyncreceivefactory.java
package sessionport.datacomm.group.syncrcv;

import port.ParticipantChoice;

public interface GroupSessionPortWithSyncReceiveFactory<MessageType> {
	GroupSessionPortWithSyncReceive<MessageType> createGroupSessionPortWithSyncReceive(
			String aSessionsServerHost, 
			String aSessionsServerId, 
			String aSessionsServerName, 
			String aSessionName, 
			String anId,
			String aName, ParticipantChoice aChoice);

}
//END OF FILE
//START OF FILE: src/sessionport/duplex/syncrcv/aduplexsessionportwithsyncreceive.java
package sessionport.duplex.syncrcv;

import inputport.ConnectionListener;
import inputport.ConnectionType;
import inputport.datacomm.ReceiveListener;
import inputport.datacomm.ReceiveTrapper;
import inputport.datacomm.SendTrapper;
import inputport.datacomm.duplex.object.explicitreceive.ASyncReceiveListener;
import inputport.datacomm.duplex.object.explicitreceive.ReceiveReturnMessage;
import inputport.datacomm.duplex.object.explicitreceive.ExplicitReceiveListener;
import inputport.datacomm.simplex.buffer.ByteBufferSendListener;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import sessionport.datacomm.duplex.DuplexSessionPort;

public class ADuplexSessionPortWithSyncReceive<MessageType> implements  DuplexSessionPortWithSyncReceive<MessageType> {
	DuplexSessionPort<MessageType> duplexSessionPort;
	Map<String, ExplicitReceiveListener<MessageType>> nameToSyncReceiveListener = new HashMap();
	public ADuplexSessionPortWithSyncReceive(DuplexSessionPort<MessageType> aDuplexSessionPort) {
		duplexSessionPort = aDuplexSessionPort;	
	}
	protected ExplicitReceiveListener<MessageType>  createSyncReceiveListener(String clientName) {
		return new ASyncReceiveListener(clientName);
	}
	protected ExplicitReceiveListener<MessageType> getAndMaybeCreateSyncReceiveListener(String clientName) {
		ExplicitReceiveListener<MessageType> syncReceiveListener = nameToSyncReceiveListener.get(clientName);
		if (syncReceiveListener == null) {
			syncReceiveListener = createSyncReceiveListener(clientName);
			nameToSyncReceiveListener.put(clientName, syncReceiveListener);
			duplexSessionPort.addReceiveListener(syncReceiveListener);	
		}
		return syncReceiveListener;
	}

	@Override
	public ReceiveReturnMessage<MessageType> receive() {
		return receive(getSender());		
	}	
	@Override
	public ReceiveReturnMessage<MessageType> receive(String aSource) {
		return getAndMaybeCreateSyncReceiveListener(aSource).getReceivedMessage();		
	}
	public void addConnectionListener(ConnectionListener portConnectListener) {
		duplexSessionPort.addConnectionListener(portConnectListener);
	}
	public void addReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexSessionPort.addReceiveListener(portReceiveListener);
	}
	public void addSendListener(ByteBufferSendListener portSendListener) {
		duplexSessionPort.addSendListener(portSendListener);
	}
	public void connect() {
		duplexSessionPort.connect();
	}
	public void disconnect() {
		duplexSessionPort.disconnect();
	}
	public String getSender() {
		return duplexSessionPort.getSender();
	}
	public String getLocalName() {
		return duplexSessionPort.getLocalName();
	}
	public Set<String> getConnections() {
		return duplexSessionPort.getConnections();
	}
	public void notifyConnect(String remoteEnd, ConnectionType aConnectionType) {
		duplexSessionPort.notifyConnect(remoteEnd, aConnectionType);
	}
	public void notifyConnectFailure(String remoteEnd, String message, ConnectionType aConnectionType) {
		duplexSessionPort.notifyConnectFailure(remoteEnd, message, null);
	}
	public void notifyDisconnect(String remoteEnd, boolean eof,
			String closeReason, ConnectionType aConnectionType) {
		duplexSessionPort.notifyDisconnect(remoteEnd, eof, closeReason, null);
	}
	public void notifyPortReceive(String remoteEnd, MessageType message) {
		duplexSessionPort.notifyPortReceive(remoteEnd, message);
	}
	public void notifyPortSend(String aRemoteEnd, ByteBuffer message, int sendId) {
		duplexSessionPort.notifyPortSend(aRemoteEnd, message, sendId);
	}
	public void removeConnectionListener(ConnectionListener portConnectListener) {
		duplexSessionPort.removeConnectionListener(portConnectListener);
	}
	public void removeReceiveListener(
			ReceiveListener<MessageType> portReceiveListener) {
		duplexSessionPort.removeReceiveListener(portReceiveListener);
	}
	public void removeSendListener(ByteBufferSendListener portSendListener) {
		duplexSessionPort.removeSendListener(portSendListener);
	}
	public void reply(MessageType message) {
		duplexSessionPort.reply(message);
	}
	@Override
	public void reply(String aRemoteEnd, MessageType aMessage) {
		send(aRemoteEnd, aMessage);
	}
	public void send(MessageType message) {
		duplexSessionPort.send(message);
	}
	public void send(String remoteName, MessageType message) {
		duplexSessionPort.send(remoteName, message);
	}
	public void setSender(String newVal) {
		duplexSessionPort.setSender(newVal);
	}
	@Override
	public String getServerId() {
		return duplexSessionPort.getServerId();
	}
	@Override
	public ReceiveTrapper<MessageType, MessageType> getReceiveTrapper() {
		return duplexSessionPort.getReceiveTrapper();
	}
	@Override
	public void setReceiveTrapper(
			ReceiveTrapper<MessageType, MessageType> newVal) {
		duplexSessionPort.setReceiveTrapper(newVal);
	}
	@Override
	public SendTrapper<MessageType, MessageType> getSendTrapper() {
		return duplexSessionPort.getSendTrapper();
	}
	@Override
	public void setSendTrapper(SendTrapper<MessageType, MessageType> newVal) {
		duplexSessionPort.setSendTrapper(newVal);
	}
	@Override
	public boolean isConnected(String remoteName) {
		// TODO Auto-generated method stub
		return duplexSessionPort.isConnected(remoteName);
	}
	@Override
	public List<ReceiveListener<MessageType>> getReceiveListeners() {
		return duplexSessionPort.getReceiveListeners();
	}
	public String getLogicalRemoteEndPoint() {
		return duplexSessionPort.getLogicalRemoteEndPoint();
	}
	@Override
	public String getPhysicalRemoteEndPoint() {
		return duplexSessionPort.getPhysicalRemoteEndPoint();
	}
	@Override
	public void setLogicalRemoteEndPoint(String newVal) {
		duplexSessionPort.setLogicalRemoteEndPoint(newVal);
	}
	@Override
	public void setPhysicalRemoteEndPoint(String newVal) {
		duplexSessionPort.setPhysicalRemoteEndPoint(newVal);
	}

}
//END OF FILE
//START OF FILE: src/sessionport/duplex/syncrcv/aduplexsessionportwithsyncreceivefactory.java
package sessionport.duplex.syncrcv;

import port.ParticipantChoice;
import sessionport.datacomm.duplex.DuplexSessionPort;
import sessionport.datacomm.duplex.DuplexSessionPortFactory;

public abstract class ADuplexSessionPortWithSyncReceiveFactory<MessageType> implements 
	DuplexSessionPortWithSyncReceiveFactory<MessageType>, DuplexSessionPortFactory<MessageType>{

	@Override
	public DuplexSessionPortWithSyncReceive<MessageType> createDuplexSessionPortWithSyncReceive(
			String sessionsServerHost, String sessionsServerId,
			String sessionsServerName, String sessionName, String anId,
			String name, ParticipantChoice aJoinChoice) {
		DuplexSessionPort<MessageType>  duplexSessionPort = createDuplexSessionPort(sessionsServerHost, sessionsServerId, sessionsServerName, sessionName, anId, name, aJoinChoice);
		return new ADuplexSessionPortWithSyncReceive<MessageType>(duplexSessionPort);		
	}

}
//END OF FILE
//START OF FILE: src/sessionport/duplex/syncrcv/duplexsessionportwithsyncreceive.java
package sessionport.duplex.syncrcv;

import inputport.datacomm.duplex.object.explicitreceive.DuplexServerInputPortWithSyncReceive;

public interface DuplexSessionPortWithSyncReceive<MessageType> extends DuplexServerInputPortWithSyncReceive<MessageType>{

}
//END OF FILE
//START OF FILE: src/sessionport/duplex/syncrcv/duplexsessionportwithsyncreceivefactory.java
package sessionport.duplex.syncrcv;

import port.ParticipantChoice;

public interface DuplexSessionPortWithSyncReceiveFactory<MessageType> {
	DuplexSessionPortWithSyncReceive<MessageType> createDuplexSessionPortWithSyncReceive(
										String aSessionsServerHost, 
										String aSessionsServerId, 
										String aSessionsServerName, 
										String aSessionName, 
										String anId,
										String aName, ParticipantChoice aJoinChoice);	
}
//END OF FILE
//START OF FILE: src/singleuser/singleuserlauncher.java
package singleuser;

import main.BeauAndersonFinalProject;
import util.trace.Tracer;

public class SingleUserLauncher {
	public static void main(String[] args) {
		Tracer.showWarnings(false);
		BeauAndersonFinalProject.main(args);
	}

}
//END OF FILE
//START OF FILE: src/singleuser/package-info.java
/**
 * 
 */
/**
 * @author Dewan
 *
 */
package singleuser;
//END OF FILE
//START OF FILE: src/sync/client/asyncsimulationclientlauncher.java
package sync.client;



import bus.uigen.ObjectEditor;
import edu.unc.sync.Sync;
import edu.unc.sync.server.ServerProxy;
import edu.unc.sync.server.SyncClient;
import graphics.HalloweenSimulation;
import main.BeauAndersonFinalProject;
import stringProcessors.AHalloweenCommandProcessor;
import stringProcessors.HalloweenCommandProcessor;
import sync.models.AReplicatableHalloweenCommandProcessor;
import sync.server.StartSimationSyncServer;



public class ASyncSimulationClientLauncher {
//	static String SERVER_NAME = "localhost/A";
	static String SERVER_NAME = "localhost/" + StartSimationSyncServer.SERVER_NAME;

	static String MODEL_NAME = "simulation";
//	static String CLIENT_ID = "alice";
//	static Class EDITOR_CLASS = SyncObjectEditor.class;
	//static Class MODEL_CLASS = ConcertExpenseWithAttendanceTable.class;
	static Class MODEL_CLASS = AReplicatableHalloweenCommandProcessor.class;
	public static ServerProxy server;
	public static SyncClient client;
	public static HalloweenCommandProcessor  launchClient(String aMyName, boolean aBroadcastData, String aPrefix, int anXOffset, int aYOffset, int aWidth, int aHeight, int aCommandWindowXOffset, int aCommandWindowYOffset) {
		   try {
			   HalloweenSimulation aSimulation = BeauAndersonFinalProject.createAndDisplaySimulationWithoutCommandProcessor(anXOffset, aYOffset, aWidth, aHeight, aPrefix);
			  return  launchClient(aMyName, aBroadcastData, aSimulation, aPrefix, aCommandWindowXOffset, aCommandWindowYOffset);
			   
   //		HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//				aPrefix, anXOffset, aYOffset, aWidth, aHeight, aCommandWindowXOffset, aCommandWindowYOffset);
	 
////	    	String currentDir = System.getProperty("user.dir");
////	        System.out.println("Current dir using System:" +currentDir);
//	    	
//	      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//	      Thread t = new Thread(client);
//	      t.setDaemon(true);
//	      t.start();
////	      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
////	    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	      client.createUI(aCommandProcessor);
////	      client.initiateConnection();
////	      RspHandler handler = new RspHandler();
////	      client.send("Hello World".getBytes(), handler);
////	      handler.waitForResponse();
	    } catch (Exception e) {
	    	
	      e.printStackTrace();
	      return null;
	    }
	  
	  }
	public static HalloweenCommandProcessor  launchClient(String aMyName, boolean aBroadcast, HalloweenSimulation aSimulation, String aPrefix, int aCommandWindowXOffset, int aCommandWindowYOffset ) {
		HalloweenCommandProcessor aCommandProcessor;
			if (!aBroadcast) {
				aCommandProcessor = new AHalloweenCommandProcessor();
			} else {
				Sync.setReplicate(MODEL_CLASS, "InputString", false);

				 client = Sync.replicate (SERVER_NAME, 
						MODEL_NAME, 
						MODEL_CLASS,
						aMyName);
				
				 server = client.getServerProxy(SERVER_NAME);
				
				//ConcertExpenseWithAttendanceTable model = (ConcertExpenseWithAttendanceTable) server.getModel(MODEL_NAME);
				aCommandProcessor = (HalloweenCommandProcessor) server.getModel(MODEL_NAME);
				ObjectEditor.edit(server);
			}
			BeauAndersonFinalProject.bindAndDisplayCommandProcessor(aSimulation, aCommandProcessor, aPrefix, aCommandWindowXOffset, aCommandWindowYOffset);
		   
			return aCommandProcessor;
	  }
	
}
//END OF FILE
//START OF FILE: src/sync/launcher/alicesimulationsyncclient.java
package sync.launcher;

import java.util.Scanner;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.AliceUI;
import stringProcessors.HalloweenCommandProcessor;
import sync.client.ASyncSimulationClientLauncher;
import util.misc.AClearanceManager;
import util.misc.ClearanceManager;
import util.trace.Tracer;



public class AliceSimulationSyncClient implements AliceUI {

	public static final String SIMULATION2_PREFIX = "2:";
	public static final boolean BROADCAST = true;


	public static void main(String[] args) {
	Tracer.showWarnings(false);
//	boolean aBroadCastData = false;
	HalloweenCommandProcessor aCommandProcessor = ASyncSimulationClientLauncher.launchClient(NAME, BROADCAST, SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET,  SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);

	
	ClearanceManager clearanceManager = new AClearanceManager();
	OEFrame oeFrame = ObjectEditor.edit(clearanceManager);
	oeFrame.setLocation(700, 500);
	System.out.println("waiting for cleanance");
//	clearanceManager.waitForClearance();
	Scanner scanner = new Scanner(System.in);
	scanner.nextLine();
	long startTime = System.currentTimeMillis();
	System.out.println("Start time:" + startTime);
//	System.out.println("start time" + System.currentTimeMillis());
//	aCommandProcessor.processCommand("move 50 -50");
//	System.out.println("end time after one command" + System.currentTimeMillis());
	ASyncSimulationClientLauncher.server.setRealTimeSynchronize(false);
	for (int i=0; i < 250; i++) {
//		aCommandProcessor.processCommand("move 1 -1");
		aCommandProcessor.setInputString("move 1 0");
		aCommandProcessor.setInputString("move 0 -1");



	}
	ASyncSimulationClientLauncher.server.synchronize();

//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 0 -1");
//
//
//	}
	long endTime = System.currentTimeMillis();

	System.out.println("Loop execution time:" + (endTime - startTime));


	

//	TrickOrTreatNioClient.launchClient( SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	commandProcessor = BeauAndersonFinalProject.createSimulation(
////			"SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	
//    try {
////    	String currentDir = System.getProperty("user.dir");
////        System.out.println("Current dir using System:" +currentDir);
//    	
//      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//      Thread t = new Thread(client);
//      t.setDaemon(true);
//      t.start();
//      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//      client.createUI(aCommandProcessor);
////      client.initiateConnection();
////      RspHandler handler = new RspHandler();
////      client.send("Hello World".getBytes(), handler);
////      handler.waitForResponse();
//    } catch (Exception e) {
//      e.printStackTrace();
//    }
//  
  }
}

//END OF FILE
//START OF FILE: src/sync/launcher/bobsimulationsyncclient.java
package sync.launcher;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import common.ui.BobUI;
import stringProcessors.HalloweenCommandProcessor;
import sync.client.ASyncSimulationClientLauncher;
import util.misc.AClearanceManager;
import util.misc.ClearanceManager;
import util.trace.Tracer;



public class BobSimulationSyncClient implements BobUI {

	public static final String SIMULATION2_PREFIX = "2:";
	public static final boolean BROADCAST = true;


	public static void main(String[] args) {
	Tracer.showWarnings(false);
//	boolean aBroadCastData = false;
	HalloweenCommandProcessor aCommandProcessor = ASyncSimulationClientLauncher.launchClient(NAME, BROADCAST, SIMULATION2_PREFIX, SIMULATION_COMMAND_X_OFFSET,  SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, SIMULATION_COMMAND_X_OFFSET, 0);
	aCommandProcessor.setAnimateCars(false);

	
	ClearanceManager clearanceManager = new AClearanceManager();
	OEFrame oeFrame = ObjectEditor.edit(clearanceManager);
	oeFrame.setLocation(700, 500);

//	clearanceManager.waitForClearance();
//	long startTime = System.currentTimeMillis();
////	System.out.println("start time" + System.currentTimeMillis());
////	aCommandProcessor.processCommand("move 50 -50");
////	System.out.println("end time after one command" + System.currentTimeMillis());
//	for (int i=0; i < 250; i++) {
////		aCommandProcessor.processCommand("move 1 -1");
//		aCommandProcessor.setInputString("move 1 0");
//		aCommandProcessor.setInputString("move 0 -1");
//
//
//
//	}
////	for (int i=0; i < 250; i++) {
//////		aCommandProcessor.processCommand("move 1 -1");
////		aCommandProcessor.setInputString("move 0 -1");
////
////
////	}
//	long endTime = System.currentTimeMillis();
//
//	System.out.println("Loop execution time:" + (endTime - startTime));


	

//	TrickOrTreatNioClient.launchClient( SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	commandProcessor = BeauAndersonFinalProject.createSimulation(
////			"SIMULATION1_PREFIX", 0, SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//	
//    try {
////    	String currentDir = System.getProperty("user.dir");
////        System.out.println("Current dir using System:" +currentDir);
//    	
//      TrickOrTreatNioClient client = new TrickOrTreatNioClient(InetAddress.getByName("localhost"), 9090);
//      Thread t = new Thread(client);
//      t.setDaemon(true);
//      t.start();
//      HalloweenCommandProcessor aCommandProcessor = BeauAndersonFinalProject.createSimulation(
//    		  SIMULATION2_PREFIX, 0, TrickOrTreatNioClient.SIMULATION_COMMAND_Y_OFFSET, SIMULATION_WIDTH, SIMULATION_HEIGHT, 0, 0);
//      client.createUI(aCommandProcessor);
////      client.initiateConnection();
////      RspHandler handler = new RspHandler();
////      client.send("Hello World".getBytes(), handler);
////      handler.waitForResponse();
//    } catch (Exception e) {
//      e.printStackTrace();
//    }
//  
  }
}

//END OF FILE
//START OF FILE: src/sync/models/areplicatablehalloweencommandprocessor.java
package sync.models;

import graphics.HalloweenSimulation;
import stringProcessors.AHalloweenCommandProcessor;
import util.annotations.Visible;
import util.models.AListenableVector;
import util.models.ListenableVector;
import util.models.VectorChangeEvent;
import util.models.VectorListener;

public class AReplicatableHalloweenCommandProcessor extends AHalloweenCommandProcessor implements VectorListener {
	ListenableVector<String> history = new AListenableVector();
	
	public AReplicatableHalloweenCommandProcessor() {
		history.addVectorListener(this);
	}
	@Override
	public void init (HalloweenSimulation aSimulation) {
		super.init(aSimulation);
		for (String string:history){
			super.setInputString(string);
		}
	}
	
	@Override
	public void setInputString(String newVal) {
//		super.setInputString(newVal);
//		System.out.println("set input string:" + newVal);
		history.add(newVal);
	}
	@Visible(false)
	public ListenableVector<String> getHistory() {
		return history;
	}
	
	public void setHistory(ListenableVector<String> newVal) {
		 history = newVal;
	}

	@Override
	public void updateVector(VectorChangeEvent evt) {
		String newVal = (String) evt.getNewValue();
		super.setInputString(newVal);
	}
	
	@Override
	public void initSerializedObject() {
		super.initSerializedObject();
		history.addVectorListener(this);

	}
 
 

}
//END OF FILE
//START OF FILE: src/sync/server/startsimationsyncserver.java
package sync.server;
import bus.uigen.widgets.VirtualToolkit;
import bus.uigen.widgets.swing.SwingToolkit;
import edu.unc.sync.server.SyncServer;
public class StartSimationSyncServer {
	public static final String SERVER_NAME = "A";
	public static void main(String[] args) {
		//String[] myArgs = {"--ui", "--trace",  "--server_id", "A"};
//		String[] myArgs = {"--ui",  "--server_id", "A"};	
		String[] myArgs = {"--ui",  "--server_id", SERVER_NAME};	

		VirtualToolkit.setDefaultToolkit(new SwingToolkit());
		SyncServer.instantiate(myArgs);
	}
}
//END OF FILE
